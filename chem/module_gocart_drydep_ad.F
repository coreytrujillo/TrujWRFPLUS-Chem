MODULE A_MODULE_GOCART_DRYDEP
  IMPLICIT NONE
CONTAINS
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.6 (r4756) - 12 Feb 2013 10:43
!
!  Differentiation of gocart_drydep_driver in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: ddvel rmol
!   with respect to varying inputs: ust aer_res ddvel znt rmol
!                pbl
  SUBROUTINE A_GOCART_DRYDEP_DRIVER(dtstep, config_flags, numgas, t_phy&
&    , moist, p8w, t8w, rmol, a_rmol, aer_res, a_aer_res, p_phy, chem, &
&    rho_phy, dz8w, ddvel, a_ddvel, xland, hfx, ivgtyp, tsk, vegfra, pbl&
&    , a_pbl, ust, a_ust, znt, a_znt, xlat, xlong, &
               dustdrydep_1,dustdrydep_2,dustdrydep_3,         &
               dustdrydep_4,dustdrydep_5,                      &
               depvelocity, ids, ide, jds, jde, &
&    kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte&
&  )
    USE module_model_constants
    USE module_configure
    USE module_state_description
    INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, its, ite, jts, jte, kts, kte, numgas
    INTEGER, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: ivgtyp
    REAL, INTENT(IN) :: dtstep
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme, num_moist), INTENT(IN) ::&
&    moist
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme, num_chem), INTENT(INOUT) &
&    :: chem
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: t_phy, &
&    p_phy, dz8w, t8w, p8w, rho_phy
    REAL, DIMENSION(its:ite, jts:jte, num_chem), INTENT(INOUT) :: ddvel
    REAL, DIMENSION(its:ite, jts:jte, num_chem), INTENT(INOUT) :: &
&    a_ddvel
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: tsk, vegfra, pbl, &
&    ust, xlat, xlong, rmol, xland, znt, hfx
    REAL, DIMENSION(ims:ime, jms:jme) :: a_pbl, a_ust, a_rmol, a_znt
    REAL, DIMENSION(its:ite, jts:jte), INTENT(IN) :: aer_res
    REAL, DIMENSION(its:ite, jts:jte) :: a_aer_res
    REAL, DIMENSION( ims:ime, jms:jme ), INTENT(INOUT) ::        &
                dustdrydep_1, dustdrydep_2, dustdrydep_3,       &
                dustdrydep_4, dustdrydep_5, depvelocity
!! .. Local Scalars ..
    INTEGER :: iland, iprt, iseason, jce, jcs, n, nr, ipr, jpr, nvr, &
&    idrydep_onoff, imx, jmx, lmx
    INTEGER :: ii, jj, kk, i, j, k, nv
    INTEGER, DIMENSION(1, 1) :: ilwi, ireg
    REAL :: clwchem, dvfog, dvpart, rad, rhchem, ta, vegfrac, z1, zntt
!     real*8, DIMENSION (1,1,1,3) :: erodin
!     real*8, DIMENSION (5) :: tc,bems
!     real*8, dimension (1,1) :: z0,w10m,gwet,airden,airmas,delz_sfc,hflux,ts,pblz,ustar,ps
    REAL, DIMENSION(1, 1) :: z0, airden, delz_sfc, hflux, ts, pblz, &
&    ustar, ps
    REAL, DIMENSION(1, 1) :: a_z0, a_pblz, a_ustar
    REAL :: dvel(1, 1), drydf(1, 1)
    REAL :: a_dvel(1, 1)
    LOGICAL :: highnh3, rainflag, vegflag, wetflag
    TYPE(GRID_CONFIG_REC_TYPE), INTENT(IN) :: config_flags
    INTEGER :: branch
    INTEGER :: ad_from
    INTEGER :: ad_to
    INTEGER :: min2
    INTEGER :: min3
    INTEGER :: max2
    INTEGER :: max3
    imx = 1
    jmx = 1
    IF (jds + 1 .LT. jts) THEN
      max3 = jts
    ELSE
      max3 = jds + 1
    END IF
    IF (jde - 1 .GT. jte) THEN
      min3 = jte
    ELSE
      min3 = jde - 1
    END IF
    DO j=max3,min3
      IF (ids + 1 .LT. its) THEN
        max2 = its
      ELSE
        max2 = ids + 1
      END IF
      IF (ide - 1 .GT. ite) THEN
        min2 = ite
      ELSE
        min2 = ide - 1
      END IF
      ad_from = max2
      DO i=ad_from,min2
! for aerosols, ii=1 or ii=2
!     if(ivgtyp(i,j).eq.19.or.ivgtyp(i,j).eq.23)ii=1
        IF (1.0D-1 .LT. ust(i, j)) THEN
          CALL PUSHREAL8(ustar(1, 1))
          ustar(1, 1) = ust(i, j)
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHREAL8(ustar(1, 1))
          ustar(1, 1) = 1.0D-1
          CALL PUSHCONTROL1B(1)
        END IF
        CALL PUSHREAL8(pblz(1, 1))
        pblz(1, 1) = pbl(i, j)
        CALL PUSHREAL8(z0(1, 1))
        z0(1, 1) = znt(i, j)
!    if(i.eq.23.and.j.eq.74)ipr=1
      END DO
      CALL PUSHINTEGER4(i - 1)
      CALL PUSHINTEGER4(ad_from)
    END DO
!    a_ust = 0.0_8
!    a_znt = 0.0_8
!    a_pbl = 0.0_8
!    a_aer_res = 0.0_8
    a_ustar = 0.0_8
    a_z0 = 0.0_8
    a_dvel = 0.0_8
    a_pblz = 0.0_8
    DO j=min3,max3,-1
      CALL POPINTEGER4(ad_from)
      CALL POPINTEGER4(ad_to)
      DO i=ad_to,ad_from,-1
        IF (p_msa .gt. 0) a_dvel(1, 1) = a_dvel(1, 1) + a_ddvel(i, j, p_msa)
        a_ddvel(i, j, p_msa) = 0.0_8
        IF (p_sulf .gt. 0) a_dvel(1, 1) = a_dvel(1, 1) + a_ddvel(i, j, p_sulf)
        a_ddvel(i, j, p_sulf) = 0.0_8
        DO nv = num_chem,max(numgas+1,2),-1
          a_dvel(1, 1) = a_dvel(1, 1) + a_ddvel(i, j, nv)
          a_ddvel(i, j, nv) = 0.0_8
        END DO
!!        DO nv=num_chem,p_p25,-1
!!          a_dvel(1, 1) = a_dvel(1, 1) + a_ddvel(i, j, nv)
!!          a_ddvel(i, j, nv) = 0.0_8
!!        END DO
        CALL A_DEPVEL_GOCART(config_flags, ipr, ii, imx, jmx, lmx, &
&                       airden, delz_sfc, pblz, a_pblz, ts, ustar, &
&                       a_ustar, hflux, ilwi, ps, z0, a_z0, dvel, a_dvel&
&                       , drydf, g, rmol(i, j), a_rmol(i, j), aer_res(i, &
&                       j), a_aer_res(i, j))
        CALL POPREAL8(z0(1, 1))
        a_znt(i, j) = a_znt(i, j) + a_z0(1, 1)
        a_z0(1, 1) = 0.0_8
        CALL POPREAL8(pblz(1, 1))
        a_pbl(i, j) = a_pbl(i, j) + a_pblz(1, 1)
        a_pblz(1, 1) = 0.0_8
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(ustar(1, 1))
          a_ust(i, j) = a_ust(i, j) + a_ustar(1, 1)
          a_ustar(1, 1) = 0.0_8
        ELSE
          CALL POPREAL8(ustar(1, 1))
          a_ustar(1, 1) = 0.0_8
        END IF
        a_dvel(1, 1) = 0.0_8
      END DO
    END DO
    DO nv=num_chem,numgas+1,-1
      DO j=jte,jts,-1
        DO i=ite,its,-1
          a_ddvel(i, j, nv) = 0.0_8
        END DO
      END DO
    END DO
  END SUBROUTINE A_GOCART_DRYDEP_DRIVER

!  Differentiation of depvel_gocart in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: ustar z0 aer_res dvel pblz
!                rmol
!   with respect to varying inputs: ustar z0 aer_res dvel pblz
!                rmol
  SUBROUTINE A_DEPVEL_GOCART(config_flags, ipr, ii, imx, jmx, lmx, &
&    airden, delz_sfc, pblz, a_pblz, ts, ustar, a_ustar, hflux, ilwi, ps&
&    , z0, a_z0, dvel, a_dvel, drydf, g0, rmol, a_rmol, aer_res, &
&    a_aer_res)

! ****************************************************************************
! *                                                                          *
! *  Calculate dry deposition velocity.                                      *
! *                                                                          *
! *  Input variables:                                                        *
! *    AEROSOL(k)      - Logical, T = aerosol species, F = gas species       *
! *    IREG(i,j)       - # of landtypes in grid square                       *
! *    ILAND(i,j,ldt)  - Land type ID for element ldt =1,IREG(i,j)           *
! *    IUSE(i,j,ldt)   - Fraction of gridbox area occupied by land type      *
! *                      element ldt                                         *
! *    USTAR(i,j)      - Friction velocity (m s-1)                           *
! *    DELZ_SFC(i,j)   - Thickness of layer above surface                    *
! *    PBLZ(i,j)       - Mixing depth (m)                                    *
! *    Z0(i,j)         - Roughness height (m)                                *
! *                                                                          *
! *  Determined in this subroutine (local):                                  *
! *    OBK             - Monin-Obukhov length (m): set to 1.E5 m under       *
! *                      neutral conditions                                  *
! *    Rs(ldt)         - Bulk surface resistance(s m-1) for species k to     * 
! *                      surface ldt                                         *
! *    Ra              - Aerodynamic resistance.                             *
! *    Rb              - Sublayer resistance.                                *
! *    Rs              - Surface resistance.                                 *
! *    Rttl            - Total deposition resistance (s m-1) for species k   *
! *                      Rttl(k) = Ra + Rb + Rs.                             *
! *                                                                          *
! *  Returned:                                                               *
! *    DVEL(i,j,k)     - Deposition velocity (m s-1) of species k            *
! *    DRYDf(i,j,k)    - Deposition frequency (s-1) of species k,            *
! *                    = DVEL / DELZ_SFC                                     *
! *                                                                          *
! ****************************************************************************

    USE module_configure

    IMPLICIT NONE

    INTEGER, INTENT(IN) :: imx, jmx, lmx
    REAL*8, INTENT(IN) :: airden(imx, jmx), delz_sfc(imx, jmx)
    REAL*8, INTENT(IN) :: hflux(imx, jmx), ts(imx, jmx)
    REAL*8, INTENT(IN) :: ustar(imx, jmx), pblz(imx, jmx)
    REAL*8 :: a_ustar(imx, jmx), a_pblz(imx, jmx)
    REAL*8, INTENT(IN) :: ps(imx, jmx)
    INTEGER, INTENT(IN) :: ilwi(imx, jmx)
    REAL*8, INTENT(IN) :: z0(imx, jmx)
    REAL*8 :: a_z0(imx, jmx)
    REAL, INTENT(IN) :: g0, rmol, aer_res
    REAL :: a_rmol, a_aer_res
    REAL*8 :: dvel(imx, jmx), drydf(imx, jmx)
    REAL*8 :: a_dvel(imx, jmx)
    TYPE(GRID_CONFIG_REC_TYPE), INTENT(IN) :: config_flags
    REAL*8 :: obk, vds, czh, rttl, frac, logmfrac, psi_h, cz, eps
    REAL*8 :: a_obk, a_vds, a_czh, a_rttl, a_frac, a_logmfrac, a_psi_h, &
&    a_eps
    REAL*8 :: vd, ra, rb, rs
    REAL*8 :: a_vd, a_ra, a_rs
    INTEGER :: ipr, i, j, k, ldt, iolson, ii
    CHARACTER(len=50) :: msg
    REAL*8 :: prss, tempk, tempc, xnu, ckustr, reyno, aird, diam, xm, z
    REAL*8 :: frpath, speed, dg, dw, rt
    REAL*8 :: rad0, rix, gfact, gfaci, rdc, rixx, rluxx, rgsx, rclx
    REAL*8 :: dtmp1, dtmp2, dtmp3, dtmp4
    REAL*8 :: biofit, vk
    INTEGER :: branch
    REAL*8 :: temp2
    REAL*8 :: temp1
    REAL*8 :: temp0
    INTRINSIC EXP
    REAL*8 :: min2
    REAL*8 :: tempb0
    INTRINSIC LOG
    REAL*8 :: a_min2
    REAL*8 :: tempb
    REAL*8 :: a_y1
    REAL*8 :: abs0
    REAL*8 :: temp
    REAL*8 :: y1
! executable statements
j_loop:DO j=1,jmx
i_loop:DO i=1,imx
        vk = 0.4D0
        vd = 0._8
! only required for gases (SO2)
        rb = 0._8
        IF (rmol .NE. 0.D0) THEN
          CALL PUSHREAL8(obk)
          obk = 1.D0/rmol
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHREAL8(obk)
          obk = 1.D5
          CALL PUSHCONTROL1B(1)
        END IF
!       cz = delz_sfc(i,j) / 2.0_8 ! center of the grid box above surface
        cz = 2.0D0
! ****************************************************************************
! *  (1) Aerosodynamic resistance Ra and sublayer resistance Rb.             *
! *                                                                          *
! *  The Reynolds number REYNO diagnoses whether a surface is                *
! *  aerodynamically rough (REYNO > 10) or smooth.  Surface is               *
! *  rough in all cases except over water with low wind speeds.              *
! *                                                                          *
! *  For gas species over land and ice (REYNO >= 10) and for aerosol         *
! *  species for all surfaces:                                               *
! *                                                                          *
! *      Ra = 1./VT          (VT from GEOS Kzz at L=1, m/s).                 *
! *                                                                          *
! *  The following equations are from Walcek et al, 1986:                    *
! *                                                                          *
! *  For gas species when REYNO < 10 (smooth), Ra and Rb are combined        *
! *  as Ra:                                                                  *
! *                                                                          *
! *      Ra = { ln(ku* z1/Dg) - Sh } / ku*           eq.(13)                 *
! *                                                                          *
! *      where z1 is the altitude at the center of the lowest model layer    *
! *               (CZ);                                                      *
! *            Sh is a stability correction function;                        *
! *            k  is the von Karman constant (0.4, vK);                      *
! *            u* is the friction velocity (USTAR).                          *
! *                                                                          *
! *   Sh is computed as a function of z1 and L       eq ( 4) and (5)):       *
! *                                                                          *
! *    0 < z1/L <= 1:     Sh = -5 * z1/L                                     *
! *    z1/L < 0:          Sh = exp{ 0.598 + 0.39*ln(E) - 0.09(ln(E))^2 }     *
! *                       where E = min(1,-z1/L) (Balkanski, thesis).        *
! *                                                                          *
! *   For gas species when REYNO >= 10,                                      *
! *                                                                          *
! *      Rb = 2/ku* (Dair/Dg)**(2/3)                 eq.(12)                 *
! *      where Dg is the gas diffusivity, and                                *
! *            Dair is the air diffusivity.                                  *
! *                                                                          *
! *  For aerosol species, Rb is combined with surface resistance as Rs.      *
! *                                                                          *
! ****************************************************************************
        frac = cz/obk
        IF (frac .GT. 1.0D0) THEN
          frac = 1.0D0
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (frac .GT. 0.0D0 .AND. frac .LE. 1.0D0) THEN
          CALL PUSHREAL8(psi_h)
          psi_h = -(5.0D0*frac)
          CALL PUSHCONTROL2B(0)
        ELSE IF (frac .LT. 0.0D0) THEN
          IF (1.0D0 .GT. -frac) THEN
            CALL PUSHREAL8(eps)
            eps = -frac
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHREAL8(eps)
            eps = 1.0D0
            CALL PUSHCONTROL1B(1)
          END IF
          CALL PUSHREAL8(logmfrac)
          logmfrac = LOG(eps)
          CALL PUSHREAL8(psi_h)
          psi_h = EXP(0.598D0 + 0.39D0*logmfrac - 0.09D0*logmfrac**2)
          CALL PUSHCONTROL2B(1)
        ELSE
          CALL PUSHCONTROL2B(2)
        END IF
!--------------------------------------------------------------
!  Aerosol species, Rs here is the combination of Rb and Rs.
        ra = (LOG(cz/z0(i, j))-psi_h)/(vk*ustar(i, j))
        vds = 0.002D0*ustar(i, j)
        IF (obk .LT. 0.0D0) THEN
          CALL PUSHREAL8(vds)
          vds = vds*(1.0D0+(-(300.0D0/obk))**0.6667D0)
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        czh = pblz(i, j)/obk
        IF (czh .LT. -30.0D0) THEN
          vds = 0.0009D0*ustar(i, j)*(-czh)**0.6667D0
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (config_flags%chem_opt .NE. chem_vash .AND. config_flags%&
&            chem_opt .NE. dust) THEN
          ra = aer_res
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        IF (vds .GT. 2.0D-3) THEN
          CALL PUSHREAL8(min2)
          min2 = 2.0D-3
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHREAL8(min2)
          min2 = vds
          CALL PUSHCONTROL1B(1)
        END IF
! --Set Vds to be less than VDSMAX (entry in input file divided --
!   by 1.E4). VDSMAX is taken from Table 2 of Walcek et al. [1986].
!   Invert to get corresponding R
!          if(ii.eq.1) then
!             rs=1.0_8/MIN(vds,2.0e-2_8)
!          else
        rs = 1.0D0/min2
        IF (rs .GT. 9.9990D3) THEN
          y1 = 9.9990D3
          CALL PUSHCONTROL1B(0)
        ELSE
          y1 = rs
          CALL PUSHCONTROL1B(1)
        END IF
        IF (1.0D0 .LT. y1) THEN
          rs = y1
          CALL PUSHCONTROL1B(0)
        ELSE
          rs = 1.0D0
          CALL PUSHCONTROL1B(1)
        END IF
        CALL PUSHREAL8(rttl)
! ****************************************************************************
! *                                                                          *
! *  Compute dry deposition velocity.                                        *
! *                                                                          *
! *  IUSE is the fraction of the grid square occupied by surface ldt in      *
! *  units of per mil (IUSE=500 -> 50% of the grid square).  Add the         *
! *  contribution of surface type ldt to the deposition velocity; this is    *
! *  a loop over all surface types in the gridbox.                           *
! *                                                                          *
! *  Total resistance = Ra + Rb + Rs.
! *                                                                          *
! ****************************************************************************
        rttl = ra + rb + rs
        vd = vd + 1.0D0/rttl
! ------ Load array DVEL ------
        dvel(i, j) = vd
! -- Set a minimum value for DVEL
!    MIN(VdSO2)      = 2.0e-3 m/s  over ice
!                    = 3.0e-3 m/s  over land
!    MIN(vd_aerosol) = 1.0e-4 m/s
        IF (dvel(i, j) .LT. 1.0D-4) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
      END DO i_loop
    END DO j_loop
    a_psi_h = 0.0D0
    DO j=jmx,1,-1
      DO i=imx,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) a_dvel(i, j) = 0.0_8
        a_vd = a_dvel(i, j)
        a_dvel(i, j) = 0.0_8
        a_rttl = -(a_vd/rttl**2)
        CALL POPREAL8(rttl)
        a_ra = a_rttl
        a_rs = a_rttl
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          a_y1 = a_rs
        ELSE
          a_y1 = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          a_rs = 0.0_8
        ELSE
          a_rs = a_y1
        END IF
        a_min2 = -(a_rs/min2**2)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(min2)
          a_vds = 0.0_8
        ELSE
          CALL POPREAL8(min2)
          a_vds = a_min2
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          a_aer_res = a_aer_res + a_ra
          a_ra = 0.0_8
        END IF
        czh = pblz(i, j)/obk
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          a_ustar(i, j) = a_ustar(i, j) + 0.0009D0*(-czh)**0.6667D0*&
&            a_vds
          a_czh = -(0.6667D0*(-czh)**(-0.3333D0)*ustar(i, j)*0.0009D0*&
&            a_vds)
          a_vds = 0.0D0
        ELSE
          a_czh = 0.0D0
        END IF
        a_pblz(i, j) = a_pblz(i, j) + a_czh/obk
        a_obk = -(pblz(i, j)*a_czh/obk**2)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(vds)
          temp2 = 300.0D0/obk
          a_obk = a_obk + 0.6667D0*(-temp2)**(-0.3333D0)*vds*temp2*a_vds/&
&            obk
          a_vds = ((-temp2)**0.6667D0+1.0D0)*a_vds
        END IF
        vk = 0.4D0
        cz = 2.0D0
        temp1 = vk*ustar(i, j)
        tempb0 = a_ra/temp1
        temp0 = z0(i, j)
        temp = cz/temp0
        a_ustar(i, j) = a_ustar(i, j) + 0.002D0*a_vds - (LOG(temp)-psi_h&
&          )*vk*tempb0/temp1
        a_z0(i, j) = a_z0(i, j) - tempb0/temp0
        a_psi_h = a_psi_h - tempb0
        CALL POPCONTROL2B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(psi_h)
          a_frac = -(5.0D0*a_psi_h)
          a_psi_h = 0.0D0
        ELSE IF (branch .EQ. 1) THEN
          CALL POPREAL8(psi_h)
          tempb = EXP(0.39D0*logmfrac-0.09D0*logmfrac**2+0.598D0)*&
&            a_psi_h
          a_logmfrac = (0.39D0-0.09D0*2*logmfrac)*tempb
          CALL POPREAL8(logmfrac)
          a_eps = a_logmfrac/eps
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL8(eps)
            a_frac = -a_eps
          ELSE
            CALL POPREAL8(eps)
            a_frac = 0.0D0
          END IF
          a_psi_h = 0.0D0
        ELSE
          a_frac = 0.0D0
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) a_frac = 0.0D0
        a_obk = a_obk - cz*a_frac/obk**2
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(obk)
          a_rmol = a_rmol - a_obk/rmol**2
        ELSE
          CALL POPREAL8(obk)
        END IF
      END DO
    END DO
  END SUBROUTINE A_DEPVEL_GOCART
END MODULE A_MODULE_GOCART_DRYDEP
