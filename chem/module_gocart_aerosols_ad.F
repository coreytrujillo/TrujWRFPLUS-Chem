!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.6 (r4756) - 12 Feb 2013 10:43
!
MODULE a_module_gocart_aerosols
  USE module_model_constants, only: mwdry
  IMPLICIT NONE
  INTEGER, PARAMETER :: nbc1=1, noc1=2, nbc2=3, noc2=4

CONTAINS
!  Differentiation of gocart_aerosols_driver in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: chem
!   with respect to varying inputs: chem
  SUBROUTINE a_gocart_aerosols_driver(ktau, dt, config_flags, t_phy, &
&    moist, chem, a_chem, rho_phy, dz8w, p8w, dx, g, ids, ide, jds, jde, &
&    kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte&
&  )
    USE module_configure
    USE module_state_description
    USE module_gocart_aerosols, ONLY: chem_1, chem_2
    IMPLICIT NONE
    TYPE(GRID_CONFIG_REC_TYPE), INTENT(IN) :: config_flags
    INTEGER, INTENT(IN) :: ktau, ids, ide, jds, jde, kds, kde, ims, ime&
&    , jms, jme, kms, kme, its, ite, jts, jte, kts, kte
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme, num_moist), INTENT(IN) ::&
&    moist
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme, num_chem), INTENT(INOUT) &
&    :: chem
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme, num_chem), INTENT(INOUT) &
&    :: a_chem
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: t_phy, &
&    dz8w, p8w, rho_phy
    REAL, INTENT(IN) :: dt, dx, g
    INTEGER :: ndt1, nmx, i, j, k, imx, jmx, lmx
    REAL*8, DIMENSION(1, 1, 1) :: tmp, airden, airmas
    REAL*8 :: chmlos(1, 1, 1, 4)
    REAL*8 :: bchmlos(1, 1, 4)
    REAL*8 :: pc2(1, 1, 1, 2)
    REAL*8 :: a_pc2(1, 1, 1, 2)
    REAL*8 :: tc(4), tt1, tt2
    REAL*8 :: a_tc(4), a_tt1, a_tt2
    REAL, PARAMETER :: mw_c=12.
    REAL*8 :: tempb
    imx = 1
    jmx = 1
    lmx = 1
    nmx = 4
    ndt1 = IFIX(dt)
    DO j=jts,jte
      DO k=kts,kte-1
        DO i=its,ite
          airmas(1, 1, 1) = -((p8w(i, k+1, j)-p8w(i, k, j))*dx*dx/g)
          CALL PUSHREAL8(pc2(1, 1, 1, 1))
          pc2(1, 1, 1, 1) = 0.d0
          CALL PUSHREAL8(pc2(1, 1, 1, 2))
          pc2(1, 1, 1, 2) = 0.d0
          tc(1) = chem(i, k, j, p_bc1)/mw_c*mwdry*1.d-9
          tc(2) = chem(i, k, j, p_oc1)/mw_c*mwdry*1.d-9
          tc(3) = chem(i, k, j, p_bc2)/mw_c*mwdry*1.d-9
          tc(4) = chem(i, k, j, p_oc2)/mw_c*mwdry*1.d-9
          CALL PUSHREAL8ARRAY(pc2, 2)
          CALL PUSHREAL8ARRAY(tc, 4)
          CALL CHEM_1(imx, jmx, lmx, nmx, ndt1, airmas, tc, chmlos, &
&                bchmlos, pc2)
          CALL PUSHREAL8ARRAY(tc, 4)
          CALL CHEM_2(imx, jmx, lmx, nmx, ndt1, airmas, tc, pc2)
        END DO
      END DO
    END DO
    a_pc2 = 0.0_8
    a_tc = 0.0_8
    DO j=jte,jts,-1
      DO k=kte-1,kts,-1
        DO i=ite,its,-1
          tempb = mw_c*1.d9*a_chem(i, k, j, p_oc2)/mwdry
          a_tc(4) = a_tc(4) + tempb
          a_tt2 = 8.d0*tempb
          a_chem(i, k, j, p_oc2) = 0.0_8
          a_tc(3) = a_tc(3) + mw_c*1.d9*a_chem(i, k, j, p_bc2)/mwdry
          a_chem(i, k, j, p_bc2) = 0.0_8
          a_tc(2) = a_tc(2) + mw_c*1.d9*a_chem(i, k, j, p_oc1)/mwdry
          a_chem(i, k, j, p_oc1) = 0.0_8
          a_tc(1) = a_tc(1) + mw_c*1.d9*a_chem(i, k, j, p_bc1)/mwdry
          a_chem(i, k, j, p_bc1) = 0.0_8
          a_tc(3) = a_tc(3) + a_tt2
          a_tt1 = -a_tt2
          CALL POPREAL8ARRAY(tc, 4)
          CALL A_CHEM_2(imx, jmx, lmx, nmx, ndt1, airmas, tc, a_tc, pc2&
&                  , a_pc2)
          CALL POPREAL8ARRAY(tc, 4)
          CALL POPREAL8ARRAY(pc2, 2)
          CALL A_CHEM_1(imx, jmx, lmx, nmx, ndt1, airmas, tc, a_tc, &
&                  chmlos, bchmlos, pc2, a_pc2)
          a_tc(3) = a_tc(3) + a_tt1
          a_chem(i, k, j, p_oc2) = a_chem(i, k, j, p_oc2) + mwdry*1.d-9*&
&            a_tc(4)/mw_c
          a_tc(4) = 0.0_8
          a_chem(i, k, j, p_bc2) = a_chem(i, k, j, p_bc2) + mwdry*1.d-9*&
&            a_tc(3)/mw_c
          a_tc(3) = 0.0_8
          a_chem(i, k, j, p_oc1) = a_chem(i, k, j, p_oc1) + mwdry*1.d-9*&
&            a_tc(2)/mw_c
          a_tc(2) = 0.0_8
          a_chem(i, k, j, p_bc1) = a_chem(i, k, j, p_bc1) + mwdry*1.d-9*&
&            a_tc(1)/mw_c
          a_tc(1) = 0.0_8
          CALL POPREAL8(pc2(1, 1, 1, 2))
          a_pc2(1, 1, 1, 2) = 0.0_8
          CALL POPREAL8(pc2(1, 1, 1, 1))
          a_pc2(1, 1, 1, 1) = 0.0_8
        END DO
      END DO
    END DO
  END SUBROUTINE a_gocart_aerosols_driver

!  Differentiation of sum_pm_gocart in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: pm10 pm2_5_dry_ec chem pm2_5_dry
!   with respect to varying inputs: pm10 pm2_5_dry_ec alt chem
!                pm2_5_dry
  SUBROUTINE a_sum_pm_gocart(alt, a_alt, chem, a_chem, pm2_5_dry, &
&    a_pm2_5_dry, pm2_5_dry_ec, a_pm2_5_dry_ec, pm10, a_pm10, ids, ide, &
&    jds, jde, kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte&
&    , kts, kte)
    USE module_configure
    USE module_state_description
    USE module_data_gocartchem, only: nh4_mfac,oc_mfac
    IMPLICIT NONE
    REAL, PARAMETER :: mwso4=96.0576
    INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, its, ite, jts, jte, kts, kte
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: &
&    pm2_5_dry, pm2_5_dry_ec, pm10
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: &
&    a_pm2_5_dry
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: alt
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_alt
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme, num_chem), INTENT(IN) :: &
&    chem
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme, num_chem) :: a_chem
    REAL :: d_2_5, s_2_5, d_10, sulfate
    REAL :: a_sulfate
    INTEGER :: i, j, k, ii, jj, n
    INTEGER :: branch
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: &
&    a_pm2_5_dry_ec
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: a_pm10
    REAL :: tempb0
    REAL :: tempb
    d_2_5 = 0.286
    s_2_5 = 0.942
    d_10 = 0.87
    pm2_5_dry(its:ite, kts:kte, jts:jte) = 0.
    pm10(its:ite, kts:kte, jts:jte) = 0.
    DO j=jts,jte
      IF (jde - 1 .GT. j) THEN
        CALL PUSHINTEGER4(jj)
        jj = j
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHINTEGER4(jj)
        jj = jde - 1
        CALL PUSHCONTROL1B(1)
      END IF
      DO k=kts,kte
        DO i=its,ite
          IF (ide - 1 .GT. i) THEN
            CALL PUSHINTEGER4(ii)
            ii = i
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHINTEGER4(ii)
            ii = ide - 1
            CALL PUSHCONTROL1B(1)
          END IF
          sulfate = chem(ii, k, jj, p_sulf)*mwso4/mwdry*1.d3
          DO n=p_p25,p_dust_1
            pm2_5_dry(i, k, j) = pm2_5_dry(i, k, j) + chem(ii, k, jj, n)
          END DO
          pm2_5_dry(i, k, j) = pm2_5_dry(i, k, j) + chem(ii, k, jj, &
&            p_dust_2)*d_2_5 + chem(ii, k, jj, p_seas_1) + chem(ii, k, jj&
&            , p_seas_2)*s_2_5 + sulfate*nh4_mfac + (chem(ii, k, jj, &
&            p_oc1)+chem(ii, k, jj, p_oc2))*(oc_mfac-1.)
        END DO
      END DO
    END DO
    DO j=jts,jte
      IF (jde - 1 .GT. j) THEN
        CALL PUSHINTEGER4(jj)
        jj = j
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHINTEGER4(jj)
        jj = jde - 1
        CALL PUSHCONTROL1B(1)
      END IF
      DO k=kts,kte
        DO i=its,ite
          IF (ide - 1 .GT. i) THEN
            CALL PUSHINTEGER4(ii)
            ii = i
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHINTEGER4(ii)
            ii = ide - 1
            CALL PUSHCONTROL1B(1)
          END IF
          sulfate = chem(ii, k, jj, p_sulf)*mwso4/mwdry*1.d3
          DO n=p_p25,p_dust_3
            pm10(i, k, j) = pm10(i, k, j) + chem(ii, k, jj, n)
          END DO
          DO n=p_seas_1,p_seas_3
            pm10(i, k, j) = pm10(i, k, j) + chem(ii, k, jj, n)
          END DO
          pm10(i, k, j) = pm10(i, k, j) + sulfate*nh4_mfac + chem(ii, k&
&            , jj, p_dust_4)*d_10 + chem(ii, k, jj, p_p10) + (chem(ii, k&
&            , jj, p_oc1)+chem(ii, k, jj, p_oc2))*(oc_mfac-1.)
        END DO
      END DO
    END DO
    DO j=jte,jts,-1
      DO k=kte,kts,-1
        DO i=ite,its,-1
          tempb0 = a_pm10(i, k, j)/alt(ii, k, jj)
          a_alt(ii, k, jj) = a_alt(ii, k, jj) - pm10(i, k, j)*tempb0/&
&            alt(ii, k, jj)
          a_pm10(i, k, j) = tempb0
          a_sulfate = nh4_mfac*a_pm10(i, k, j)
          a_chem(ii, k, jj, p_dust_4) = a_chem(ii, k, jj, p_dust_4) + &
&            d_10*a_pm10(i, k, j)
          a_chem(ii, k, jj, p_p10) = a_chem(ii, k, jj, p_p10) + a_pm10(i&
&            , k, j)
          a_chem(ii, k, jj, p_oc1) = a_chem(ii, k, jj, p_oc1) + (oc_mfac&
&            -1.)*a_pm10(i, k, j)
          a_chem(ii, k, jj, p_oc2) = a_chem(ii, k, jj, p_oc2) + (oc_mfac&
&            -1.)*a_pm10(i, k, j)
          DO n=p_seas_3,p_seas_1,-1
            a_chem(ii, k, jj, n) = a_chem(ii, k, jj, n) + a_pm10(i, k, j&
&              )
          END DO
          DO n=p_dust_3,p_p25,-1
            a_chem(ii, k, jj, n) = a_chem(ii, k, jj, n) + a_pm10(i, k, j&
&              )
          END DO
          a_chem(ii, k, jj, p_sulf) = a_chem(ii, k, jj, p_sulf) + mwso4*&
&            1.d3*a_sulfate/mwdry
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPINTEGER4(ii)
          ELSE
            CALL POPINTEGER4(ii)
          END IF
        END DO
      END DO
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPINTEGER4(jj)
      ELSE
        CALL POPINTEGER4(jj)
      END IF
    END DO
    DO j=jte,jts,-1
      DO k=kte,kts,-1
        DO i=ite,its,-1
          tempb = a_pm2_5_dry(i, k, j)/alt(ii, k, jj)
          a_alt(ii, k, jj) = a_alt(ii, k, jj) - pm2_5_dry(i, k, j)*&
&            tempb/alt(ii, k, jj)
          a_pm2_5_dry(i, k, j) = tempb
          a_chem(ii, k, jj, p_dust_2) = a_chem(ii, k, jj, p_dust_2) + &
&            d_2_5*a_pm2_5_dry(i, k, j)
          a_chem(ii, k, jj, p_seas_1) = a_chem(ii, k, jj, p_seas_1) + &
&            a_pm2_5_dry(i, k, j)
          a_chem(ii, k, jj, p_seas_2) = a_chem(ii, k, jj, p_seas_2) + &
&            s_2_5*a_pm2_5_dry(i, k, j)
          a_sulfate = nh4_mfac*a_pm2_5_dry(i, k, j)
          a_chem(ii, k, jj, p_oc1) = a_chem(ii, k, jj, p_oc1) + (oc_mfac&
&            -1.)*a_pm2_5_dry(i, k, j)
          a_chem(ii, k, jj, p_oc2) = a_chem(ii, k, jj, p_oc2) + (oc_mfac&
&            -1.)*a_pm2_5_dry(i, k, j)
          DO n=p_dust_1,p_p25,-1
            a_chem(ii, k, jj, n) = a_chem(ii, k, jj, n) + a_pm2_5_dry(i&
&              , k, j)
          END DO
          a_chem(ii, k, jj, p_sulf) = a_chem(ii, k, jj, p_sulf) + mwso4*&
&            1.d3*a_sulfate/mwdry
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPINTEGER4(ii)
          ELSE
            CALL POPINTEGER4(ii)
          END IF
        END DO
      END DO
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPINTEGER4(jj)
      ELSE
        CALL POPINTEGER4(jj)
      END IF
    END DO
    a_pm2_5_dry_ec(its:ite, kts:kte, jts:jte) = 0.0_8
    a_pm10(its:ite, kts:kte, jts:jte) = 0.0_8
    a_pm2_5_dry(its:ite, kts:kte, jts:jte) = 0.0_8
  END SUBROUTINE a_sum_pm_gocart

!  Differentiation of chem_1 in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: pc2 tc
!   with respect to varying inputs: pc2 tc
  SUBROUTINE A_CHEM_1(imx, jmx, lmx, nmx, ndt1, airm, tc, a_tc, chmlos, &
&    bchmlos, pc2, a_pc2)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: lmx, nmx, imx, jmx, ndt1
    REAL*8, INTENT(IN) :: airm(imx, jmx, lmx)
    REAL*8, INTENT(INOUT) :: tc(imx, jmx, lmx, nmx)
    REAL*8 :: a_tc(imx, jmx, lmx, nmx)
    REAL*8, INTENT(INOUT) :: chmlos(imx, jmx, lmx, nmx)
    REAL*8, INTENT(INOUT) :: bchmlos(imx, jmx, nmx)
    REAL*8 :: pc2(imx, jmx, lmx, 2)
    REAL*8 :: a_pc2(imx, jmx, lmx, 2)
    REAL*8 :: r1, c0, r2, rkt, c1
    REAL*8 :: a_c0, a_c1
    INTEGER :: np, n, i, j, l
    INTEGER :: branch
    INTRINSIC EXP
    INTRINSIC MAX
    INTRINSIC SUM
    INTRINSIC REAL
    REAL*8 :: tempb
    r1 = 4.63d-6
    DO n=1,nmx
      IF (n .EQ. nbc1 .OR. n .EQ. noc1) THEN
        IF (n .EQ. nbc1) THEN
          CALL PUSHINTEGER4(np)
          np = 1
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (n .EQ. noc1) THEN
          CALL PUSHINTEGER4(np)
          np = 2
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        DO l=1,lmx
          DO j=1,jmx
            DO i=1,imx
              c0 = tc(i, j, l, n)
              r2 = 0.0d0
              CALL PUSHREAL8(rkt)
              rkt = (r1+r2)*REAL(ndt1)
              c1 = c0*EXP(-rkt)
              IF (c1 .LT. 1.0d-32) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
            END DO
          END DO
        END DO
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    DO n=nmx,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        DO l=lmx,1,-1
          DO j=jmx,1,-1
            DO i=imx,1,-1
              r2 = 0.0d0
              tempb = r1*a_pc2(i, j, l, np)/(r1+r2)
              a_c0 = tempb
              a_c1 = a_tc(i, j, l, n) - tempb
              a_pc2(i, j, l, np) = 0.0_8
              a_tc(i, j, l, n) = 0.0_8
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) a_c1 = 0.0_8
              a_c0 = a_c0 + EXP(-rkt)*a_c1
              CALL POPREAL8(rkt)
              a_tc(i, j, l, n) = a_tc(i, j, l, n) + a_c0
            END DO
          END DO
        END DO
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) CALL POPINTEGER4(np)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) CALL POPINTEGER4(np)
      END IF
    END DO
  END SUBROUTINE A_CHEM_1

!  Differentiation of chem_2 in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: pc2 tc
!   with respect to varying inputs: pc2 tc
  SUBROUTINE A_CHEM_2(imx, jmx, lmx, nmx, ndt1, airm, tc, a_tc, pc2, &
&    a_pc2)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: lmx, imx, jmx, nmx, ndt1
    REAL*8, INTENT(IN) :: airm(imx, jmx, lmx)
    REAL*8, INTENT(INOUT) :: tc(imx, jmx, lmx, nmx)
    REAL*8 :: a_tc(imx, jmx, lmx, nmx)
    REAL*8, INTENT(IN) :: pc2(imx, jmx, lmx, 2)
    REAL*8 :: a_pc2(imx, jmx, lmx, 2)
    INTEGER :: np, n, i, j, l
    REAL*8 :: c0, pp, rkt, c1
    REAL*8 :: a_c0, a_pp, a_c1
    INTEGER :: branch
    INTRINSIC MAX
    DO n=1,nmx
      IF (n .EQ. nbc2 .OR. n .EQ. noc2) THEN
        IF (n .EQ. nbc2) THEN
          CALL PUSHINTEGER4(np)
          np = 1
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (n .EQ. noc2) THEN
          CALL PUSHINTEGER4(np)
          np = 2
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        DO l=1,lmx
          DO j=1,jmx
            DO i=1,imx
              c0 = tc(i, j, l, n)
              pp = pc2(i, j, l, np)
              c1 = c0 + pp
              IF (c1 .LT. 1.0d-32) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
            END DO
          END DO
        END DO
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    DO n=nmx,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        DO l=lmx,1,-1
          DO j=jmx,1,-1
            DO i=imx,1,-1
              a_c1 = a_tc(i, j, l, n)
              a_tc(i, j, l, n) = 0.0_8
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) a_c1 = 0.0_8
              a_c0 = a_c1
              a_pp = a_c1
              a_pc2(i, j, l, np) = a_pc2(i, j, l, np) + a_pp
              a_tc(i, j, l, n) = a_tc(i, j, l, n) + a_c0
            END DO
          END DO
        END DO
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) CALL POPINTEGER4(np)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) CALL POPINTEGER4(np)
      END IF
    END DO
  END SUBROUTINE A_CHEM_2

END MODULE a_module_gocart_aerosols
