!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.6 (r4756) - 12 Feb 2013 10:43
!
!WRF:MODEL_LAYER:PHYSICS
!
MODULE G_MODULE_SF_PXSFCLAY
  IMPLICIT NONE
!-------------------------------------------------------------------          
!critical Richardson number
  REAL, PARAMETER :: ricrit=0.25D0
! 8.21
  REAL, PARAMETER :: betah=5.0D0
! 6.0
  REAL, PARAMETER :: betam=5.0D0
  REAL, PARAMETER :: bm=13.0D0
  REAL, PARAMETER :: bh=15.7D0
  REAL, PARAMETER :: gamam=19.3D0
  REAL, PARAMETER :: gamah=11.6D0
  REAL, PARAMETER :: pr0=0.95D0
  REAL, PARAMETER :: czo=0.032D0
  REAL, PARAMETER :: ozo=1.d-4
  REAL, PARAMETER :: vconvc=1.0D0

CONTAINS
!  Differentiation of pxsfclay in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: wspd ust cpm hfx br qsfc psih
!                znt psim rmol flqc qfx chs gz1oz0 zol flhc mol
!   with respect to varying inputs: wspd ust u3d cpm pblh hfx br
!                t3d qsfc qv3d psih znt psfc psim rmol flqc qfx
!                chs gz1oz0 v3d th3d zol flhc dz8w mol
!-------------------------------------------------------------------
  SUBROUTINE G_PXSFCLAY(u3d, g_u3d, v3d, g_v3d, t3d, g_t3d, th3d, g_th3d&
&    , qv3d, g_qv3d, p3d, dz8w, g_dz8w, cp, g, rovcp, r, xlv, psfc, &
&    g_psfc, chs, g_chs, chs2, cqs2, cpm, g_cpm, znt, g_znt, ust, g_ust, &
&    pblh, g_pblh, mavail, zol, g_zol, mol, g_mol, regime, psim, g_psim, &
&    psih, g_psih, xland, hfx, g_hfx, qfx, g_qfx, lh, tsk, flhc, g_flhc, &
&    flqc, g_flqc, qgh, qsfc, g_qsfc, rmol, g_rmol, u10, v10, gz1oz0, &
&    g_gz1oz0, wspd, g_wspd, br, g_br, isfflx, dx, svp1, svp2, svp3, &
&    svpt0, ep1, ep2, karman, ids, ide, jds, jde, kds, kde, ims, ime, jms&
&    , jme, kms, kme, its, ite, jts, jte, kts, kte)
    IMPLICIT NONE
!-------------------------------------------------------------------
!   THIS MODULE COMPUTES SFC RELATED PARAMETERS (U*, RA, REGIME, etc.)
!   USING A MODIFIED RICHARDSON NUMBER PARAMETERIZATIONS.
!
!   THE PARAMETERIZATIONS OF THE PSI FUNCTIONS FOR UNSTABLE CONDITIONS
!   HAVE BEEN REPLACED WITH EMPIRICAL EXPRESSIONS WHICH RELATE RB DIRECTLY
!   TO PSIH AND PSIM.  THESE EXPRESSIONS ARE FIT TO THE DYER (1974) FUNCTIONS
!   WITH HOGSTROM (1988) REVISED COEFFICIENTS.  ALSO, THESE EXPERESSIONS
!   ASSUME A LAMINAR SUBLAYER RESISTANCE FOR HEAT (Rb = 5/U*)   - JP 8/01
! 
!   Reference: Pleim (2006): JAMC, 45, 341-347
!
!  REVISION HISTORY:
!     A. Xiu        2/2005 - developed WRF version based on the MM5 PX LSM
!     R. Gilliam    7/2006 - completed implementation into WRF model
!*********************************************************************** 
!-------------------------------------------------------------------
!-- U3D         3D u-velocity interpolated to theta points (m/s)
!-- V3D         3D v-velocity interpolated to theta points (m/s)
!-- T3D         temperature (K)
!-- TH3D        potential temperature (K)
!-- QV3D        3D water vapor mixing ratio (Kg/Kg)
!-- P3D         3D pressure (Pa)
!-- dz8w        dz between full levels (m)
!-- CP          heat capacity at constant pressure for dry air (J/kg/K)
!-- G           acceleration due to gravity (m/s^2)
!-- ROVCP       R/CP
!-- R           gas constant for dry air (j/kg/k)
!-- XLV         latent heat of vaporization (j/kg)
!-- PSFC        surface pressure (Pa)
!-- CHS         exchange coefficient for heat (m/s)
!-- CHS2        exchange coefficient for heat at 2 m (m/s)
!-- CQS2        exchange coefficient for moisture at 2 m (m/s)
!-- CPM         heat capacity at constant pressure for moist air (J/kg/K)
!-- ZNT         roughness length (m)
!-- UST         u* in similarity theory (m/s)
!-- PBLH        PBL height from previous time (m)
!-- MAVAIL      surface moisture availability (between 0 and 1)
!-- ZOL         z/L height over Monin-Obukhov length
!-- MOL         T* (similarity theory) (K)
!-- REGIME      flag indicating PBL regime (stable, unstable, etc.)
!-- PSIM        similarity stability function for momentum
!-- PSIH        similarity stability function for heat
!-- XLAND       land mask (1 for land, 2 for water)
!-- HFX         upward heat flux at the surface (W/m^2)
!-- QFX         upward moisture flux at the surface (kg/m^2/s)
!-- LH          net upward latent heat flux at surface (W/m^2)
!-- TSK         surface temperature (K)
!-- FLHC        exchange coefficient for heat (m/s)
!-- FLQC        exchange coefficient for moisture (m/s)
!-- QGH         lowest-level saturated mixing ratio
!-- QSFC        SPECIFIC HUMIDITY AT LOWER BOUNDARY				
!-- RMOL        inverse Monin-Obukhov length (1/m)
!-- U10         diagnostic 10m u wind
!-- V10         diagnostic 10m v wind
!-- GZ1OZ0      log(z/z0) where z0 is roughness length
!-- WSPD        wind speed at lowest model level (m/s)
!-- BR          bulk Richardson number in surface layer
!-- ISFFLX      isfflx=1 for surface heat and moisture fluxes
!-- DX          horizontal grid size (m)
!-- SVP1        constant for saturation vapor pressure (kPa)
!-- SVP2        constant for saturation vapor pressure (dimensionless)
!-- SVP3        constant for saturation vapor pressure (K)
!-- SVPT0       constant for saturation vapor pressure (K)
!-- EP1         constant for virtual temperature (R_v/R_d - 1) (dimensionless)
!-- EP2         constant for specific humidity calculation 
!               (R_d/R_v) (dimensionless)
!-- KARMAN      Von Karman constant
!-- ids         start index for i in domain
!-- ide         end index for i in domain
!-- jds         start index for j in domain
!-- jde         end index for j in domain
!-- kds         start index for k in domain
!-- kde         end index for k in domain
!-- ims         start index for i in memory
!-- ime         end index for i in memory
!-- jms         start index for j in memory
!-- jme         end index for j in memory
!-- kms         start index for k in memory
!-- kme         end index for k in memory
!-- its         start index for i in tile
!-- ite         end index for i in tile
!-- jts         start index for j in tile
!-- jte         end index for j in tile
!-- kts         start index for k in tile
!-- kte         end index for k in tile
!-------------------------------------------------------------------
    INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, its, ite, jts, jte, kts, kte
!                                                               
    INTEGER, INTENT(IN) :: isfflx
    REAL, INTENT(IN) :: svp1, svp2, svp3, svpt0
    REAL, INTENT(IN) :: ep1, ep2, karman
!
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: dz8w
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: g_dz8w
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: qv3d, p3d&
&    , t3d, th3d
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: g_qv3d, &
&    g_t3d, g_th3d
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: mavail, pblh, xland&
&    , tsk
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: g_pblh
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(OUT) :: u10, v10, qsfc
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(OUT) :: g_qsfc
!
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: regime, hfx, qfx&
&    , lh, mol, rmol
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: g_hfx, g_qfx, &
&    g_mol, g_rmol
!m the following 5 are change to memory size
!
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: gz1oz0, wspd, br&
&    , psim, psih
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: g_gz1oz0, g_wspd&
&    , g_br, g_psim, g_psih
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: u3d, v3d
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: g_u3d, &
&    g_v3d
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: psfc
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: g_psfc
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: znt, zol, ust, &
&    cpm, chs2, cqs2, chs
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: g_znt, g_zol, &
&    g_ust, g_cpm, g_chs
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: flhc, flqc
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: g_flhc, g_flqc
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: qgh
    REAL, INTENT(IN) :: cp, g, rovcp, r, xlv, dx
! LOCAL VARS
    REAL, DIMENSION(its:ite) :: u1d, v1d, qv1d, p1d, t1d, th1d
    REAL, DIMENSION(its:ite) :: g_u1d, g_v1d, g_qv1d, g_t1d, g_th1d
    REAL, DIMENSION(its:ite) :: dz8w1d
    REAL, DIMENSION(its:ite) :: g_dz8w1d
    INTEGER :: i, j
    g_qv1d = 0.0_8
    g_v1d = 0.0_8
    g_th1d = 0.0_8
    g_dz8w1d = 0.0_8
    g_u1d = 0.0_8
    g_t1d = 0.0_8
    DO j=jts,jte
      DO i=its,ite
        g_dz8w1d(i) = g_dz8w(i, 1, j)
        dz8w1d(i) = dz8w(i, 1, j)
        g_u1d(i) = g_u3d(i, 1, j)
        u1d(i) = u3d(i, 1, j)
        g_v1d(i) = g_v3d(i, 1, j)
        v1d(i) = v3d(i, 1, j)
        g_qv1d(i) = g_qv3d(i, 1, j)
        qv1d(i) = qv3d(i, 1, j)
        p1d(i) = p3d(i, 1, j)
        g_t1d(i) = g_t3d(i, 1, j)
        t1d(i) = t3d(i, 1, j)
        g_th1d(i) = g_th3d(i, 1, j)
        th1d(i) = th3d(i, 1, j)
      END DO

!  TST, WST, MOLENGTH, USTM need to be recaculated or passed in
      CALL G_PXSFCLAY1D(j, u1d, g_u1d, v1d, g_v1d, t1d, g_t1d, th1d, &
&                  g_th1d, qv1d, g_qv1d, p1d, dz8w1d, g_dz8w1d, cp, g, &
&                  rovcp, r, xlv, psfc(ims, j), g_psfc(ims, j), chs(ims, j), &
&                  g_chs(ims, j), chs2(ims, j), cqs2(ims, j), cpm(ims, j), g_cpm(&
&                  ims, j), pblh(ims, j), g_pblh(ims, j), rmol(ims, j), g_rmol(ims&
&                  , j), znt(ims, j), g_znt(ims, j), ust(ims, j), g_ust(ims, j), &
&                  mavail(ims, j), zol(ims, j), g_zol(ims, j), mol(ims, j), g_mol&
&                  (ims, j), regime(ims, j), psim(ims, j), g_psim(ims, j), psih(ims&
&                  , j), g_psih(ims, j), xland(ims, j), hfx(ims, j), g_hfx(ims, j&
&                  ), qfx(ims, j), g_qfx(ims, j), tsk(ims, j), u10(ims, j), v10(ims&
&                  , j), flhc(ims, j), g_flhc(ims, j), flqc(ims, j), g_flqc(ims, &
&                  j), qgh(ims, j), qsfc(ims, j), g_qsfc(ims, j), lh(ims, j), &
&                  gz1oz0(ims, j), g_gz1oz0(ims, j), wspd(ims, j), g_wspd(ims, j)&
&                  , br(ims, j), g_br(ims, j), isfflx, dx, svp1, svp2, svp3, &
&                  svpt0, ep1, ep2, karman, ids, ide, jds, jde, kds, kde&
&                  , ims, ime, jms, jme, kms, kme, its, ite, jts, jte, &
&                  kts, kte)
    END DO
  END SUBROUTINE G_PXSFCLAY
!-------------------------------------------------------------------

!  Differentiation of pxsfclay1d in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: wspd ust cpm hfx br qsfc psih
!                znt psim flqc rmol qfx chs gz1oz0 zol flhc mol
!   with respect to varying inputs: qv1d wspd ust cpm psfcpa pblh
!                hfx theta1 dz8w1d us br qsfc psih znt psim flqc
!                rmol vs qfx chs gz1oz0 zol flhc t1d mol
!====================================================================
  SUBROUTINE G_PXSFCLAY1D(j, us, g_us, vs, g_vs, t1d, g_t1d, theta1, &
&    g_theta1, qv1d, g_qv1d, p1d, dz8w1d, g_dz8w1d, cp, g, rovcp, r, xlv&
&    , psfcpa, g_psfcpa, chs, g_chs, chs2, cqs2, cpm, g_cpm, pblh, g_pblh&
&    , rmol, g_rmol, znt, g_znt, ust, g_ust, mavail, zol, g_zol, mol, &
&    g_mol, regime, psim, g_psim, psih, g_psih, xland, hfx, g_hfx, qfx, &
&    g_qfx, tg, u10, v10, flhc, g_flhc, flqc, g_flqc, qgh, qsfc, g_qsfc, &
&    lh, gz1oz0, g_gz1oz0, wspd, g_wspd, br, g_br, isfflx, dx, svp1, svp2&
&    , svp3, svpt0, ep1, ep2, karman, ids, ide, jds, jde, kds, kde, ims, &
&    ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte)
    IMPLICIT NONE
!-------------------------------------------------------------------
    REAL, PARAMETER :: xka=2.4e-5
    REAL, PARAMETER :: prt=1.
    INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, its, ite, jts, jte, kts, kte, j
!                                                               
    INTEGER, INTENT(IN) :: isfflx
    REAL, INTENT(IN) :: svp1, svp2, svp3, svpt0
    REAL, INTENT(IN) :: ep1, ep2, karman
!
    REAL, DIMENSION(ims:ime), INTENT(IN) :: mavail, pblh, xland, tg
    REAL, DIMENSION(ims:ime), INTENT(IN) :: g_pblh
!
    REAL, DIMENSION(ims:ime), INTENT(IN) :: psfcpa
    REAL, DIMENSION(ims:ime), INTENT(IN) :: g_psfcpa
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: regime, hfx, qfx, mol, &
&    rmol
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: g_hfx, g_qfx, g_mol, &
&    g_rmol
!m the following 5 are changed to memory size---
!
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: gz1oz0, wspd, br, psim, &
&    psih
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: g_gz1oz0, g_wspd, g_br, &
&    g_psim, g_psih
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: znt, zol, ust, cpm, chs2&
&    , cqs2, chs
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: g_znt, g_zol, g_ust, &
&    g_cpm, g_chs
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: flhc, flqc
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: g_flhc, g_flqc
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: qgh
    REAL, DIMENSION(ims:ime), INTENT(OUT) :: u10, v10, qsfc, lh
    REAL, DIMENSION(ims:ime), INTENT(OUT) :: g_qsfc
    REAL, INTENT(IN) :: cp, g, rovcp, xlv, dx, r
! MODULE-LOCAL VARIABLES, DEFINED IN SUBROUTINE SFCLAY
    REAL, DIMENSION(its:ite), INTENT(IN) :: dz8w1d
    REAL, DIMENSION(its:ite), INTENT(IN) :: g_dz8w1d
    REAL, DIMENSION(its:ite), INTENT(IN) :: us, vs, qv1d, p1d, t1d, &
&    theta1
    REAL, DIMENSION(its:ite), INTENT(IN) :: g_us, g_vs, g_qv1d, g_t1d, &
&    g_theta1
! LOCAL VARS
    REAL, DIMENSION(its:ite) :: za, th0, thetag, ws, ricut, ustm, ra, &
&    thetav1, molength
    REAL, DIMENSION(its:ite) :: g_za, g_th0, g_thetag, g_ws, g_ricut, &
&    g_ustm, g_ra, g_thetav1, g_molength
!
    REAL, DIMENSION(its:ite) :: rhox, govrth
    REAL, DIMENSION(its:ite) :: g_rhox, g_govrth
!
    REAL, DIMENSION(its:ite) :: psfc
    REAL, DIMENSION(its:ite) :: g_psfc
!
    INTEGER :: kl
    INTEGER :: n, i, k, kk, l, nzol, nk, nzol2, nzol10
    REAL :: pl, thcon, tvcon, e1
    REAL :: g_tvcon
    REAL :: zl, tskv, dthvdz, dthvm, vconv, rzol, rzol2, rzol10, zol2, &
&    zol10
    REAL :: g_dthvdz, g_vconv
    REAL :: dtg, psix, dtthx, psix10, psit, psit2, psiq, psiq2
    REAL :: g_dtg, g_psix
    REAL :: fluxc, vsgd
    REAL :: g_fluxc
    REAL :: xmol, zobol, z10ol, zntol, ynt, yob, x1, x2
    REAL :: g_xmol
    REAL :: g2oz0, g10oz0, ra2, zoll
    REAL :: g_zoll
    REAL :: tv0, cpot, ricriti, am, ah, sqlnzz0, rbh, rbw, tstv
    REAL :: g_tv0, g_cpot, g_am, g_ah, g_sqlnzz0, g_rbh, g_rbw, g_tstv
    REAL :: psih2, psim2, psih10, psim10, cqs
    REAL :: g_cqs
    REAL :: arg1
    REAL :: g_arg1
    REAL :: pwx1
    REAL :: g_pwx1
    REAL :: pwr1
    REAL :: g_pwr1
    REAL :: arg10
    REAL :: g_arg10
    REAL :: arg2
    REAL :: x3
    REAL :: g_x3
    REAL :: abs0
    REAL :: max2
    g_thetav1 = 0.0_8
    g_psfc = 0.0_8
    g_rhox = 0.0_8
!-------------------------------Exicutable starts here-------------------- 
    DO i=its,ite
! PSFC cb
      g_psfc(i) = g_psfcpa(i)/1000.D0
      psfc(i) = psfcpa(i)/1000.D0
      g_tvcon = ep1*g_qv1d(i)
      tvcon = 1.0D0 + ep1*qv1d(i)
      g_thetav1(i) = g_theta1(i)*tvcon + theta1(i)*g_tvcon
      thetav1(i) = theta1(i)*tvcon
      g_rhox(i) = (g_psfcpa(i)*r*t1d(i)*tvcon-psfcpa(i)*r*(g_t1d(i)*&
&        tvcon+t1d(i)*g_tvcon))/(r*t1d(i)*tvcon)**2
      rhox(i) = psfcpa(i)/(r*t1d(i)*tvcon)
    END DO
!
!-----Compute virtual potential temperature at surface
!
    DO i=its,ite
      arg1 = svp2*(tg(i)-svpt0)/(tg(i)-svp3)
      e1 = svp1*EXP(arg1)
      g_qsfc(i) = -(ep2*e1*g_psfc(i)/(psfc(i)-e1)**2)
      qsfc(i) = ep2*e1/(psfc(i)-e1)
! QGH CHANGED TO USE LOWEST-LEVEL AIR TEMP CONSISTENT WITH MYJSFC CHANGE
! Q2SAT = QGH IN LSM
      arg1 = svp2*(t1d(i)-svpt0)/(t1d(i)-svp3)
      e1 = svp1*EXP(arg1)
      pl = p1d(i)/1000.D0
      qgh(i) = ep2*e1/(pl-e1)
      g_cpm(i) = cp*0.8D0*g_qv1d(i)
      cpm(i) = cp*(1.D0+0.8D0*qv1d(i))
    END DO
    g_th0 = 0.0_8
    g_thetag = 0.0_8
!.......... compute the thetav at ground
    DO i=its,ite
      g_tv0 = tg(i)*ep1*mavail(i)*g_qsfc(i)
      tv0 = tg(i)*(1.0D0+ep1*qsfc(i)*mavail(i))
      g_pwx1 = -(100.D0*g_psfc(i)/psfc(i)**2)
      pwx1 = 100.D0/psfc(i)
      IF (pwx1 .GT. 0.0_8 .OR. (pwx1 .LT. 0.0_8 .AND. rovcp .EQ. INT(&
&          rovcp))) THEN
        g_cpot = rovcp*pwx1**(rovcp-1.D0)*g_pwx1
      ELSE IF (pwx1 .EQ. 0.0_8 .AND. rovcp .EQ. 1.0) THEN
        g_cpot = g_pwx1
      ELSE
        g_cpot = 0.0_8
      END IF
      cpot = pwx1**rovcp
      g_pwx1 = -(100.D0*g_psfc(i)/psfc(i)**2)
      pwx1 = 100.D0/psfc(i)
      IF (pwx1 .GT. 0.0_8 .OR. (pwx1 .LT. 0.0_8 .AND. rovcp .EQ. INT(&
&          rovcp))) THEN
        g_pwr1 = rovcp*pwx1**(rovcp-1.D0)*g_pwx1
      ELSE IF (pwx1 .EQ. 0.0_8 .AND. rovcp .EQ. 1.0) THEN
        g_pwr1 = g_pwx1
      ELSE
        g_pwr1 = 0.0_8
      END IF
      pwr1 = pwx1**rovcp
      g_th0(i) = g_tv0*pwr1 + tv0*g_pwr1
      th0(i) = tv0*pwr1
      g_thetag(i) = tg(i)*g_cpot
      thetag(i) = cpot*tg(i)
    END DO
    g_ws = 0.0_8
    g_za = 0.0_8
!                                                                                
!-----COMPUTE THE HEIGHT OF FULL- AND HALF-SIGMA LEVELS ABOVE GROUND             
!     LEVEL, AND THE LAYER THICKNESSES.                                          
!                                                                                
!... DZ8W1D is DZ between full sigma levels and Z0 is the height of the first 
!    half sigma level
    DO i=its,ite
      g_za(i) = 0.5D0*g_dz8w1d(i)
      za(i) = 0.5D0*dz8w1d(i)
      g_arg1 = g_us(i)*us(i) + us(i)*g_us(i) + g_vs(i)*vs(i) + vs(i)*&
&        g_vs(i)
      arg1 = us(i)*us(i) + vs(i)*vs(i)
      IF (arg1 .EQ. 0.0_8) THEN
        g_ws(i) = 0.0_8
      ELSE
        g_ws(i) = g_arg1/(2.0*SQRT(arg1))
      END IF
      ws(i) = SQRT(arg1)
    END DO
!
!-----CALCULATE BULK RICHARDSON NO. OF SURFACE LAYER, ACCORDING TO
!     AKB(1976), EQ(12).
    ricriti = 1.0D0/ricrit
    g_ricut = 0.0_8
    g_govrth = 0.0_8
    DO i=its,ite
      g_gz1oz0(i) = (g_za(i)*znt(i)-za(i)*g_znt(i))/(znt(i)*za(i))
      gz1oz0(i) = ALOG(za(i)/znt(i))
      g_dthvdz = g_thetav1(i) - g_th0(i)
      dthvdz = thetav1(i) - th0(i)
      g_x3 = (g_hfx(i)*rhox(i)-hfx(i)*g_rhox(i))/rhox(i)**2/cp + (ep1*(&
&        g_th0(i)*qfx(i)+th0(i)*g_qfx(i))*rhox(i)-ep1*th0(i)*qfx(i)*&
&        g_rhox(i))/rhox(i)**2
      x3 = hfx(i)/rhox(i)/cp + ep1*th0(i)*qfx(i)/rhox(i)
      IF (x3 .LT. 0.) THEN
        fluxc = 0.D0
        g_fluxc = 0.0_8
        g_vconv = 0.0_8
      ELSE
        g_fluxc = g_x3
        fluxc = x3
        IF(pblh(i) .eq. 0. .or. fluxc .eq. 0.) THEN
           g_vconv = 0.0_8
        ELSE
           g_vconv = vconvc*.33D0*(g/tg(i)*pblh(i)*fluxc)**(-0.67D0)*g*(g_pblh(i)&
&             *fluxc+pblh(i)*g_fluxc)/tg(i)
        END IF
      END IF
      vconv = vconvc*(g/tg(i)*pblh(i)*fluxc)**.33D0
      IF (dx/5000.D0 - 1.D0 .LT. 0.) THEN
        max2 = 0.D0
      ELSE
        max2 = dx/5000.D0 - 1.D0
      END IF
      vsgd = 0.32D0*max2**.33D0
      g_arg1 = g_ws(i)*ws(i) + ws(i)*g_ws(i) + g_vconv*vconv + vconv*&
&        g_vconv
      arg1 = ws(i)*ws(i) + vconv*vconv + vsgd*vsgd
      IF (arg1 .EQ. 0.0_8) THEN
        g_wspd(i) = 0.0_8
      ELSE
        g_wspd(i) = g_arg1/(2.0D0*SQRT(arg1))
      END IF
      wspd(i) = SQRT(arg1)
      IF (wspd(i) .LT. 0.1) THEN
        g_wspd(i) = 0.0_8
        wspd(i) = 0.1D0
      ELSE
        wspd(i) = wspd(i)
      END IF
      g_govrth(i) = -(g*g_theta1(i)/theta1(i)**2)
      govrth(i) = g/theta1(i)
      g_br(i) = (((g_govrth(i)*dthvdz+govrth(i)*g_dthvdz)*za(i)+govrth(i&
&        )*dthvdz*g_za(i))*wspd(i)**2-govrth(i)*za(i)*dthvdz*(g_wspd(i)*&
&        wspd(i)+wspd(i)*g_wspd(i)))/(wspd(i)*wspd(i))**2
      br(i) = govrth(i)*za(i)*dthvdz/(wspd(i)*wspd(i))
      g_ricut(i) = -(g_gz1oz0(i)/(ricriti+gz1oz0(i))**2)
      ricut(i) = 1.0D0/(ricriti+gz1oz0(i))
    END DO
    DO i=its,ite
!       -- NOTE THAT THE REGIMES USED IN HIRPBL HAVE BEEN CHANGED:
      zoll = 0.0D0
      IF (br(i) .GE. ricut(i)) THEN
!           -----CLASS 1; VERY STABLE CONDITIONS:  Z/L > 1
        regime(i) = 1.0
        g_zoll = ((g_br(i)*gz1oz0(i)+br(i)*g_gz1oz0(i))*(1.0D0-ricriti*&
&          ricut(i))+br(i)*gz1oz0(i)*ricriti*g_ricut(i))/(1.0D0-ricriti*&
&          ricut(i))**2
        zoll = br(i)*gz1oz0(i)/(1.0D0-ricriti*ricut(i))
        g_psim(i) = -g_zoll
        psim(i) = 1.0D0 - betam - zoll
        g_psih(i) = -g_zoll
        psih(i) = 1.0D0 - betah - zoll
      ELSE IF (br(i) .GE. 0.0) THEN
!           -----CLASS 2; STABLE: for 1 > Z/L >0
        regime(i) = 2.0
        g_zoll = ((g_br(i)*gz1oz0(i)+br(i)*g_gz1oz0(i))*(1.0D0-ricriti*br(&
&          i))+br(i)*gz1oz0(i)*ricriti*g_br(i))/(1.0D0-ricriti*br(i))**2
        zoll = br(i)*gz1oz0(i)/(1.0-ricriti*br(i))
        g_psim(i) = -(betam*g_zoll)
        psim(i) = -(betam*zoll)
        g_psih(i) = -(betah*g_zoll)
        psih(i) = -(betah*zoll)
      ELSE
!        ----- CLASS 3 or 4; UNSTABLE:
!        ----- CLASS 4 IS FOR ACM NON-LOCAL CONVECTION (H/L < -3)
! Regime will be reset to 4 if ACM is used
        regime(i) = 3.0
        g_am = 0.276D0*g_gz1oz0(i)/gz1oz0(i)
        am = 0.031D0 + 0.276D0*ALOG(gz1oz0(i))
        g_ah = 0.355D0*g_gz1oz0(i)/gz1oz0(i)
        ah = 0.04D0 + 0.355D0*ALOG(gz1oz0(i))
        IF (gz1oz0(i) .EQ. 0.0_8) THEN
          g_sqlnzz0 = 0.0_8
        ELSE
          g_sqlnzz0 = g_gz1oz0(i)/(2.0D0*SQRT(gz1oz0(i)))
        END IF
        sqlnzz0 = SQRT(gz1oz0(i))
        g_arg10 = -(bm*(g_sqlnzz0*br(i)+sqlnzz0*g_br(i)))
        arg10 = 1.0D0 - bm*sqlnzz0*br(i)
        g_psim(i) = g_am*ALOG(arg10) + am*g_arg10/arg10
        psim(i) = am*ALOG(arg10)
        g_arg10 = -(bh*(g_sqlnzz0*br(i)+sqlnzz0*g_br(i)))
        arg10 = 1.0D0 - bh*sqlnzz0*br(i)
        g_psih(i) = g_ah*ALOG(arg10) + ah*g_arg10/arg10
        psih(i) = ah*ALOG(arg10)
      END IF
    END DO
    g_molength = 0.0_8
    g_ra = 0.0_8
    g_ustm = 0.0_8
!
!     -------- COMPUTE THE FRICTIONAL VELOCITY AND SURFACE FLUXES:
    DO i=its,ite
      g_dtg = g_theta1(i) - g_thetag(i)
      dtg = theta1(i) - thetag(i)
      g_psix = g_gz1oz0(i) - g_psim(i)
      psix = gz1oz0(i) - psim(i)
      g_ust(i) = 0.5D0*g_ust(i) + (0.5D0*karman*g_wspd(i)*psix-0.5D0*karman*&
&        wspd(i)*g_psix)/psix**2
      ust(i) = 0.5D0*ust(i) + 0.5D0*karman*wspd(i)/psix
      g_ustm(i) = g_ust(i)
      ustm(i) = ust(i)
!      ------- OVER WATER, ALTER ROUGHNESS LENGTH (Z0) ACCORDING TO WIND (UST).
!
      IF (xland(i) - 1.5D0 .GE. 0.0) THEN
        g_znt(i) = czo*(g_ustm(i)*ustm(i)+ustm(i)*g_ustm(i))/g
        znt(i) = czo*ustm(i)*ustm(i)/g + ozo
        g_gz1oz0(i) = (g_za(i)*znt(i)-za(i)*g_znt(i))/(znt(i)*za(i))
        gz1oz0(i) = ALOG(za(i)/znt(i))
        g_psix = g_gz1oz0(i) - g_psim(i)
        psix = gz1oz0(i) - psim(i)
        g_ust(i) = (karman*g_wspd(i)*psix-karman*wspd(i)*g_psix)/psix**2
        ust(i) = karman*wspd(i)/psix
        g_ustm(i) = g_ust(i)
        ustm(i) = ust(i)
      END IF
      g_ra(i) = (pr0*(g_gz1oz0(i)-g_psih(i))*karman*ust(i)-pr0*(gz1oz0(i&
&        )-psih(i))*karman*g_ust(i))/(karman*ust(i))**2
      ra(i) = pr0*(gz1oz0(i)-psih(i))/(karman*ust(i))
! 5/U*  ! WESELY AND HICKS (1977)
      g_rbh = -(5.0D0*g_ust(i)/ust(i)**2)
      rbh = 5.0D0/ust(i)
!       ------- RB FOR WATER VAPOR =  5*(0.599/0.709)^2/3 /UST = 4.47/UST    hi               
      g_rbw = -(4.47D0*g_ust(i)/ust(i)**2)
      rbw = 4.47D0/ust(i)
      g_chs(i) = -((g_ra(i)+g_rbh)/(ra(i)+rbh)**2)
      chs(i) = 1.D0/(ra(i)+rbh)
      g_cqs = -((g_ra(i)+g_rbw)/(ra(i)+rbw)**2)
      cqs = 1.D0/(ra(i)+rbw)
! This is really TST
      g_mol(i) = ((g_dtg*chs(i)+dtg*g_chs(i))*ust(i)-dtg*chs(i)*g_ust(i)&
&        )/ust(i)**2
      mol(i) = dtg*chs(i)/ust(i)
      g_tstv = (((g_thetav1(i)-g_th0(i))*chs(i)+(thetav1(i)-th0(i))*&
&        g_chs(i))*ust(i)-(thetav1(i)-th0(i))*chs(i)*g_ust(i))/ust(i)**2
      tstv = (thetav1(i)-th0(i))*chs(i)/ust(i)
      IF (tstv .GE. 0.) THEN
        abs0 = tstv
      ELSE
        abs0 = -tstv
      END IF
      IF (abs0 .LT. 1.d-5) THEN
        tstv = 1.d-5
        g_tstv = 0.0_8
      END IF
      g_molength(i) = (((g_thetav1(i)*ust(i)+thetav1(i)*g_ust(i))*ust(i)&
&        +thetav1(i)*ust(i)*g_ust(i))*karman*g*tstv-thetav1(i)*ust(i)**2*&
&        karman*g*g_tstv)/(karman*g*tstv)**2
      molength(i) = thetav1(i)*ust(i)*ust(i)/(karman*g*tstv)
!
!       ---Compute 2m surface exchange coefficients for heat and moisture
      g_xmol = g_molength(i)
      xmol = molength(i)
      IF (molength(i) .GT. 0.0) THEN
        IF (molength(i) .LT. 2.0) THEN
          xmol = 2.0D0
          g_xmol = 0.0_8
        ELSE
          g_xmol = g_molength(i)
          xmol = molength(i)
        END IF
      END IF
      g_rmol(i) = (-g_xmol)/xmol**2
      rmol(i) = 1.D0/xmol
      g_zol(i) = g_za(i)*rmol(i) + za(i)*g_rmol(i)
      zol(i) = za(i)*rmol(i)
      zobol = 1.5D0*rmol(i)
      z10ol = 10.0D0*rmol(i)
      zntol = znt(i)*rmol(i)
      IF (xmol .LT. 0.0) THEN
        ynt = (1.0D0-gamah*zntol)**0.5
        yob = (1.0D0-gamah*zobol)**0.5
        arg10 = (yob+1.0D0)/(ynt+1.0D0)
        psih2 = 2.D0*ALOG(arg10)
        x1 = (1.0D0-gamam*z10ol)**0.25
        x2 = (1.0D0-gamam*zntol)**0.25
        arg10 = (1.0D0+x1)/(1.0D0+x2)
        arg2 = (1.0D0+x1*x1)/(1.0D0+x2*x2)
        psim10 = 2.0D0*ALOG(arg10) + ALOG(arg2) - 2.0D0*ATAN(x1) + 2.0D0*ATAN(&
&          x2)
      ELSE
        IF (zobol - zntol .LE. 1.0) THEN
          psih2 = -(betah*(zobol-zntol))
        ELSE
          psih2 = 1.D0 - betah - (zobol-zntol)
        END IF
        IF (z10ol - zntol .LE. 1.0) THEN
          psim10 = -(betam*(z10ol-zntol))
        ELSE
          psim10 = 1.D0 - betam - (z10ol-zntol)
        END IF
      END IF
      g2oz0 = ALOG(1.5D0/znt(i))
      g10oz0 = ALOG(10.0D0/znt(i))
      ra2 = pr0*(g2oz0-psih2)/(karman*ust(i))
      chs2(i) = 1.0D0/(ra2+rbh)
      cqs2(i) = 1.0D0/(ra2+rbw)
      u10(i) = us(i)*(g10oz0-psim10)/psix
      v10(i) = vs(i)*(g10oz0-psim10)/psix
!       -----COMPUTE SURFACE HEAT AND MOIST FLUX:                                                
      g_flhc(i) = (g_cpm(i)*rhox(i)+cpm(i)*g_rhox(i))*chs(i) + cpm(i)*&
&        rhox(i)*g_chs(i)
      flhc(i) = cpm(i)*rhox(i)*chs(i)
      g_flqc(i) = mavail(i)*(g_rhox(i)*cqs+rhox(i)*g_cqs)
      flqc(i) = rhox(i)*cqs*mavail(i)
      g_qfx(i) = g_flqc(i)*(qsfc(i)-qv1d(i)) + flqc(i)*(g_qsfc(i)-g_qv1d&
&        (i))
      qfx(i) = flqc(i)*(qsfc(i)-qv1d(i))
      IF (qfx(i) .LT. 0.) THEN
        g_qfx(i) = 0.0_8
        qfx(i) = 0.
      ELSE
        qfx(i) = qfx(i)
      END IF
      lh(i) = xlv*qfx(i)
      IF (xland(i) - 1.5D0 .GT. 0.) THEN
        g_hfx(i) = -(g_flhc(i)*dtg+flhc(i)*g_dtg)
        hfx(i) = -(flhc(i)*dtg)
      ELSE IF (xland(i) - 1.5D0 .LT. 0.) THEN
        g_hfx(i) = -(g_flhc(i)*dtg+flhc(i)*g_dtg)
        hfx(i) = -(flhc(i)*dtg)
        IF (hfx(i) .LT. -250.) THEN
          g_hfx(i) = 0.0_8
          hfx(i) = -250.D0
        ELSE
          hfx(i) = hfx(i)
        END IF
      END IF
    END DO
  END SUBROUTINE G_PXSFCLAY1D
!====================================================================
END MODULE G_MODULE_SF_PXSFCLAY
