!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.6 (r4756) - 12 Feb 2013 10:43
!
!WRF:MODEL_LAYER:PHYSICS
!
MODULE A_MODULE_BL_ACM

  USE module_bl_acm, ONLY: ric, crankp, ACM2D, ACM, EDDYX, MATRIX, TRI
  IMPLICIT NONE
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
CONTAINS
!  Differentiation of acmpbl in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: alloc(*vci) alloc(*fs) alloc(*ui)
!                alloc(*di) rublten qc3d rr3d wspd ust u3d vd3d
!                pblh hfx rqvblten rvblten t3d chem3d qv3d qi3d
!                rqcblten qfx rthblten v3d rqiblten th3d mut dz8w
!   with respect to varying inputs: alloc(*vci) alloc(*fs) alloc(*ui)
!                alloc(*di) rublten qc3d rr3d wspd ust u3d vd3d
!                pblh hfx rqvblten rvblten t3d chem3d qv3d qi3d
!                rqcblten qfx rthblten v3d rqiblten th3d mut dz8w
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
  SUBROUTINE A_ACMPBL(xtime, dtpbl, znw, sigmah, u3d, a_u3d, v3d, a_v3d&
&    , pp3d, dz8w, a_dz8w, th3d, a_th3d, t3d, a_t3d, qv3d, a_qv3d, qc3d, &
&    a_qc3d, qi3d, a_qi3d, rr3d, a_rr3d, &
#if (WRF_CHEM == 1)
! For WRF-Chem
     chem3d, a_chem3d, vd3d, a_vd3d, nchem, kdvel, ndvel, num_vert_mix, &
! For WRF-Chem
#endif
     ust, a_ust, hfx, a_hfx, qfx, a_qfx, &
&    tsk, psfc, ep1, g, rovcp, rd, cpd, pblh, a_pblh, kpbl2d, &
&    exch_h, regime, gz1oz0, wspd, a_wspd, psim, mut, a_mut, rublten, a_rublten&
&    , rvblten, a_rvblten, rthblten, a_rthblten, rqvblten, a_rqvblten, &
&    rqcblten, a_rqcblten, rqiblten, a_rqiblten, ids, ide, jds, jde, kds&
&    , kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte)
    IMPLICIT NONE
!.......Arguments
! DECLARATIONS - INTEGER
    INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, its, ite, jts, jte, kts, kte, xtime
! DECLARATIONS - REAL
    REAL, INTENT(IN) :: dtpbl, ep1, g, rovcp, rd, cpd
    REAL, DIMENSION(kms:kme), INTENT(IN) :: znw, sigmah
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: u3d, v3d, &
&    pp3d, dz8w, t3d, qv3d, qc3d, qi3d, rr3d, th3d
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_u3d, a_v3d, a_dz8w, &
&    a_t3d, a_qv3d, a_qc3d, a_qi3d, a_rr3d, a_th3d
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: psim, gz1oz0, hfx, &
&    qfx, tsk, psfc, wspd, mut
    REAL, DIMENSION(ims:ime, jms:jme) :: a_hfx, a_qfx, a_wspd, a_mut
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: pblh, regime, &
&    ust
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_pblh
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: rublten&
&    , rvblten, rthblten, rqvblten, rqcblten, rqiblten
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: &
&    a_rublten
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: exch_h
    INTEGER, DIMENSION(ims:ime, jms:jme), INTENT(OUT) :: kpbl2d
#if (WRF_CHEM == 1)
!... Chem
    INTEGER, INTENT(IN) :: nchem, kdvel, ndvel, num_vert_mix
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme, nchem), INTENT(INOUT) :: &
&    chem3d
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme, nchem), INTENT(INOUT) :: &
&    a_chem3d
    REAL, DIMENSION(ims:ime, kdvel, jms:jme, ndvel), INTENT(IN) :: vd3d
    REAL, DIMENSION(ims:ime, kdvel, jms:jme, ndvel) :: a_vd3d
#endif
!... Local Variables
!... Integer
    INTEGER :: i, j, k, l
!... Real
    REAL, DIMENSION(kts:kte) :: dsigh, dsighi, dsigfi
    REAL, DIMENSION(0:kte) :: sigmaf
    REAL :: rdt
    REAL, PARAMETER :: karman=0.4D0
#if (WRF_CHEM == 1)
!... Chem
    REAL, DIMENSION(ims:ime, kms:kme, nchem) :: chem2d
    REAL, DIMENSION(ims:ime, kms:kme, nchem) :: a_chem2d
    REAL, DIMENSION(ims:ime, kdvel, ndvel) :: vd2d
    REAL, DIMENSION(ims:ime, kdvel, ndvel) :: a_vd2d
#endif
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_ust
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: &
&    a_rqcblten
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: &
&    a_rthblten
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: &
&    a_rqiblten
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: &
&    a_rvblten
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: &
&    a_rqvblten
!...
    rdt = 1.0D0/dtpbl
    DO k=1,kte
      sigmaf(k-1) = znw(k)
    END DO
    sigmaf(kte) = 0.0D0
    DO k=1,kte
      dsigh(k) = sigmaf(k) - sigmaf(k-1)
      dsighi(k) = 1.0D0/dsigh(k)
    END DO
    DO k=kts,kte-1
      dsigfi(k) = 1.0D0/(sigmah(k+1)-sigmah(k))
    END DO
    dsigfi(kte) = dsigfi(kte-1)
    DO j=jts,jte
#if (WRF_CHEM == 1)
      DO l=1,nchem
        DO k=kms,kme
          DO i=its,ite
            chem2d(i, k, l) = chem3d(i, k, j, l)
          END DO
        END DO
      END DO
      DO l=1,ndvel
        DO k=1,kdvel
          DO i=its,ite
            CALL PUSHREAL8(vd2d(i, k, l))
            vd2d(i, k, l) = vd3d(i, k, j, l)
          END DO
        END DO
      END DO
      CALL PUSHREAL8ARRAY(chem2d, (ime-ims+1)*(kme-kms+1)*nchem)
#endif
      CALL PUSHINTEGER4ARRAY(kpbl2d(:, j), ime - ims + 1)
      CALL PUSHREAL8ARRAY(pblh(:, j), ime - ims + 1)
      CALL ACM2D(j=J,xtime=XTIME, dtpbl=DTPBL, sigmaf=SIGMAF, sigmah=SIGMAH    &
              ,dsigfi=DSIGFI,dsighi=DSIGHI,dsigh=DSIGH             &
              ,us=u3d(ims,kms,j),vs=v3d(ims,kms,j)                 &
              ,theta=th3d(ims,kms,j),tt=t3d(ims,kms,j)             &
              ,qvs=qv3d(ims,kms,j),qcs=qc3d(ims,kms,j)             &
              ,qis=qi3d(ims,kms,j)                                 &
#if (WRF_CHEM == 1)
              ,chem=chem2d                                         &
              ,vd=vd2d                                             &
              ,nchem=nchem,kdvel=kdvel,ndvel=ndvel                 &
              ,num_vert_mix=num_vert_mix                           &
#endif
              ,dzf=DZ8W(ims,kms,j)                                 &
              ,densx=RR3D(ims,kms,j)                               &
              ,utnp=rublten(ims,kms,j),vtnp=rvblten(ims,kms,j)     &
              ,ttnp=rthblten(ims,kms,j),qvtnp=rqvblten(ims,kms,j)  &
              ,qctnp=rqcblten(ims,kms,j),qitnp=rqiblten(ims,kms,j) &
              ,cpd=cpd,g=g,rovcp=rovcp,rd=rd,rdt=rdt               &
              ,psfcpa=psfc(ims,j),ust=ust(ims,j)                   &
              ,pbl=pblh(ims,j)                                     &
              ,exch_hx=exch_h(ims,kms,j)                           &
              ,regime=regime(ims,j),psim=psim(ims,j)               &
              ,hfx=hfx(ims,j),qfx=qfx(ims,j)                       &
              ,tg=tsk(ims,j),gz1oz0=gz1oz0(ims,j)                  &
              ,wspd=wspd(ims,j) ,klpbl=kpbl2d(ims,j)               &
              ,mut=mut(ims,j)                                      &
              ,ep1=ep1,karman=karman                               &
              ,ids=ids,ide=ide, jds=jds,jde=jde, kds=kds,kde=kde   &
              ,ims=ims,ime=ime, jms=jms,jme=jme, kms=kms,kme=kme   &
              ,its=its,ite=ite, jts=jts,jte=jte, kts=kts,kte=kte   )

#if (WRF_CHEM == 1)
      DO l=1,nchem
        DO i=ims,ime
          chem3d(i, kms:kme, j, l) = chem2d(i, kms:kme, l)
        END DO
      END DO
#endif
    END DO
#if (WRF_CHEM == 1)
    a_chem2d = 0.0_8
    a_vd2d = 0.0_8
#endif
    DO j=jte,jts,-1
      CALL POPREAL8ARRAY(pblh(:, j), ime - ims + 1)
      CALL POPINTEGER4ARRAY(kpbl2d(:, j), ime - ims + 1)
#if (WRF_CHEM == 1)
      DO l=nchem,1,-1
        DO i=ite,its,-1
          a_chem2d(i, :, l) = a_chem2d(i, :, l) + a_chem3d(i, :, j, l)
          a_chem3d(i, :, j, l) = 0.0_8
        END DO
      END DO
      CALL POPREAL8ARRAY(chem2d, (ime-ims+1)*(kme-kms+1)*nchem)
#endif
      CALL A_ACM2D(j=j,xtime=xtime,dtpbl=dtpbl,sigmaf=sigmaf,sigmah=sigmah   &
                ,dsigfi=dsigfi,dsighi=dsighi,dsigh=dsigh                     &
                ,us=u3d(ims,kms,j),a_us=a_u3d(ims,kms,j)                     &
                ,vs=v3d(ims,kms,j),a_vs=a_v3d(ims,kms,j)                     &
                ,theta=th3d(ims,kms,j),a_theta=a_th3d(ims,kms,j)             &
                ,tt=t3d(ims,kms,j),a_tt=a_t3d(ims,kms,j)                     &
                ,qvs=qv3d(ims,kms,j),a_qvs=a_qv3d(ims,kms,j)             &
                ,qcs=qc3d(ims,kms,j),a_qcs=a_qc3d(ims,kms,j)             &
                ,qis=qi3d(ims,kms,j),a_qis=a_qi3d(ims,kms,j)             &
#if (WRF_CHEM == 1)
                ,chem=chem2d,a_chem=a_chem2d,vd=vd2d,a_vd=a_vd2d             &
                ,nchem=nchem,kdvel=kdvel,ndvel=ndvel                         &
                ,num_vert_mix=num_vert_mix                                   &
#endif
                ,dzf=dz8w(ims,kms,j),a_dzf=a_dz8w(ims,kms,j)                 &
                ,densx=rr3d(ims,kms,j),a_densx=a_rr3d(ims,kms,j)             &
                ,utnp=rublten(ims,kms,j),a_utnp=a_rublten(ims,kms,j)         &
                ,vtnp=rvblten(ims,kms,j),a_vtnp=a_rvblten(ims,kms,j)         &
                ,ttnp=rthblten(ims,kms,j),a_ttnp=a_rthblten(ims,kms,j)       &
                ,qvtnp=rqvblten(ims,kms,j),a_qvtnp=a_rqvblten(ims,kms,j)     &
                ,qctnp=rqcblten(ims,kms,j),a_qctnp=a_rqcblten(ims,kms,j)     &
                ,qitnp=rqiblten(ims,kms,j),a_qitnp=a_rqiblten(ims,kms,j)     &
                ,cpd=cpd,g=g,rovcp=rovcp,rd=rd,rdt=rdt             &
                ,psfcpa=psfc(ims,j),ust=ust(ims,j),a_ust=a_ust(ims,j)                 &
                ,pbl=pblh(ims,j),a_pbl=a_pblh(ims,j)               &
                ,exch_hx=exch_h(ims,kms,j)     &
                ,regime=regime(ims,j),psim=psim(ims,j)             &
                ,hfx=hfx(ims,j),a_hfx=a_hfx(ims,j),qfx=qfx(ims,j),a_qfx=a_qfx(ims,j)  &
                ,tg=tsk(ims,j),gz1oz0=gz1oz0(ims,j)                &
                ,wspd=wspd(ims,j),a_wspd=a_wspd(ims,j),klpbl=kpbl2d(ims,j)              &
                ,mut=mut(ims,j),a_mut=a_mut(ims,j)                           &
                ,ep1=ep1,karman=karman                                       &
                ,ids=ids,ide=ide, jds=jds,jde=jde, kds=kds,kde=kde           &
                ,ims=ims,ime=ime, jms=jms,jme=jme, kms=kms,kme=kme           &
                ,its=its,ite=ite, jts=jts,jte=jte, kts=kts,kte=kte)
#if (WRF_CHEM == 1)
      DO l=ndvel,1,-1
        DO k=kdvel,1,-1
          DO i=ite,its,-1
            CALL POPREAL8(vd2d(i, k, l))
            a_vd3d(i, k, j, l) = a_vd3d(i, k, j, l) + a_vd2d(i, k, l)
            a_vd2d(i, k, l) = 0.0_8
          END DO
        END DO
      END DO
      DO l=nchem,1,-1
        DO k=kme,kms,-1
          DO i=ite,its,-1
            a_chem3d(i, k, j, l) = a_chem3d(i, k, j, l) + a_chem2d(i, k&
&              , l)
            a_chem2d(i, k, l) = 0.0_8
          END DO
        END DO
      END DO
#endif
    END DO
  END SUBROUTINE A_ACMPBL

!  Differentiation of acm2d in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: alloc(*vci) alloc(*fs) alloc(*ui)
!                alloc(*di) qvtnp tt wspd ust hfx qitnp vtnp us
!                utnp ttnp theta vd qis qvs vs qfx qcs pbl qctnp
!                dzf densx mut chem
!   with respect to varying inputs: alloc(*vci) alloc(*fs) alloc(*ui)
!                alloc(*di) qvtnp tt wspd ust hfx qitnp vtnp us
!                utnp ttnp theta vd qis qvs vs qfx qcs pbl qctnp
!                dzf densx mut chem
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
  SUBROUTINE A_ACM2D(j, xtime, dtpbl, sigmaf, sigmah, dsigfi, dsighi, &
&    dsigh, us, a_us, vs, a_vs, theta, a_theta, tt, a_tt, qvs, a_qvs, qcs&
&    , a_qcs, qis, a_qis &
#if (WRF_CHEM == 1)
     , chem, a_chem, vd, a_vd, nchem, kdvel, ndvel, num_vert_mix &
#endif
     , dzf, a_dzf, densx, a_densx, utnp, a_utnp, vtnp, a_vtnp&
&    , ttnp, a_ttnp, qvtnp, a_qvtnp, qctnp, a_qctnp, qitnp, a_qitnp, cpd&
&    , g, rovcp, rd, rdt, psfcpa, ust, a_ust, pbl, a_pbl, exch_hx, regime&
&    , psim, hfx, a_hfx, qfx, a_qfx, tg, gz1oz0, wspd, a_wspd, klpbl, mut, a_mut&
&    , ep1, karman, ids, ide, jds, jde, kds, kde, ims, ime, jms, jme, kms&
&    , kme, its, ite, jts, jte, kts, kte)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, its, ite, jts, jte, kts, kte, j
!.......Arguments
!... Real
    REAL, DIMENSION(0:kte), INTENT(IN) :: sigmaf
    REAL, DIMENSION(kms:kme), INTENT(IN) :: sigmah
    REAL, DIMENSION(kts:kte), INTENT(IN) :: dsigh, dsighi, dsigfi
    REAL, INTENT(IN) :: dtpbl, g, rd, ep1, karman, cpd, rovcp, rdt
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: pbl, ust
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_pbl
    REAL, DIMENSION(ims:ime, kms:kme), INTENT(IN) :: us, vs, theta, tt, &
&    qvs, qcs, qis, densx
    REAL, DIMENSION(ims:ime, kms:kme) :: a_us, a_vs, a_theta, a_tt, &
&    a_qvs, a_qcs, a_qis, a_densx
    REAL, DIMENSION(ims:ime, kms:kme), INTENT(IN) :: dzf
    REAL, DIMENSION(ims:ime, kms:kme) :: a_dzf
    REAL, DIMENSION(ims:ime, kms:kme), INTENT(INOUT) :: utnp, vtnp, ttnp&
&    , qvtnp, qctnp, qitnp
    REAL, DIMENSION(ims:ime, kms:kme), INTENT(INOUT) :: a_utnp
    REAL, DIMENSION(ims:ime), INTENT(IN) :: psfcpa
    REAL, DIMENSION(ims:ime), INTENT(IN) :: tg
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: regime
    REAL, DIMENSION(ims:ime), INTENT(IN) :: wspd, psim, gz1oz0
    REAL, DIMENSION(ims:ime) :: a_wspd
    REAL, DIMENSION(ims:ime), INTENT(IN) :: hfx, qfx
    REAL, DIMENSION(ims:ime) :: a_hfx, a_qfx
    REAL, DIMENSION(ims:ime), INTENT(IN) :: mut
    REAL, DIMENSION(ims:ime) :: a_mut
    REAL, DIMENSION(ims:ime, kms:kme), INTENT(INOUT) :: exch_hx
!... Integer
    INTEGER, DIMENSION(ims:ime), INTENT(OUT) :: klpbl
    INTEGER, INTENT(IN) :: xtime
#if (WRF_CHEM == 1)
!....Chem
    INTEGER, INTENT(IN) :: nchem, kdvel, ndvel, num_vert_mix
    REAL, DIMENSION(ims:ime, kms:kme, nchem), INTENT(INOUT) :: chem
    REAL, DIMENSION(ims:ime, kms:kme, nchem), INTENT(INOUT) :: a_chem
    REAL, DIMENSION(ims:ime, kdvel, ndvel), INTENT(IN) :: vd
    REAL, DIMENSION(ims:ime, kdvel, ndvel) :: a_vd
#endif
!--------------------------------------------------------------------
!--Local 
    INTEGER :: i, k
    INTEGER :: kpblht
    INTEGER, DIMENSION(its:ite) :: kpblh, noconv
!... Real
    REAL :: tvcon, wss, tconv, th1, tog, dtmp, wssq
    REAL :: a_tvcon, a_wss, a_tconv, a_th1, a_tog, a_dtmp, a_wssq
    REAL :: psix, thv1
    REAL :: a_thv1
    REAL, DIMENSION(its:ite) :: fint, pstar, cpair
    REAL, DIMENSION(its:ite) :: a_fint, a_pstar, a_cpair
    REAL, DIMENSION(its:ite, kts:kte) :: thetav, rib, eddyz, ux, vx, &
&    thetax, qvx, qcx, qix, za
    REAL, DIMENSION(its:ite, kts:kte) :: a_thetav, a_rib, a_eddyz, a_ux&
&    , a_vx, a_thetax, a_qvx, a_qcx, a_qix, a_za
    REAL, DIMENSION(its:ite, 0:kte) :: zf
    REAL, DIMENSION(its:ite, 0:kte) :: a_zf
    REAL, DIMENSION(its:ite) :: wst, tst, qst, ustm, tstv
    REAL, DIMENSION(its:ite) :: a_wst, a_tst, a_qst, a_ustm, a_tstv
    REAL, DIMENSION(its:ite) :: pblsig, mol
    REAL, DIMENSION(its:ite) :: a_pblsig, a_mol
    REAL :: fintt, zmix, umix, vmix
    REAL :: a_fintt, a_zmix, a_umix, a_vmix
    REAL :: tmpfx, tmpvtcon, tmpp, tmpths, tmpth1, tmpvconv, ws1, dth
    REAL :: a_tmpfx, a_tmpvtcon, a_ws1
    REAL :: a, tst12, rl, zfunc, densf
!    REAL, PARAMETER :: KARMAN = 0.4
!... Integer
    INTEGER :: kl, jtf, ktf, itf, kmix, ksrc
!...
    CHARACTER(len=256) :: message
    INTEGER :: branch
    INTEGER :: ad_count
    INTEGER :: i0
    INTEGER :: ad_to
    INTEGER :: ad_count0
    INTEGER :: i1
    REAL, DIMENSION(ims:ime, kms:kme), INTENT(INOUT) :: a_ttnp
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_ust
    REAL, DIMENSION(ims:ime, kms:kme), INTENT(INOUT) :: a_qitnp
    REAL, DIMENSION(ims:ime, kms:kme), INTENT(INOUT) :: a_qctnp
    REAL, DIMENSION(ims:ime, kms:kme), INTENT(INOUT) :: a_vtnp
    REAL, DIMENSION(ims:ime, kms:kme), INTENT(INOUT) :: a_qvtnp
    REAL :: temp3
    REAL :: temp2
    REAL :: temp1
    REAL :: temp0
    REAL :: temp0b
    REAL :: temp1b
    REAL :: temp6b4
    REAL :: temp6b3
    REAL :: temp6b2
    REAL :: temp6b1
    REAL :: temp6b0
    REAL :: temp2b
    INTRINSIC MAX
    REAL :: temp1b0
    INTRINSIC SIGN
    INTRINSIC ABS
    REAL :: a_abs2
    REAL :: a_abs1
    REAL :: temp4b
    REAL :: temp5b0
    REAL :: temp0b1
    REAL :: temp0b0
    REAL :: temp5b
    REAL :: temp6b
    REAL :: temp4b0
    REAL :: tempb
    REAL :: abs2
    REAL :: abs1
    REAL :: abs0
    INTRINSIC SQRT
    REAL :: temp
    REAL :: temp6
    REAL :: temp5
    REAL :: temp4
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!  Compute Micromet Scaling variables, not availiable in WRF for ACM
    DO i=its,ite
! J/(K KG)
      cpair(i) = cpd*(1.0D0+0.84D0*qvs(i, 1))
      tmpfx = hfx(i)/(cpair(i)*densx(i, 1))
! COnversion factor for virtual temperature
      tmpvtcon = 1.0D0 + ep1*qvs(i, 1)
      CALL PUSHREAL8(ws1)
! Level 1 wind speed
      ws1 = SQRT(us(i, 1)**2 + vs(i, 1)**2)
      tst(i) = -(tmpfx/ust(i))
      qst(i) = -(qfx(i)/(ust(i)*densx(i, 1)))
      ustm(i) = ust(i)*ws1/wspd(i)
      thv1 = tmpvtcon*theta(i, 1)
      tstv(i) = tst(i)*tmpvtcon + thv1*ep1*qst(i)
      IF (tstv(i) .GE. 0.) THEN
        abs0 = tstv(i)
      ELSE
        abs0 = -tstv(i)
      END IF
      IF (abs0 .LT. 1.0d-6) THEN
        tstv(i) = SIGN(1.0d-6, tstv(i))
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      mol(i) = thv1*ust(i)**2/(karman*g*tstv(i))
      IF (mol(i) .GE. 0.) THEN
        CALL PUSHREAL8(abs1)
        abs1 = mol(i)
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHREAL8(abs1)
        abs1 = -mol(i)
        CALL PUSHCONTROL1B(1)
      END IF
      wst(i) = ust(i)*(pbl(i)/(karman*abs1))**0.333333D0
! P* in cb 
      pstar(i) = mut(i)/1000.D0
    END DO
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!... Compute PBL height
!... compute the height of full- and half-sigma level above ground level
    DO i=its,ite
      zf(i, 0) = 0.0D0
      klpbl(i) = 1
    END DO
    DO k=kts,kte
      DO i=its,ite
        zf(i, k) = dzf(i, k) + zf(i, k-1)
        za(i, k) = 0.5D0*(zf(i, k)+zf(i, k-1))
      END DO
    END DO
    DO k=kts,kte
      DO i=its,ite
        tvcon = 1.0D0 + ep1*qvs(i, k)
        thetav(i, k) = theta(i, k)*tvcon
      END DO
    END DO
!...  COMPUTE PBL WHERE RICHARDSON NUMBER = RIC (0.25) HOLTSLAG ET AL 1990  
    DO i=its,ite
      CALL PUSHINTEGER4(k)
      ad_count = 1
      DO k=1,kte
        CALL PUSHINTEGER4(ksrc)
        ksrc = k
        IF (sigmaf(k) .LT. 0.9955) THEN
          GOTO 100
        ELSE
          CALL PUSHINTEGER4(k)
          ad_count = ad_count + 1
        END IF
      END DO
      CALL PUSHCONTROL1B(0)
      CALL PUSHINTEGER4(ad_count)
      GOTO 69
 100  CALL PUSHCONTROL1B(1)
      CALL PUSHINTEGER4(ad_count)
 69   CALL PUSHREAL8(th1)
      th1 = 0.0D0
      DO k=1,ksrc
        th1 = th1 + thetav(i, k)
      END DO
      CALL PUSHINTEGER4(k - 1)
      th1 = th1/ksrc
      IF (mol(i) .LT. 0.0 .AND. xtime .GT. 1) THEN
        CALL PUSHREAL8(wss)
        wss = (ust(i)**3+0.6D0*wst(i)**3)**0.33333D0
        tconv = -(8.5D0*ust(i)*tstv(i)/wss)
        th1 = th1 + tconv
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      CALL PUSHINTEGER4(kmix)
      kmix = 1
      DO k=1,kte
        dtmp = thetav(i, k) - th1
        IF (dtmp .LT. 0.0) kmix = k
      END DO
      IF (kmix .GT. 1) THEN
        CALL PUSHREAL8(fintt)
        fintt = (th1-thetav(i, kmix))/(thetav(i, kmix+1)-thetav(i, kmix)&
&          )
        zmix = fintt*(za(i, kmix+1)-za(i, kmix)) + za(i, kmix)
        CALL PUSHREAL8(umix)
        umix = fintt*(us(i, kmix+1)-us(i, kmix)) + us(i, kmix)
        CALL PUSHREAL8(vmix)
        vmix = fintt*(vs(i, kmix+1)-vs(i, kmix)) + vs(i, kmix)
        CALL PUSHCONTROL1B(1)
      ELSE
        zmix = za(i, 1)
        CALL PUSHREAL8(umix)
        umix = us(i, 1)
        CALL PUSHREAL8(vmix)
        vmix = vs(i, 1)
        CALL PUSHCONTROL1B(0)
      END IF
      CALL PUSHINTEGER4(k)
      ad_count0 = 1
      DO k=kmix,kte
        dtmp = thetav(i, k) - th1
        tog = 0.5D0*(thetav(i, k)+th1)/g
        CALL PUSHREAL8(wssq)
        wssq = (us(i, k)-umix)**2 + (vs(i, k)-vmix)**2
        IF (kmix .EQ. 1) THEN
          wssq = wssq + 100.D0*ust(i)*ust(i)
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        IF (wssq .LT. 0.1) THEN
          wssq = 0.1D0
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
          wssq = wssq
        END IF
        IF (za(i, k) - zmix .GE. 0.) THEN
          CALL PUSHREAL8(abs2)
          abs2 = za(i, k) - zmix
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHREAL8(abs2)
          abs2 = -(za(i, k)-zmix)
          CALL PUSHCONTROL1B(1)
        END IF
        rib(i, k) = abs2*dtmp/(tog*wssq)
        IF (rib(i, k) .GE. ric) THEN
          GOTO 110
        ELSE
          CALL PUSHINTEGER4(k)
          ad_count0 = ad_count0 + 1
        END IF
      END DO
      CALL PUSHCONTROL1B(0)
      CALL PUSHINTEGER4(ad_count0)
      GOTO 201
 110  CALL PUSHCONTROL1B(1)
      CALL PUSHINTEGER4(ad_count0)
!       write (message, *)' RIBX never exceeds RIC, RIB(i,kte) = ',rib(i,5),        &
!               ' THETAV(i,1) = ',thetav(i,1),' MOL=',mol(i),            &
!               ' TCONV = ',TCONV,' WST = ',WST(I),                      &
!               ' KMIX = ',kmix,' UST = ',UST(I),                       &
!               ' TST = ',TST(I),' U,V = ',US(I,1),VS(I,1),              &
!               ' I,J=',I,J
!       CALL wrf_error_fatal ( message )
 201  kpblh(i) = k
    END DO
    DO i=its,ite
      IF (kpblh(i) .NE. 1) THEN
!---------INTERPOLATE BETWEEN LEVELS -- jp 7/93
        fint(i) = (ric-rib(i, kpblh(i)-1))/(rib(i, kpblh(i))-rib(i, &
&          kpblh(i)-1))
        IF (fint(i) .GT. 0.5) THEN
          CALL PUSHINTEGER4(kpblht)
          kpblht = kpblh(i)
          fint(i) = fint(i) - 0.5D0
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHINTEGER4(kpblht)
          kpblht = kpblh(i) - 1
          fint(i) = fint(i) + 0.5D0
          CALL PUSHCONTROL1B(1)
        END IF
        CALL PUSHREAL8(pbl(i))
        pbl(i) = fint(i)*(zf(i, kpblht)-zf(i, kpblht-1)) + zf(i, kpblht-&
&          1)
        klpbl(i) = kpblht
! sigma at PBL height
        pblsig(i) = fint(i)*dsigh(kpblht) + sigmaf(kpblht-1)
        CALL PUSHCONTROL1B(1)
      ELSE
        klpbl(i) = 1
        CALL PUSHREAL8(pbl(i))
        pbl(i) = zf(i, 1)
        pblsig(i) = sigmaf(1)
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    DO i=its,ite
      noconv(i) = 0
! Check for CBL and identify conv. vs. non-conv cells
      IF (pbl(i)/mol(i) .LT. -0.02 .AND. klpbl(i) .GT. 3 .AND. thetav(i&
&          , 1) .GT. thetav(i, 2) .AND. xtime .GT. 1) noconv(i) = 1
! FREE CONVECTIVE - ACM
    END DO
!... Calculate Kz
    CALL EDDYX(dtpbl, zf, za, mol, pbl, ust, us, vs, tt, thetav, densx, &
&         pstar, qvs, qcs, qis, dsigfi, g, rd, cpair, eddyz, its, ite, &
&         kts, kte, ims, ime, kms, kme)
    CALL PUSHINTEGER4(k)
    a_ux = 0.0_8
    a_qix = 0.0_8
    a_qvx = 0.0_8
    a_vx = 0.0_8
    a_qcx = 0.0_8
    a_thetax = 0.0_8
    DO k=kte,kts,-1
      DO i=ite,its,-1
        a_qix(i, k) = a_qix(i, k) + rdt*a_qitnp(i, k)
        a_qis(i, k) = a_qis(i, k) - rdt*a_qitnp(i, k)
        a_qcx(i, k) = a_qcx(i, k) + rdt*a_qctnp(i, k)
        a_qcs(i, k) = a_qcs(i, k) - rdt*a_qctnp(i, k)
        a_qvx(i, k) = a_qvx(i, k) + rdt*a_qvtnp(i, k)
        a_qvs(i, k) = a_qvs(i, k) - rdt*a_qvtnp(i, k)
        a_thetax(i, k) = a_thetax(i, k) + rdt*a_ttnp(i, k)
        a_theta(i, k) = a_theta(i, k) - rdt*a_ttnp(i, k)
        a_vx(i, k) = a_vx(i, k) + rdt*a_vtnp(i, k)
        a_vs(i, k) = a_vs(i, k) - rdt*a_vtnp(i, k)
        a_ux(i, k) = a_ux(i, k) + rdt*a_utnp(i, k)
        a_us(i, k) = a_us(i, k) - rdt*a_utnp(i, k)
      END DO
    END DO
    CALL POPINTEGER4(k)
    CALL A_ACM(dtpbl, pstar, a_pstar, noconv, sigmaf, dsigh, dsighi, j, klpbl, &
&         pbl, a_pbl, pblsig, a_pblsig, mol, a_mol, ust, a_ust, tst, &
&         a_tst, qst, a_qst, ustm, a_ustm, eddyz, a_eddyz, densx, a_densx&
&         , us, a_us, vs, a_vs, theta, a_theta, qvs, a_qvs, qcs, a_qcs, &
&         qis, a_qis, ux, a_ux, vx, a_vx, thetax, a_thetax, qvx, a_qvx, &
&         qcx, a_qcx, qix, a_qix, &
#if (WRF_CHEM == 1)
          chem, a_chem, vd, a_vd, nchem, kdvel, ndvel, num_vert_mix, &
#endif
          ids, ide, jds, jde, kds, kde, ims, ime, &
&         jms, jme, kms, kme, its, ite, jts, jte, kts, kte)
    CALL A_EDDYX(dtpbl, zf, a_zf, za, a_za, mol, a_mol, pbl, a_pbl, ust&
&           , a_ust, us, a_us, vs, a_vs, tt, a_tt, thetav, a_thetav, &
&           densx, a_densx, pstar, a_pstar, qvs, a_qvs, qcs, qis, dsigfi, g, rd, &
&           cpair, a_cpair, eddyz, a_eddyz, its, ite, kts, kte, ims, ime&
&           , kms, kme)
    a_rib = 0.0_8
    a_fint = 0.0_8


!!!!
!!!!Need to print/force a_pbl here which goes to a_fint, a_rib, a_dtmp/a_tog,a_th1
!!!!
    DO i=ite,its,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        a_pblsig(i) = 0.0_8
        CALL POPREAL8(pbl(i))
        a_zf(i, 1) = a_zf(i, 1) + a_pbl(i)
        a_pbl(i) = 0.0_8
      ELSE
        a_fint(i) = a_fint(i) + (zf(i, kpblht)-zf(i, kpblht-1))*a_pbl(i)&
&          + dsigh(kpblht)*a_pblsig(i)
        a_pblsig(i) = 0.0_8
        CALL POPREAL8(pbl(i))
        a_zf(i, kpblht) = a_zf(i, kpblht) + fint(i)*a_pbl(i)
        a_zf(i, kpblht-1) = a_zf(i, kpblht-1) + (1.0D0-fint(i))*a_pbl(i)
        a_pbl(i) = 0.0_8
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPINTEGER4(kpblht)
        ELSE
          CALL POPINTEGER4(kpblht)
        END IF
        temp6 = rib(i, kpblh(i)) - rib(i, kpblh(i)-1)
        temp6b4 = -((ric-rib(i, kpblh(i)-1))*a_fint(i)/temp6**2)
        a_rib(i, kpblh(i)-1) = a_rib(i, kpblh(i)-1) - temp6b4 - a_fint&
&          (i)/temp6
        a_rib(i, kpblh(i)) = a_rib(i, kpblh(i)) + temp6b4
        a_fint(i) = 0.0_8
      END IF
    END DO
    a_wst = 0.0_8
    a_tstv = 0.0_8
    DO i=ite,its,-1
      a_zmix = 0.0_8
      a_th1 = 0.0_8
      a_vmix = 0.0_8
      a_umix = 0.0_8
      CALL POPINTEGER4(ad_count0)
      DO i1=1,ad_count0
        IF (i1 .EQ. 1) THEN
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            a_zmix = 0.0_8
            a_th1 = 0.0_8
            a_vmix = 0.0_8
            a_umix = 0.0_8
            GOTO 120
          ELSE
            a_zmix = 0.0_8
            a_th1 = 0.0_8
            a_vmix = 0.0_8
            a_umix = 0.0_8
          END IF
        END IF
        tog = 0.5D0*(thetav(i, k)+th1)/g
        dtmp = thetav(i, k) - th1
        temp6b2 = a_rib(i, k)/(tog*wssq)
        temp6b3 = -(abs2*dtmp*temp6b2/(tog*wssq))
        a_abs2 = dtmp*temp6b2
        a_dtmp = abs2*temp6b2
        a_tog = wssq*temp6b3
        a_wssq = tog*temp6b3
        a_rib(i, k) = 0.0_8
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(abs2)
          a_za(i, k) = a_za(i, k) + a_abs2
          a_zmix = a_zmix - a_abs2
        ELSE
          CALL POPREAL8(abs2)
          a_zmix = a_zmix + a_abs2
          a_za(i, k) = a_za(i, k) - a_abs2
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) a_wssq = 0.0_8
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) a_ust(i) = a_ust(i) + 100.D0*2.D0*ust(i)*a_wssq
        CALL POPREAL8(wssq)
        temp6b = 2.D0*(us(i, k)-umix)*a_wssq
        temp6b0 = 2.D0*(vs(i, k)-vmix)*a_wssq
        a_us(i, k) = a_us(i, k) + temp6b
        a_umix = a_umix - temp6b
        a_vs(i, k) = a_vs(i, k) + temp6b0
        a_vmix = a_vmix - temp6b0
        temp6b1 = 0.5D0*a_tog/g
        a_thetav(i, k) = a_thetav(i, k) + a_dtmp + temp6b1
        a_th1 = a_th1 + temp6b1 - a_dtmp
 120    CALL POPINTEGER4(k)
      END DO
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(vmix)
        a_vs(i, 1) = a_vs(i, 1) + a_vmix
        CALL POPREAL8(umix)
        a_us(i, 1) = a_us(i, 1) + a_umix
        a_za(i, 1) = a_za(i, 1) + a_zmix
      ELSE
        CALL POPREAL8(vmix)
        a_fintt = (us(i, kmix+1)-us(i, kmix))*a_umix + (za(i, kmix+1)-za&
&          (i, kmix))*a_zmix + (vs(i, kmix+1)-vs(i, kmix))*a_vmix
        a_vs(i, kmix+1) = a_vs(i, kmix+1) + fintt*a_vmix
        a_vs(i, kmix) = a_vs(i, kmix) + (1.0D0-fintt)*a_vmix
        CALL POPREAL8(umix)
        a_us(i, kmix+1) = a_us(i, kmix+1) + fintt*a_umix
        a_us(i, kmix) = a_us(i, kmix) + (1.0D0-fintt)*a_umix
        a_za(i, kmix+1) = a_za(i, kmix+1) + fintt*a_zmix
        a_za(i, kmix) = a_za(i, kmix) + (1.0D0-fintt)*a_zmix
        CALL POPREAL8(fintt)
        temp5 = thetav(i, kmix+1) - thetav(i, kmix)
        temp5b = a_fintt/temp5
        temp5b0 = -((th1-thetav(i, kmix))*temp5b/temp5)
        a_th1 = a_th1 + temp5b
        a_thetav(i, kmix) = a_thetav(i, kmix) - temp5b0 - temp5b
        a_thetav(i, kmix+1) = a_thetav(i, kmix+1) + temp5b0
      END IF
      CALL POPINTEGER4(kmix)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        a_tconv = a_th1
        temp4 = ust(i)/wss
        temp4b = -(tstv(i)*8.5D0*a_tconv/wss)
        a_wss = -(temp4*temp4b)
        a_tstv(i) = a_tstv(i) - 8.5D0*temp4*a_tconv
        CALL POPREAL8(wss)
        temp4b0 = 0.33333D0*(ust(i)**3+0.6D0*wst(i)**3)**(-0.66667D0)*a_wss
        a_ust(i) = a_ust(i) + 3.D0*ust(i)**2*temp4b0 + temp4b
        a_wst(i) = a_wst(i) + 0.6D0*3.D0*wst(i)**2*temp4b0
      END IF
      a_th1 = a_th1/ksrc
      CALL POPINTEGER4(ad_to)
      DO k=ad_to,1,-1
        a_thetav(i, k) = a_thetav(i, k) + a_th1
      END DO
      CALL POPREAL8(th1)
      CALL POPINTEGER4(ad_count)
      DO i0=1,ad_count
        IF (i0 .EQ. 1) THEN
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) GOTO 130
        END IF
        CALL POPINTEGER4(ksrc)
 130    CALL POPINTEGER4(k)
      END DO
    END DO
    DO k=kte,kts,-1
      DO i=ite,its,-1
        tvcon = 1.0D0 + ep1*qvs(i, k)
        a_theta(i, k) = a_theta(i, k) + tvcon*a_thetav(i, k)
        a_tvcon = theta(i, k)*a_thetav(i, k)
        a_thetav(i, k) = 0.0_8
        a_qvs(i, k) = a_qvs(i, k) + ep1*a_tvcon
      END DO
    END DO
    DO k=kte,kts,-1
      DO i=ite,its,-1
        a_zf(i, k) = a_zf(i, k) + 0.5D0*a_za(i, k)
        a_zf(i, k-1) = a_zf(i, k-1) + 0.5D0*a_za(i, k)
        a_za(i, k) = 0.0_8
        a_dzf(i, k) = a_dzf(i, k) + a_zf(i, k)
        a_zf(i, k-1) = a_zf(i, k-1) + a_zf(i, k)
        a_zf(i, k) = 0.0_8
      END DO
    END DO
    DO i=ite,its,-1
      a_mut(i) = a_mut(i) + a_pstar(i)/1000.D0
      a_pstar(i) = 0.0_8
      temp3 = karman*abs1
      temp2 = pbl(i)/temp3
      IF(pbl(i) .LE. 0.D0) THEN
         temp2b = 0.D0
      ELSE
         temp2b = 0.333333D0*temp2**(-0.666667D0)*ust(i)*a_wst(i)/temp3
      ENDIF
      a_ust(i) = a_ust(i) + temp2**0.333333D0*a_wst(i)
      a_pbl(i) = a_pbl(i) + temp2b
      a_abs1 = -(temp2*karman*temp2b)
      a_wst(i) = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(abs1)
        a_mol(i) = a_mol(i) + a_abs1
      ELSE
        CALL POPREAL8(abs1)
        a_mol(i) = a_mol(i) - a_abs1
      END IF
      tmpvtcon = 1.0D0 + ep1*qvs(i, 1)
      thv1 = tmpvtcon*theta(i, 1)
      temp1 = karman*g*tstv(i)
      temp1b0 = a_mol(i)/temp1
      a_thv1 = ust(i)**2*temp1b0
      a_ust(i) = a_ust(i) + thv1*2.D0*ust(i)*temp1b0
      a_tstv(i) = a_tstv(i) - thv1*ust(i)**2*karman*g*temp1b0/temp1
      a_mol(i) = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) a_tstv(i) = 0.0_8
      a_thv1 = a_thv1 + ep1*qst(i)*a_tstv(i)
      a_tst(i) = a_tst(i) + tmpvtcon*a_tstv(i)
      a_tmpvtcon = theta(i, 1)*a_thv1 + tst(i)*a_tstv(i)
      a_qst(i) = a_qst(i) + ep1*thv1*a_tstv(i)
      a_tstv(i) = 0.0_8
      a_theta(i, 1) = a_theta(i, 1) + tmpvtcon*a_thv1
      temp1b = a_ustm(i)/wspd(i)
      a_ws1 = ust(i)*temp1b
      a_wspd(i) = a_wspd(i) - ust(i)*ws1*temp1b/wspd(i)
      a_ustm(i) = 0.0_8
      temp0 = ust(i)*densx(i, 1)
      temp0b = qfx(i)*a_qst(i)/temp0**2
      a_qfx(i) = a_qfx(i) - a_qst(i)/temp0
      a_qst(i) = 0.0_8
      tmpfx = hfx(i)/(cpair(i)*densx(i, 1))
      temp0b0 = -(a_tst(i)/ust(i))
      a_ust(i) = a_ust(i) + densx(i, 1)*temp0b - tmpfx*temp0b0/ust(i&
&        ) + ws1*temp1b
      a_tmpfx = temp0b0
      a_tst(i) = 0.0_8
      CALL POPREAL8(ws1)
      IF (us(i, 1)**2 + vs(i, 1)**2 .EQ. 0.0_8) THEN
        temp0b1 = 0.0D0
      ELSE
        temp0b1 = a_ws1/(2.0D0*SQRT(us(i, 1)**2+vs(i, 1)**2))
      END IF
      a_us(i, 1) = a_us(i, 1) + 2.D0*us(i, 1)*temp0b1
      a_vs(i, 1) = a_vs(i, 1) + 2.D0*vs(i, 1)*temp0b1
      temp = cpair(i)*densx(i, 1)
      tempb = -(hfx(i)*a_tmpfx/temp**2)
      a_densx(i, 1) = a_densx(i, 1) + cpair(i)*tempb + ust(i)*temp0b
      a_hfx(i) = a_hfx(i) + a_tmpfx/temp
      a_cpair(i) = a_cpair(i) + densx(i, 1)*tempb
      a_qvs(i, 1) = a_qvs(i, 1) + cpd*0.84D0*a_cpair(i) + ep1*a_tmpvtcon
      a_cpair(i) = 0.0_8
    END DO
    DO k=kte,kts,-1
      DO i=ite,its,-1
        a_qitnp(i, k) = 0.0_8
        a_qctnp(i, k) = 0.0_8
      END DO
    END DO
    DO k=kte,kts,-1
      DO i=ite,its,-1
        a_qvtnp(i, k) = 0.0_8
      END DO
    END DO
    DO i=ite,its,-1
      DO k=kte,kts,-1
        a_ttnp(i, k) = 0.0_8
        a_vtnp(i, k) = 0.0_8
        a_utnp(i, k) = 0.0_8
      END DO
    END DO
  END SUBROUTINE A_ACM2D

!  Differentiation of eddyx in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: tt pstar ust us qvs vs pbl densx
!                eddyz mol
!   with respect to varying inputs: tt pstar ust us cpair qvs vs pbl
!                za zf densx thetav mol
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!-------------------------------------------------------------------          
  SUBROUTINE A_EDDYX(dtpbl, zf, a_zf, za, a_za, mol, a_mol, pbl, a_pbl, &
&    ust, a_ust, us, a_us, vs, a_vs, tt, a_tt, thetav, a_thetav, densx, &
&    a_densx, pstar, a_pstar, qvs, a_qvs, qcs, qis, dsigfi, g, rd, cpair, a_cpair&
&    , eddyz, a_eddyz, its, ite, kts, kte, ims, ime, kms, kme)
    IMPLICIT NONE
!.......Arguments
!... Integer
    INTEGER, INTENT(IN) :: its, ite, kts, kte, ims, ime, kms, kme
!... Real
    REAL, DIMENSION(ims:ime), INTENT(IN) :: pbl, ust
    REAL, DIMENSION(ims:ime) :: a_pbl, a_ust
    REAL, INTENT(IN) :: dtpbl, g, rd
    REAL, DIMENSION(kts:kte), INTENT(IN) :: dsigfi
    REAL, DIMENSION(its:ite), INTENT(IN) :: mol, pstar, cpair
    REAL, DIMENSION(its:ite) :: a_mol, a_pstar, a_cpair
    REAL, DIMENSION(ims:ime, kms:kme), INTENT(IN) :: us, vs, tt, qvs, &
&    qcs, qis, densx
    REAL, DIMENSION(ims:ime, kms:kme) :: a_us, a_vs, a_tt, a_qvs, &
&    a_densx
    REAL, DIMENSION(its:ite, kts:kte), INTENT(IN) :: za, thetav
    REAL, DIMENSION(its:ite, kts:kte) :: a_za, a_thetav
    REAL, DIMENSION(its:ite, 0:kte), INTENT(IN) :: zf
    REAL, DIMENSION(its:ite, 0:kte) :: a_zf
    REAL, DIMENSION(its:ite, kts:kte) :: eddyz
    REAL, DIMENSION(its:ite, kts:kte) :: a_eddyz
!.......Local variables
!... Integer
    INTEGER :: ilx, kl, klm, k, i
!... Real
    REAL :: zovl, phih, wt, zsol, zfunc, dzf, ss, goth, edyz
    REAL :: a_zovl, a_phih, a_wt, a_zsol, a_zfunc, a_dzf, a_ss, a_goth, &
&    a_edyz
    REAL :: ri, qmean, tmean, xlv, alph, chi, zk, sql, densf, kzo
    REAL :: a_ri, a_qmean, a_tmean, a_xlv, a_alph, a_chi, a_zk, a_sql, &
&    a_densf
    REAL :: fh
    REAL :: a_fh
!... Parameters
    REAL, PARAMETER :: rv=461.5D0
    REAL, PARAMETER :: rc=0.25D0
    REAL, PARAMETER :: rlam=80.0D0
!15.0  !  Holtslag and Boville (1993)
    REAL, PARAMETER :: gamh=16.0D0
!  Holtslag and Boville (1993)
    REAL, PARAMETER :: betah=5.0D0
    REAL, PARAMETER :: karman=0.4D0
! New Min Kz
    REAL, PARAMETER :: edyz0=0.01D0
!      REAL, PARAMETER :: EDYZ0  = 0.1
!--   IMVDIF      imvdif=1 for moist adiabat vertical diffusion
    INTEGER, PARAMETER :: imvdif=1
    INTEGER :: branch
    REAL :: temp3
    REAL :: temp2
    REAL :: temp1
    REAL :: temp13b
    REAL :: temp0
    REAL :: temp0b
    REAL :: temp2b0
    REAL :: temp14b
    REAL :: temp1b
    REAL :: temp2b
    INTRINSIC MAX
    REAL :: temp16b
    REAL :: temp3b
    REAL :: temp15
    REAL :: temp14
    REAL :: temp13
    REAL :: temp12
    REAL :: temp11
    REAL :: temp4b
    REAL :: temp10
    REAL :: a_max2
    REAL :: a_max3
    REAL :: temp5b
    REAL :: temp6b
    REAL :: temp7b
    REAL :: tempb
    REAL :: temp10b
    REAL :: temp8b
    REAL :: temp11b
    INTRINSIC MIN
    REAL :: temp9b
    INTRINSIC SQRT
    REAL :: temp
    REAL :: max2
    REAL :: temp12b
    REAL :: max3
    REAL :: temp9
    REAL :: temp8
    REAL :: temp7
    REAL :: temp6
    REAL :: temp5
    REAL :: temp7b1
    REAL :: temp4
    REAL :: temp7b0
!
    ilx = ite
    kl = kte
    klm = kte - 1
    DO k=kts,klm
      DO i=its,ilx
        edyz = 0.0D0
        CALL PUSHREAL8(zovl)
        zovl = 0.0D0
        CALL PUSHREAL8(dzf)
        dzf = za(i, k+1) - za(i, k)
        kzo = edyz0
!--------------------------------------------------------------------------
        IF (zf(i, k) .LT. pbl(i)) THEN
          zovl = zf(i, k)/mol(i)
          IF (zovl .LT. 0.0) THEN
            IF (zf(i, k) .LT. 0.1*pbl(i)) THEN
              CALL PUSHREAL8(phih)
              phih = 1.0D0/SQRT(1.0D0-gamh*zovl)
              CALL PUSHREAL8(wt)
              wt = ust(i)/phih
              CALL PUSHCONTROL2B(0)
            ELSE
              zsol = 0.1D0*pbl(i)/mol(i)
              CALL PUSHREAL8(phih)
              phih = 1.0D0/SQRT(1.0D0-gamh*zsol)
              CALL PUSHREAL8(wt)
              wt = ust(i)/phih
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE IF (zovl .LT. 1.0D0) THEN
            CALL PUSHREAL8(phih)
            phih = 1.0D0 + betah*zovl
            CALL PUSHREAL8(wt)
            wt = ust(i)/phih
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHREAL8(phih)
            phih = betah + zovl
            CALL PUSHREAL8(wt)
            wt = ust(i)/phih
            CALL PUSHCONTROL2B(3)
          END IF
          CALL PUSHREAL8(zfunc)
          zfunc = zf(i, k)*(1.0D0-zf(i, k)/pbl(i))**2
          edyz = karman*wt*zfunc
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        CALL PUSHREAL8(ss)
!--------------------------------------------------------------------------
        ss = ((us(i, k+1)-us(i, k))**2+(vs(i, k+1)-vs(i, k))**2)/(dzf*&
&          dzf) + 1.0d-9
        CALL PUSHREAL8(goth)
        goth = 2.0D0*g/(thetav(i, k+1)+thetav(i, k))
        CALL PUSHREAL8(ri)
        ri = goth*(thetav(i, k+1)-thetav(i, k))/(dzf*ss)
!--------------------------------------------------------------------------
!         Adjustment to vert diff in Moist air
        IF (imvdif .EQ. 1) THEN
          IF (qcs(i, k) + qis(i, k) .GT. 0.01d-3 .OR. qcs(i, k+1) + qis(&
&              i, k+1) .GT. 0.01d-3) THEN
            qmean = 0.5D0*(qvs(i, k)+qvs(i, k+1))
            tmean = 0.5D0*(tt(i, k)+tt(i, k+1))
            xlv = (2.501D0-0.00237D0*(tmean-273.15D0))*1.d6
            alph = xlv*qmean/rd/tmean
            chi = xlv*xlv*qmean/cpair(i)/rv/tmean/tmean
            CALL PUSHREAL8(ri)
            ri = (1.0D0+alph)*(ri-g*g/ss/tmean/cpair(i)*((chi-alph)/(1.0D0+&
&              chi)))
            CALL PUSHCONTROL2B(0)
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(2)
        END IF
!--------------------------------------------------------------------------
        zk = 0.4D0*zf(i, k)
        CALL PUSHREAL8(sql)
        sql = (zk*rlam/(rlam+zk))**2
        IF (ri .GE. 0.0) THEN
          IF (zf(i, k) .LT. pbl(i) .AND. zovl .GT. 0.0) THEN
            IF ((1.D0-zf(i, k)/pbl(i))**2 .LT. 0.01) THEN
              CALL PUSHREAL8(max3)
              max3 = 0.01D0
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREAL8(max3)
              max3 = (1.D0-zf(i, k)/pbl(i))**2
              CALL PUSHCONTROL1B(1)
            END IF
            CALL PUSHREAL8(fh)
            fh = max3*phih**(-2)
            sql = zk**2
            CALL PUSHCONTROL1B(0)
          ELSE
            IF (1.D0 - ri/rc .LT. 0.01) THEN
              CALL PUSHREAL8(max2)
              max2 = 0.01D0
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREAL8(max2)
              max2 = 1.D0 - ri/rc
              CALL PUSHCONTROL1B(1)
            END IF
            CALL PUSHREAL8(fh)
            fh = max2**2
            CALL PUSHCONTROL1B(1)
          END IF
          eddyz(i, k) = kzo + SQRT(ss)*fh*sql
          CALL PUSHCONTROL1B(0)
        ELSE
          eddyz(i, k) = kzo + SQRT(ss*(1.0D0-25.0D0*ri))*sql
          CALL PUSHCONTROL1B(1)
        END IF
        IF (edyz .GT. eddyz(i, k)) THEN
          eddyz(i, k) = edyz
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        IF (1000.0 .GT. eddyz(i, k)) THEN
          CALL PUSHCONTROL1B(0)
          eddyz(i, k) = eddyz(i, k)
        ELSE
          eddyz(i, k) = 1000.0D0
          CALL PUSHCONTROL1B(1)
        END IF
        IF (kzo .LT. eddyz(i, k)) THEN
          CALL PUSHCONTROL1B(0)
          eddyz(i, k) = eddyz(i, k)
        ELSE
          eddyz(i, k) = kzo
          CALL PUSHCONTROL1B(1)
        END IF
      END DO
    END DO
    DO i=ilx,its,-1
      a_eddyz(i, kl) = 0.0_8
    END DO
    a_cpair = 0.0_8
    a_za = 0.0_8
    a_zf = 0.0_8
    a_thetav = 0.0_8
    a_phih = 0.0_8
    DO k=klm,kts,-1
      DO i=ilx,its,-1
        densf = 0.5D0*(densx(i, k+1)+densx(i, k))
        temp16b = g**2*dsigfi(k)*dtpbl*1.d-6*a_eddyz(i, k)/pstar(i)**2
        a_densf = eddyz(i, k)*2.D0*densf*temp16b
        a_pstar(i) = a_pstar(i) - eddyz(i, k)*densf**2*2.D0*temp16b/pstar(i)
        a_eddyz(i, k) = densf**2*temp16b
        a_densx(i, k+1) = a_densx(i, k+1) + 0.5D0*a_densf
        a_densx(i, k) = a_densx(i, k) + 0.5D0*a_densf
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) a_eddyz(i, k) = 0.0_8
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) a_eddyz(i, k) = 0.0_8
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          a_edyz = 0.0_8
        ELSE
          a_edyz = a_eddyz(i, k)
          a_eddyz(i, k) = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          temp13 = SQRT(ss)
          IF (ss .EQ. 0.0_8) THEN
            a_ss = 0.0D0
          ELSE
            a_ss = fh*sql*a_eddyz(i, k)/(2.0D0*temp13)
          END IF
          a_fh = temp13*sql*a_eddyz(i, k)
          a_sql = temp13*fh*a_eddyz(i, k)
          a_eddyz(i, k) = 0.0_8
          zk = 0.4D0*zf(i, k)
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            a_zk = 2.D0*zk*a_sql
            CALL POPREAL8(fh)
            temp13b = a_fh/phih**2
            a_max3 = temp13b
            a_phih = a_phih - max3*2.D0*temp13b/phih
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREAL8(max3)
            ELSE
              CALL POPREAL8(max3)
              temp12 = zf(i, k)/pbl(i)
              temp12b = -(2.D0*(1.D0-temp12)*a_max3/pbl(i))
              a_zf(i, k) = a_zf(i, k) + temp12b
              a_pbl(i) = a_pbl(i) - temp12*temp12b
            END IF
            a_sql = 0.0_8
            a_ri = 0.0_8
          ELSE
            CALL POPREAL8(fh)
            a_max2 = 2.D0*max2*a_fh
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREAL8(max2)
              a_ri = 0.0_8
            ELSE
              CALL POPREAL8(max2)
              a_ri = -(a_max2/rc)
            END IF
            a_zk = 0.0_8
          END IF
        ELSE
          zk = 0.4D0*zf(i, k)
          sql = (zk*rlam/(rlam+zk))**2
          temp14 = ss*(-(25.0D0*ri)+1.0D0)
          temp15 = SQRT(temp14)
          IF (temp14 .EQ. 0.0_8) THEN
            temp14b = 0.0D0
          ELSE
            temp14b = sql*a_eddyz(i, k)/(2.0D0*temp15)
          END IF
          a_ss = (1.0D0-25.0D0*ri)*temp14b
          a_ri = -(ss*25.0D0*temp14b)
          a_sql = temp15*a_eddyz(i, k)
          a_eddyz(i, k) = 0.0_8
          a_zk = 0.0_8
        END IF
        CALL POPREAL8(sql)
        temp11 = zk/(rlam+zk)
        temp11b = rlam**2*2.D0*temp11*a_sql/(rlam+zk)
        a_zk = a_zk + (1.0D0-temp11)*temp11b
        a_zf(i, k) = a_zf(i, k) + 0.4D0*a_zk
        CALL POPCONTROL2B(branch)
        IF (branch .EQ. 0) THEN
          tmean = 0.5D0*(tt(i, k)+tt(i, k+1))
          goth = 2.0D0*g/(thetav(i, k+1)+thetav(i, k))
          qmean = 0.5D0*(qvs(i, k)+qvs(i, k+1))
          xlv = (2.501D0-0.00237D0*(tmean-273.15D0))*1.d6
          chi = xlv*xlv*qmean/cpair(i)/rv/tmean/tmean
          dzf = za(i, k+1) - za(i, k)
          alph = xlv*qmean/rd/tmean
          CALL POPREAL8(ri)
          temp10 = cpair(i)*(chi+1.0D0)
          temp9 = ss*tmean*temp10
          temp8 = (chi-alph)/temp9
          temp8b = -(g**2*(alph+1.0D0)*a_ri/temp9)
          temp9b = -(temp8*temp8b)
          temp10b = ss*tmean*temp9b
          a_alph = (ri-g**2*temp8)*a_ri - temp8b
          a_chi = cpair(i)*temp10b + temp8b
          a_ss = a_ss + temp10*tmean*temp9b
          a_ri = (alph+1.0D0)*a_ri
          temp7 = rv*cpair(i)*tmean**2
          temp7b1 = a_chi/temp7
          temp7b = -(xlv**2*qmean*temp7b1/temp7)
          a_cpair(i) = a_cpair(i) + tmean**2*rv*temp7b + (chi+1.0D0)*&
&            temp10b
          temp7b0 = a_alph/(rd*tmean)
          a_xlv = qmean*temp7b0 + qmean*2.D0*xlv*temp7b1
          a_tmean = rv*cpair(i)*2.D0*tmean*temp7b - 1.d6*0.00237D0*a_xlv - &
&            xlv*qmean*temp7b0/tmean + temp10*ss*temp9b
          a_qmean = xlv*temp7b0 + xlv**2*temp7b1
          a_tt(i, k) = a_tt(i, k) + 0.5D0*a_tmean
          a_tt(i, k+1) = a_tt(i, k+1) + 0.5D0*a_tmean
          a_qvs(i, k) = a_qvs(i, k) + 0.5D0*a_qmean
          a_qvs(i, k+1) = a_qvs(i, k+1) + 0.5D0*a_qmean
        END IF
        temp3 = vs(i, k+1) - vs(i, k)
        temp2 = us(i, k+1) - us(i, k)
        CALL POPREAL8(ri)
        temp6 = dzf*ss
        temp5 = goth/temp6
        temp5b = (thetav(i, k+1)-thetav(i, k))*a_ri/temp6
        temp6b = -(temp5*temp5b)
        a_thetav(i, k+1) = a_thetav(i, k+1) + temp5*a_ri
        a_thetav(i, k) = a_thetav(i, k) - temp5*a_ri
        a_goth = temp5b
        a_ss = a_ss + dzf*temp6b
        CALL POPREAL8(goth)
        temp4 = thetav(i, k+1) + thetav(i, k)
        temp4b = -(g*2.0D0*a_goth/temp4**2)
        a_thetav(i, k+1) = a_thetav(i, k+1) + temp4b
        a_thetav(i, k) = a_thetav(i, k) + temp4b
        temp2b = a_ss/dzf**2
        a_dzf = ss*temp6b - (temp2**2+temp3**2)*2.D0*temp2b/dzf
        CALL POPREAL8(ss)
        temp2b0 = 2.D0*temp2*temp2b
        temp3b = 2.D0*temp3*temp2b
        a_us(i, k+1) = a_us(i, k+1) + temp2b0
        a_us(i, k) = a_us(i, k) - temp2b0
        a_vs(i, k+1) = a_vs(i, k+1) + temp3b
        a_vs(i, k) = a_vs(i, k) - temp3b
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          a_wt = karman*zfunc*a_edyz
          a_zfunc = karman*wt*a_edyz
          CALL POPREAL8(zfunc)
          temp1 = zf(i, k)/pbl(i)
          temp1b = -(2.D0*(1.0D0-temp1)*zf(i, k)*a_zfunc/pbl(i))
          a_zf(i, k) = a_zf(i, k) + temp1b + (1.0D0-temp1)**2*a_zfunc
          a_pbl(i) = a_pbl(i) - temp1*temp1b
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              CALL POPREAL8(wt)
              a_ust(i) = a_ust(i) + a_wt/phih
              a_phih = a_phih - ust(i)*a_wt/phih**2
              CALL POPREAL8(phih)
              temp = SQRT(-(gamh*zovl) + 1.0D0)
              IF (1.0D0 - gamh*zovl .EQ. 0.0_8) THEN
                a_zovl = 0.0D0
              ELSE
                a_zovl = gamh*a_phih/(2.0D0*temp**3)
              END IF
            ELSE
              CALL POPREAL8(wt)
              a_ust(i) = a_ust(i) + a_wt/phih
              a_phih = a_phih - ust(i)*a_wt/phih**2
              zsol = 0.1D0*pbl(i)/mol(i)
              CALL POPREAL8(phih)
              temp0 = SQRT(-(gamh*zsol) + 1.0D0)
              IF (1.0D0 - gamh*zsol .EQ. 0.0_8) THEN
                a_zsol = 0.0D0
              ELSE
                a_zsol = gamh*a_phih/(2.0D0*temp0**3)
              END IF
              temp0b = 0.1D0*a_zsol/mol(i)
              a_pbl(i) = a_pbl(i) + temp0b
              a_mol(i) = a_mol(i) - pbl(i)*temp0b/mol(i)
              a_zovl = 0.0_8
            END IF
          ELSE IF (branch .EQ. 2) THEN
            CALL POPREAL8(wt)
            a_ust(i) = a_ust(i) + a_wt/phih
            a_phih = a_phih - ust(i)*a_wt/phih**2
            CALL POPREAL8(phih)
            a_zovl = betah*a_phih
          ELSE
            CALL POPREAL8(wt)
            a_ust(i) = a_ust(i) + a_wt/phih
            a_phih = a_phih - ust(i)*a_wt/phih**2
            CALL POPREAL8(phih)
            a_zovl = a_phih
          END IF
          tempb = a_zovl/mol(i)
          a_zf(i, k) = a_zf(i, k) + tempb
          a_mol(i) = a_mol(i) - zf(i, k)*tempb/mol(i)
          a_phih = 0.0_8
        END IF
        CALL POPREAL8(dzf)
        a_za(i, k+1) = a_za(i, k+1) + a_dzf
        a_za(i, k) = a_za(i, k) - a_dzf
        CALL POPREAL8(zovl)
      END DO
    END DO
  END SUBROUTINE A_EDDYX

!  Differentiation of acm in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: alloc(*vci) alloc(*fs) alloc(*ui)
!                alloc(*di) ust us ux theta vd qis qvs qix qvx
!                vs qcs vx pbl qcx densx chem thetax
!   with respect to varying inputs: alloc(*vci) alloc(*fs) alloc(*ui)
!                alloc(*di) pstar ust us theta tst vd qis qvs ustm vs
!                qst pblsig qcs pbl densx chem eddyz mol
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!-------------------------------------------------------------------          
  SUBROUTINE A_ACM(dtpbl, pstar, a_pstar, noconv, sigmaf, dsigh, dsighi, jx, &
&    klpbl, pbl, a_pbl, pblsig, a_pblsig, mol, a_mol, ust, a_ust, tst, &
&    a_tst, qst, a_qst, ustm, a_ustm, eddyz, a_eddyz, densx, a_densx, us&
&    , a_us, vs, a_vs, theta, a_theta, qvs, a_qvs, qcs, a_qcs, qis, a_qis&
&    , ux, a_ux, vx, a_vx, thetax, a_thetax, qvx, a_qvx, qcx, a_qcx, qix&
&    , a_qix, &
#if (WRF_CHEM == 1)
     chem, a_chem, vd, a_vd, nchem, kdvel, ndvel, num_vert_mix, &
#endif
&    ids, ide, jds, jde, kds, kde, ims, ime, jms, jme, kms, kme, its, ite&
&    , jts, jte, kts, kte)
    IMPLICIT NONE
!.......Arguments
!... Integer
    INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, its, ite, jts, jte, kts, kte, jx
    INTEGER, DIMENSION(its:ite), INTENT(IN) :: noconv
    INTEGER, DIMENSION(ims:ime), INTENT(IN) :: klpbl
!... Real
    REAL, DIMENSION(ims:ime), INTENT(IN) :: pbl, ust
    REAL, DIMENSION(ims:ime) :: a_pbl, a_ust
    REAL, INTENT(IN) :: dtpbl
    REAL, DIMENSION(its:ite), INTENT(IN) :: pstar, pblsig, mol, tst, qst&
&    , ustm
    REAL, DIMENSION(its:ite) :: a_pstar, a_pblsig, a_mol, a_tst, a_qst, a_ustm
    REAL, DIMENSION(kts:kte), INTENT(IN) :: dsighi, dsigh
    REAL, DIMENSION(0:kte), INTENT(IN) :: sigmaf
    REAL, DIMENSION(its:ite, kts:kte), INTENT(INOUT) :: eddyz
    REAL, DIMENSION(its:ite, kts:kte), INTENT(INOUT) :: a_eddyz
    REAL, DIMENSION(ims:ime, kms:kme), INTENT(IN) :: us, vs, theta, qvs&
&    , qcs, qis, densx
    REAL, DIMENSION(ims:ime, kms:kme) :: a_us, a_vs, a_theta, a_qvs, &
&    a_qcs, a_qis, a_densx
    REAL, DIMENSION(its:ite, kts:kte) :: ux, vx, thetax, qvx, qcx, qix
    REAL, DIMENSION(its:ite, kts:kte) :: a_ux, a_vx, a_thetax, a_qvx, &
&    a_qcx, a_qix
#if (WRF_CHEM == 1)
!......Chem
    INTEGER, INTENT(IN) :: nchem, kdvel, ndvel, num_vert_mix
    REAL, DIMENSION(ims:ime, kms:kme, nchem), INTENT(INOUT) :: chem
    REAL, DIMENSION(ims:ime, kms:kme, nchem), INTENT(INOUT) :: a_chem
    REAL, DIMENSION(ims:ime, kdvel, ndvel), INTENT(IN) :: vd
    REAL, DIMENSION(ims:ime, kdvel, ndvel) :: a_vd
#endif
!.......Local variables
!... Parameters
    INTEGER, PARAMETER :: nsp=6
!
!......ACM2 Parameters
!     INTEGER, PARAMETER :: IFACM = 0
!
    REAL, PARAMETER :: g1000=9.8d-3
! FACTOR APPLIED TO CONV MIXING TIME STEP
    REAL, PARAMETER :: xx=0.5D0
    REAL, PARAMETER :: karman=0.4D0
!... Integer
    INTEGER :: ilx, kl, klm, i, k, nspx, nlp, nl, jj, l, ll
    INTEGER :: kcblmx
    INTEGER, DIMENSION(its:ite) :: kcbl
!... Real
    REAL :: g1000i, mbmax, hovl, meddy, mbar
    REAL :: a_hovl, a_meddy, a_mbar
    REAL :: ekz, rz, fm, wspd, dts, dtrat, f1
    REAL :: a_fm, a_wspd, a_f1
    REAL, DIMENSION(its:ite) :: pstari, fsacm, dtlim
    REAL, DIMENSION(its:ite) :: a_pstari, a_fsacm
    REAL, DIMENSION(kts:kte, its:ite) :: mbarks, mdwn
    REAL, DIMENSION(kts:kte, its:ite) :: a_mbarks, a_mdwn
    REAL, DIMENSION(kts:kte) :: xplus, xminus
    REAL, DIMENSION(kts:kte) :: a_xplus, a_xminus
    REAL :: delc
    REAL :: a_delc
!, Y
    REAL, DIMENSION(kts:kte) :: ai, bi, ci, ei
    REAL, DIMENSION(kts:kte) :: a_ai, a_bi, a_ci, a_ei
    REAL, DIMENSION(:, :), ALLOCATABLE :: di, ui
    REAL, DIMENSION(:, :), ALLOCATABLE :: a_di, a_ui
    REAL, DIMENSION(:, :), ALLOCATABLE :: fs, bcbotn
    REAL, DIMENSION(:, :), ALLOCATABLE :: a_fs
    REAL, DIMENSION(:, :, :), ALLOCATABLE :: vci
    REAL, DIMENSION(:, :, :), ALLOCATABLE :: a_vci
    CHARACTER(len=80) :: message
    INTEGER :: ad_to
    INTEGER :: ad_to0
    INTEGER :: branch
    INTEGER :: ad_to1
    INTEGER :: ad_from
    INTEGER :: ad_to2
    INTEGER :: ad_from0
    INTEGER :: ad_to3
    REAL :: temp2b4
    REAL :: temp2b3
    REAL :: temp1
    REAL :: temp2b2
    REAL :: temp0
    REAL :: temp2b1
    REAL :: temp2b0
    REAL :: temp2b19
    REAL :: temp2b18
    REAL :: temp2b17
    REAL :: temp2b16
    REAL :: temp2b15
    REAL :: temp2b14
    REAL :: temp2b13
    REAL :: temp2b12
    REAL :: temp2b11
    REAL :: temp2b10
    REAL :: temp2b
    INTRINSIC INT
    REAL :: tempb
    INTRINSIC SQRT
    REAL :: temp
    REAL :: temp2b9
    REAL :: temp2b8
    REAL :: temp2b7
    REAL :: temp2b6
    REAL :: temp2b5
!
!--Start Exicutable ----
    ilx = ite
    kl = kte
    klm = kte - 1
    nspx = nsp
#if (WRF_CHEM == 1)
    nspx = nspx + num_vert_mix
#endif
    g1000i = 1.0D0/g1000
!...Allocate species variables
    ALLOCATE(a_di(1:nspx, kts:kte))
    ALLOCATE(di(1:nspx, kts:kte))
    ALLOCATE(a_ui(1:nspx, kts:kte))
    ALLOCATE(ui(1:nspx, kts:kte))
    ALLOCATE(a_fs(1:nspx, its:ite))
    ALLOCATE(fs(1:nspx, its:ite))
    ALLOCATE(bcbotn(1:nspx, its:ite))
    ALLOCATE(a_vci(1:nspx, its:ite, kts:kte))
    ALLOCATE(vci(1:nspx, its:ite, kts:kte))
a_di=0.D0
a_ui=0.D0
a_fs=0.D0
a_vci=0.D0
!---COMPUTE ACM MIXING RATE
    DO i=its,ilx
      dtlim(i) = dtpbl
      pstari(i) = 1.0D0/pstar(i)
      kcbl(i) = 1
      IF (noconv(i) .EQ. 1) THEN
        kcbl(i) = klpbl(i)
!-------MBARKS IS UPWARD MIXING RATE; MDWN IS DOWNWARD MIXING RATE
!--New couple ACM & EDDY-------------------------------------------------------------
        hovl = -(pbl(i)/mol(i))
        fsacm(i) = 1.D0/(1.D0+(karman/hovl)**0.3333D0/(0.72D0*karman))
        CALL PUSHREAL8(meddy)
        meddy = eddyz(i, 1)/(dtpbl*(pblsig(i)-sigmaf(1)))
        mbar = meddy*fsacm(i)
        DO k=kts,kcbl(i)-1
          CALL PUSHREAL8(eddyz(i, k))
          eddyz(i, k) = eddyz(i, k)*(1.0D0-fsacm(i))
        END DO
        CALL PUSHINTEGER4(k - 1)
        DO k=kts+1,kcbl(i)
          mbarks(k, i) = mbar
          mdwn(k, i) = mbar*(pblsig(i)-sigmaf(k-1))*dsighi(k)
        END DO
        CALL PUSHINTEGER4(k - 1)
        mbarks(1, i) = mbar
        mbarks(kcbl(i), i) = mdwn(kcbl(i), i)
        mdwn(kcbl(i)+1, i) = 0.0D0
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
! end of I loop
    DO k=kts,klm
      DO i=its,ilx
        ekz = eddyz(i, k)/dtpbl*dsighi(k)
        IF (0.75D0/ekz .GT. dtlim(i)) THEN
          dtlim(i) = dtlim(i)
        ELSE
          dtlim(i) = 0.75D0/ekz
        END IF
      END DO
    END DO
    DO i=its,ilx
      IF (noconv(i) .EQ. 1) THEN
        rz = (sigmaf(kcbl(i))-sigmaf(1))*dsighi(1)
        IF (xx/(mbarks(1, i)*rz) .GT. dtlim(i)) THEN
          dtlim(i) = dtlim(i)
        ELSE
          dtlim(i) = xx/(mbarks(1, i)*rz)
        END IF
      END IF
    END DO
    DO k=kts,kl
      DO i=its,ilx
        vci(1, i, k) = theta(i, k)
        vci(2, i, k) = qvs(i, k)
        vci(3, i, k) = us(i, k)
        vci(4, i, k) = vs(i, k)
! -- Also mix cloud water and ice IF necessary
! IF (IMOISTX.NE.1.AND.IMOISTX.NE.3) THEN  !!! Check other PBL models
        vci(5, i, k) = qcs(i, k)
        vci(6, i, k) = qis(i, k)
#if (WRF_CHEM == 1)
        DO l=7,nspx
          vci(l, i, k) = chem(i, k, l-nsp)
        END DO
#endif
      END DO
    END DO
    DO i=its,ilx
      fs(1, i) = -(ust(i)*tst(i)*densx(i, 1)*pstari(i))
      fs(2, i) = -(ust(i)*qst(i)*densx(i, 1)*pstari(i))
      fm = -(ustm(i)*ustm(i)*densx(i, 1)*pstari(i))
      CALL PUSHREAL8(wspd)
      wspd = SQRT(us(i, 1)*us(i, 1) + vs(i, 1)*vs(i, 1)) + 1.d-9
      fs(3, i) = fm*us(i, 1)/wspd
      fs(4, i) = fm*vs(i, 1)/wspd
      fs(5, i) = 0.0D0
! SURFACE FLUXES OF CLOUD WATER AND ICE = 0
      fs(6, i) = 0.0D0
#if (WRF_CHEM == 1)
      DO l=7,nspx
        fs(l, i) = -(vd(i, 1, l-nsp)*chem(i, 1, l-nsp)*densx(i, 1)*&
&          pstari(i))
      END DO
#endif
    END DO
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    DO i=its,ilx
      nlp = INT(dtpbl/dtlim(i) + 1.0D0)
      CALL PUSHREAL8(dts)
      dts = dtpbl/nlp
      CALL PUSHREAL8(dtrat)
      dtrat = dts/dtpbl
! LOOP OVER SUB TIME LOOP              
      DO nl=1,nlp
!-- COMPUTE ARRAY ELEMENTS THAT ARE INDEPENDANT OF SPECIES
        DO k=kts,kte
          CALL PUSHREAL8(ai(k))
          ai(k) = 0.0D0
          CALL PUSHREAL8(bi(k))
          bi(k) = 0.0D0
          CALL PUSHREAL8(ci(k))
          ci(k) = 0.0D0
          CALL PUSHREAL8(ei(k))
          ei(k) = 0.0D0
        END DO
        DO k=2,kcbl(i)
          CALL PUSHREAL8(ei(k-1))
          ei(k-1) = -(crankp*mdwn(k, i)*dts*dsigh(k)*dsighi(k-1))
          CALL PUSHREAL8(bi(k))
          bi(k) = 1.0D0 + crankp*mdwn(k, i)*dts
          CALL PUSHREAL8(ai(k))
          ai(k) = -(crankp*mbarks(k, i)*dts)
        END DO
        CALL PUSHINTEGER4(k - 1)
        CALL PUSHREAL8(ei(1))
        ei(1) = ei(1) - eddyz(i, 1)*crankp*dsighi(1)*dtrat
        CALL PUSHREAL8(ai(2))
        ai(2) = ai(2) - eddyz(i, 1)*crankp*dsighi(2)*dtrat
        ad_from = kcbl(i) + 1
        DO k=ad_from,kl
          CALL PUSHREAL8(bi(k))
          bi(k) = 1.0D0
        END DO
        CALL PUSHINTEGER4(ad_from)
        DO k=2,kl
          CALL PUSHREAL8(xplus(k))
          xplus(k) = eddyz(i, k)*dsighi(k)*dtrat
          CALL PUSHREAL8(xminus(k))
          xminus(k) = eddyz(i, k-1)*dsighi(k)*dtrat
          CALL PUSHREAL8(ci(k))
          ci(k) = -(xminus(k)*crankp)
          CALL PUSHREAL8(ei(k))
          ei(k) = ei(k) - xplus(k)*crankp
          CALL PUSHREAL8(bi(k))
          bi(k) = bi(k) + xplus(k)*crankp + xminus(k)*crankp
        END DO
        IF (noconv(i) .EQ. 1) THEN
          CALL PUSHREAL8(bi(1))
          bi(1) = 1.0D0 + crankp*mbarks(1, i)*(pblsig(i)-sigmaf(1))*dts*&
&            dsighi(1) + eddyz(i, 1)*dsighi(1)*crankp*dtrat
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHREAL8(bi(1))
          bi(1) = 1.0D0 + eddyz(i, 1)*dsighi(1)*crankp*dtrat
          CALL PUSHCONTROL1B(0)
        END IF
        DO k=1,kl
          DO l=1,nspx
            CALL PUSHREAL8(di(l, k))
            di(l, k) = 0.0D0
          END DO
        END DO
!
!**   COMPUTE TENDENCY OF CBL CONCENTRATIONS - SEMI-IMPLICIT SOLUTION
        DO k=2,kcbl(i)
          DO l=1,nspx
            delc = dts*(mbarks(k, i)*vci(l, i, 1)-mdwn(k, i)*vci(l, i, k&
&              )+dsigh(k+1)*dsighi(k)*mdwn(k+1, i)*vci(l, i, k+1))
            CALL PUSHREAL8(di(l, k))
            di(l, k) = vci(l, i, k) + (1.0D0-crankp)*delc
          END DO
        END DO
        CALL PUSHINTEGER4(k - 1)
        ad_from0 = kcbl(i) + 1
        DO k=ad_from0,kl
          DO l=1,nspx
            CALL PUSHREAL8(di(l, k))
            di(l, k) = vci(l, i, k)
          END DO
        END DO
        CALL PUSHINTEGER4(ad_from0)
        DO k=2,kl
          IF (k .EQ. kl) THEN
            DO l=1,nspx
              CALL PUSHREAL8(di(l, k))
              di(l, k) = di(l, k) - (1.0D0-crankp)*xminus(k)*(vci(l, i, k)&
&                -vci(l, i, k-1))
            END DO
            CALL PUSHCONTROL1B(1)
          ELSE
            DO l=1,nspx
              CALL PUSHREAL8(di(l, k))
              di(l, k) = di(l, k) + (1.0D0-crankp)*xplus(k)*(vci(l, i, k+1&
&                )-vci(l, i, k)) - (1.0D0-crankp)*xminus(k)*(vci(l, i, k)-&
&                vci(l, i, k-1))
            END DO
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
        IF (noconv(i) .EQ. 1) THEN
          DO l=1,nspx
            f1 = -(g1000i*(mbarks(1, i)*(pblsig(i)-sigmaf(1))*vci(l, i, &
&              1)-mdwn(2, i)*vci(l, i, 2)*dsigh(2)))
            CALL PUSHREAL8(di(l, 1))
            di(l, 1) = vci(l, i, 1) - g1000*(fs(l, i)-(1.0D0-crankp)*f1)*&
&              dsighi(1)*dts
          END DO
          CALL PUSHCONTROL1B(1)
        ELSE
          DO l=1,nspx
            CALL PUSHREAL8(di(l, 1))
            di(l, 1) = vci(l, i, 1) - g1000*fs(l, i)*dsighi(1)*dts
          END DO
          CALL PUSHCONTROL1B(0)
        END IF
        DO l=1,nspx
          CALL PUSHREAL8(di(l, 1))
          di(l, 1) = di(l, 1) + (1.0D0-crankp)*eddyz(i, 1)*dsighi(1)*dtrat&
&            *(vci(l, i, 2)-vci(l, i, 1))
        END DO
        IF (noconv(i) .EQ. 1) THEN
          CALL PUSHREAL8ARRAY(ui, SIZE(ui, 1)*SIZE(ui, 2))
          CALL MATRIX(ai, bi, ci, di, ei, ui, kl, nspx)
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHREAL8ARRAY(ui, SIZE(ui, 1)*SIZE(ui, 2))
          CALL TRI(ci, bi, ei, di, ui, kl, nspx)
          CALL PUSHCONTROL1B(0)
        END IF
!
!-- COMPUTE NEW THETAV AND Q
        DO k=1,kl
          DO l=1,nspx
            CALL PUSHREAL8(vci(l, i, k))
            vci(l, i, k) = ui(l, k)
          END DO
        END DO
      END DO
      CALL PUSHINTEGER4(nl - 1)
    END DO
    DO k=kl,kts,-1
      DO i=ilx,its,-1
#if (WRF_CHEM == 1)
        DO ll=nspx,7,-1
          a_vci(ll, i, k) = a_vci(ll, i, k) + a_chem(i, k, ll-nsp)
          a_chem(i, k, ll-nsp) = 0.0_8
        END DO
#endif
        a_vci(6, i, k) = a_vci(6, i, k) + a_qix(i, k)
        a_qix(i, k) = 0.0_8
        a_vci(5, i, k) = a_vci(5, i, k) + a_qcx(i, k)
        a_qcx(i, k) = 0.0_8
        a_vci(4, i, k) = a_vci(4, i, k) + a_vx(i, k)
        a_vx(i, k) = 0.0_8
        a_vci(3, i, k) = a_vci(3, i, k) + a_ux(i, k)
        a_ux(i, k) = 0.0_8
        a_vci(2, i, k) = a_vci(2, i, k) + a_qvx(i, k)
        a_qvx(i, k) = 0.0_8
        a_vci(1, i, k) = a_vci(1, i, k) + a_thetax(i, k)
        a_thetax(i, k) = 0.0_8
      END DO
    END DO
    a_pblsig = 0.0_8
    a_eddyz = 0.0_8
    a_ai = 0.0_8
    a_mdwn = 0.0_8
    a_xminus = 0.0_8
    a_mbarks = 0.0_8
    a_ei = 0.0_8
    a_xplus = 0.0_8
    a_bi = 0.0_8
    a_ci = 0.0_8
    DO i=ilx,its,-1
      CALL POPINTEGER4(ad_to3)
      DO nl=ad_to3,1,-1
        DO k=kl,1,-1
          DO l=nspx,1,-1
            CALL POPREAL8(vci(l, i, k))
            a_ui(l, k) = a_ui(l, k) + a_vci(l, i, k)
            a_vci(l, i, k) = 0.0_8
          END DO
        END DO
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8ARRAY(ui, SIZE(ui, 1)*SIZE(ui, 2))
          CALL A_TRI(ci, a_ci, bi, a_bi, ei, a_ei, di, a_di, ui, a_ui, &
&               kl, nspx)
        ELSE
          CALL POPREAL8ARRAY(ui, SIZE(ui, 1)*SIZE(ui, 2))
          CALL A_MATRIX(ai, a_ai, bi, a_bi, ci, a_ci, di, a_di, ei, a_ei&
&                  , ui, a_ui, kl, nspx)
        END IF
        DO l=nspx,1,-1
          CALL POPREAL8(di(l, 1))
          temp2b18 = (1.0D0-crankp)*dtrat*dsighi(1)*a_di(l, 1)
          temp2b19 = eddyz(i, 1)*temp2b18
          a_eddyz(i, 1) = a_eddyz(i, 1) + (vci(l, i, 2)-vci(l, i, 1))*&
&            temp2b18
          a_vci(l, i, 2) = a_vci(l, i, 2) + temp2b19
          a_vci(l, i, 1) = a_vci(l, i, 1) - temp2b19
        END DO
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          DO l=nspx,1,-1
            CALL POPREAL8(di(l, 1))
            a_vci(l, i, 1) = a_vci(l, i, 1) + a_di(l, 1)
            a_fs(l, i) = a_fs(l, i) - dsighi(1)*g1000*dts*a_di(l, 1)
            a_di(l, 1) = 0.0_8
          END DO
        ELSE
          DO l=nspx,1,-1
            CALL POPREAL8(di(l, 1))
            temp2b15 = -(dsighi(1)*g1000*dts*a_di(l, 1))
            a_vci(l, i, 1) = a_vci(l, i, 1) + a_di(l, 1)
            a_fs(l, i) = a_fs(l, i) + temp2b15
            a_f1 = -((1.0D0-crankp)*temp2b15)
            a_di(l, 1) = 0.0_8
            temp2b16 = -(g1000i*a_f1)
            temp2b17 = vci(l, i, 1)*temp2b16
            a_mbarks(1, i) = a_mbarks(1, i) + (pblsig(i)-sigmaf(1))*&
&              temp2b17
            a_pblsig(i) = a_pblsig(i) + mbarks(1, i)*temp2b17
            a_vci(l, i, 1) = a_vci(l, i, 1) + mbarks(1, i)*(pblsig(i)-&
&              sigmaf(1))*temp2b16
            a_mdwn(2, i) = a_mdwn(2, i) - dsigh(2)*vci(l, i, 2)*&
&              temp2b16
            a_vci(l, i, 2) = a_vci(l, i, 2) - dsigh(2)*mdwn(2, i)*&
&              temp2b16
          END DO
        END IF
        DO k=kl,2,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            DO l=nspx,1,-1
              CALL POPREAL8(di(l, k))
              temp2b13 = (1.0D0-crankp)*xplus(k)*a_di(l, k)
              temp2b14 = -((1.0D0-crankp)*xminus(k)*a_di(l, k))
              a_xplus(k) = a_xplus(k) + (1.0D0-crankp)*(vci(l, i, k+1)-vci&
&                (l, i, k))*a_di(l, k)
              a_vci(l, i, k+1) = a_vci(l, i, k+1) + temp2b13
              a_vci(l, i, k) = a_vci(l, i, k) + temp2b14 - temp2b13
              a_xminus(k) = a_xminus(k) - (1.0D0-crankp)*(vci(l, i, k)-vci&
&                (l, i, k-1))*a_di(l, k)
              a_vci(l, i, k-1) = a_vci(l, i, k-1) - temp2b14
            END DO
          ELSE
            DO l=nspx,1,-1
              CALL POPREAL8(di(l, k))
              temp2b12 = -((1.0D0-crankp)*xminus(k)*a_di(l, k))
              a_xminus(k) = a_xminus(k) - (1.0D0-crankp)*(vci(l, i, k)-vci&
&                (l, i, k-1))*a_di(l, k)
              a_vci(l, i, k) = a_vci(l, i, k) + temp2b12
              a_vci(l, i, k-1) = a_vci(l, i, k-1) - temp2b12
            END DO
          END IF
        END DO
        CALL POPINTEGER4(ad_from0)
        DO k=kl,ad_from0,-1
          DO l=nspx,1,-1
            CALL POPREAL8(di(l, k))
            a_vci(l, i, k) = a_vci(l, i, k) + a_di(l, k)
            a_di(l, k) = 0.0_8
          END DO
        END DO
        CALL POPINTEGER4(ad_to2)
        DO k=ad_to2,2,-1
          DO l=nspx,1,-1
            CALL POPREAL8(di(l, k))
            a_vci(l, i, k) = a_vci(l, i, k) + a_di(l, k)
            a_delc = (1.0D0-crankp)*a_di(l, k)
            a_di(l, k) = 0.0_8
            temp2b10 = dts*a_delc
            temp2b11 = dsigh(k+1)*dsighi(k)*temp2b10
            a_mbarks(k, i) = a_mbarks(k, i) + vci(l, i, 1)*temp2b10
            a_vci(l, i, 1) = a_vci(l, i, 1) + mbarks(k, i)*temp2b10
            a_mdwn(k, i) = a_mdwn(k, i) - vci(l, i, k)*temp2b10
            a_vci(l, i, k) = a_vci(l, i, k) - mdwn(k, i)*temp2b10
            a_mdwn(k+1, i) = a_mdwn(k+1, i) + vci(l, i, k+1)*temp2b11
            a_vci(l, i, k+1) = a_vci(l, i, k+1) + mdwn(k+1, i)*temp2b11
          END DO
        END DO
        DO k=kl,1,-1
          DO l=nspx,1,-1
            CALL POPREAL8(di(l, k))
            a_di(l, k) = 0.0_8
          END DO
        END DO
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(bi(1))
          a_eddyz(i, 1) = a_eddyz(i, 1) + crankp*dtrat*dsighi(1)*a_bi(1)
          a_bi(1) = 0.0_8
        ELSE
          CALL POPREAL8(bi(1))
          temp2b9 = crankp*dts*dsighi(1)*a_bi(1)
          a_mbarks(1, i) = a_mbarks(1, i) + (pblsig(i)-sigmaf(1))*&
&            temp2b9
          a_pblsig(i) = a_pblsig(i) + mbarks(1, i)*temp2b9
          a_eddyz(i, 1) = a_eddyz(i, 1) + crankp*dtrat*dsighi(1)*a_bi(1)
          a_bi(1) = 0.0_8
        END IF
        DO k=kl,2,-1
          CALL POPREAL8(bi(k))
          a_xplus(k) = a_xplus(k) + crankp*a_bi(k) - crankp*a_ei(k)
          a_xminus(k) = a_xminus(k) + crankp*a_bi(k) - crankp*a_ci(k)
          CALL POPREAL8(ei(k))
          CALL POPREAL8(ci(k))
          a_ci(k) = 0.0_8
          CALL POPREAL8(xminus(k))
          a_eddyz(i, k-1) = a_eddyz(i, k-1) + dsighi(k)*dtrat*a_xminus(k&
&            )
          a_xminus(k) = 0.0_8
          CALL POPREAL8(xplus(k))
          a_eddyz(i, k) = a_eddyz(i, k) + dsighi(k)*dtrat*a_xplus(k)
          a_xplus(k) = 0.0_8
        END DO
        CALL POPINTEGER4(ad_from)
        DO k=kl,ad_from,-1
          CALL POPREAL8(bi(k))
          a_bi(k) = 0.0_8
        END DO
        CALL POPREAL8(ai(2))
        a_eddyz(i, 1) = a_eddyz(i, 1) - crankp*dtrat*dsighi(1)*a_ei(1) -&
&          crankp*dtrat*dsighi(2)*a_ai(2)
        CALL POPREAL8(ei(1))
        CALL POPINTEGER4(ad_to1)
        DO k=ad_to1,2,-1
          CALL POPREAL8(ai(k))
          a_mbarks(k, i) = a_mbarks(k, i) - crankp*dts*a_ai(k)
          a_ai(k) = 0.0_8
          CALL POPREAL8(bi(k))
          a_mdwn(k, i) = a_mdwn(k, i) + crankp*dts*a_bi(k) - dsigh(k)*&
&            dsighi(k-1)*crankp*dts*a_ei(k-1)
          a_bi(k) = 0.0_8
          CALL POPREAL8(ei(k-1))
          a_ei(k-1) = 0.0_8
        END DO
        DO k=kte,kts,-1
          CALL POPREAL8(ei(k))
          a_ei(k) = 0.0_8
          CALL POPREAL8(ci(k))
          a_ci(k) = 0.0_8
          CALL POPREAL8(bi(k))
          a_bi(k) = 0.0_8
          CALL POPREAL8(ai(k))
          a_ai(k) = 0.0_8
        END DO
      END DO
      CALL POPREAL8(dtrat)
      CALL POPREAL8(dts)
    END DO
    a_tst = 0.0_8
    a_ustm = 0.0_8
    a_qst = 0.0_8
    a_pstari = 0.0_8
    DO i=ilx,its,-1
#if (WRF_CHEM == 1)
      DO l=nspx,7,-1
        temp2b7 = -(densx(i, 1)*pstari(i)*a_fs(l, i))
        temp2b8 = -(vd(i, 1, l-nsp)*chem(i, 1, l-nsp)*a_fs(l, i))
        a_vd(i, 1, l-nsp) = a_vd(i, 1, l-nsp) + chem(i, 1, l-nsp)*&
&          temp2b7
        a_chem(i, 1, l-nsp) = a_chem(i, 1, l-nsp) + vd(i, 1, l-nsp)*&
&          temp2b7
        a_densx(i, 1) = a_densx(i, 1) + pstari(i)*temp2b8
        a_pstari(i) = a_pstari(i) + densx(i, 1)*temp2b8
        a_fs(l, i) = 0.0_8
      END DO
#endif
      a_fs(6, i) = 0.0_8
      a_fs(5, i) = 0.0_8
      fm = -(ustm(i)*ustm(i)*densx(i, 1)*pstari(i))
      temp2b = vs(i, 1)*a_fs(4, i)/wspd
      a_vs(i, 1) = a_vs(i, 1) + fm*a_fs(4, i)/wspd
      a_fs(4, i) = 0.0_8
      temp2b0 = us(i, 1)*a_fs(3, i)/wspd
      a_fm = temp2b0 + temp2b
      a_wspd = -(fm*temp2b0/wspd) - fm*temp2b/wspd
      IF (us(i, 1)**2 + vs(i, 1)**2 .EQ. 0.0_8) THEN
        temp2b1 = 0.0
      ELSE
        temp2b1 = a_wspd/(2.0D0*SQRT(us(i, 1)**2+vs(i, 1)**2))
      END IF
      a_us(i, 1) = a_us(i, 1) + 2.D0*us(i, 1)*temp2b1 + fm*a_fs(3, i)/&
&        wspd
      a_fs(3, i) = 0.0_8
      CALL POPREAL8(wspd)
      a_vs(i, 1) = a_vs(i, 1) + 2.D0*vs(i, 1)*temp2b1
      temp2b2 = -(ustm(i)**2*a_fm)
      a_ustm(i) = a_ustm(i) - densx(i, 1)*pstari(i)*2.D0*ustm(i)*a_fm
      temp2b5 = -(densx(i, 1)*pstari(i)*a_fs(2, i))
      temp2b3 = -(ust(i)*qst(i)*a_fs(2, i))
      a_qst(i) = a_qst(i) + ust(i)*temp2b5
      a_fs(2, i) = 0.0_8
      temp2b6 = -(densx(i, 1)*pstari(i)*a_fs(1, i))
      a_ust(i) = a_ust(i) + tst(i)*temp2b6 + qst(i)*temp2b5
      temp2b4 = -(ust(i)*tst(i)*a_fs(1, i))
      a_densx(i, 1) = a_densx(i, 1) + pstari(i)*temp2b3 + pstari(i)*&
&        temp2b4 + pstari(i)*temp2b2
      a_pstari(i) = a_pstari(i) + densx(i, 1)*temp2b3 + densx(i, 1)*&
&        temp2b4 + densx(i, 1)*temp2b2
      a_tst(i) = a_tst(i) + ust(i)*temp2b6
      a_fs(1, i) = 0.0_8
    END DO
    DO k=kl,kts,-1
      DO i=ilx,its,-1
#if (WRF_CHEM == 1)
        DO l=nspx,7,-1
          a_chem(i, k, l-nsp) = a_chem(i, k, l-nsp) + a_vci(l, i, k)
          a_vci(l, i, k) = 0.0_8
        END DO
#endif
        a_qis(i, k) = a_qis(i, k) + a_vci(6, i, k)
        a_vci(6, i, k) = 0.0_8
        a_qcs(i, k) = a_qcs(i, k) + a_vci(5, i, k)
        a_vci(5, i, k) = 0.0_8
        a_vs(i, k) = a_vs(i, k) + a_vci(4, i, k)
        a_vci(4, i, k) = 0.0_8
        a_us(i, k) = a_us(i, k) + a_vci(3, i, k)
        a_vci(3, i, k) = 0.0_8
        a_qvs(i, k) = a_qvs(i, k) + a_vci(2, i, k)
        a_vci(2, i, k) = 0.0_8
        a_theta(i, k) = a_theta(i, k) + a_vci(1, i, k)
        a_vci(1, i, k) = 0.0_8
      END DO
    END DO
    a_pstar = 0.0_8
    a_mol = 0.0_8
    a_fsacm = 0.0_8
    DO i=ilx,its,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        a_mdwn(kcbl(i)+1, i) = 0.0_8
        a_mdwn(kcbl(i), i) = a_mdwn(kcbl(i), i) + a_mbarks(kcbl(i), i)
        a_mbarks(kcbl(i), i) = 0.0_8
        mbar = meddy*fsacm(i)
        a_mbar = a_mbarks(1, i)
        a_mbarks(1, i) = 0.0_8
        CALL POPINTEGER4(ad_to0)
        DO k=ad_to0,kts+1,-1
          a_mbar = a_mbar + a_mbarks(k, i) + dsighi(k)*(pblsig(i)-sigmaf&
&            (k-1))*a_mdwn(k, i)
          a_pblsig(i) = a_pblsig(i) + dsighi(k)*mbar*a_mdwn(k, i)
          a_mdwn(k, i) = 0.0_8
          a_mbarks(k, i) = 0.0_8
        END DO
        CALL POPINTEGER4(ad_to)
        DO k=ad_to,kts,-1
          CALL POPREAL8(eddyz(i, k))
          a_fsacm(i) = a_fsacm(i) - eddyz(i, k)*a_eddyz(i, k)
          a_eddyz(i, k) = (1.0D0-fsacm(i))*a_eddyz(i, k)
        END DO
        a_meddy = fsacm(i)*a_mbar
        a_fsacm(i) = a_fsacm(i) + meddy*a_mbar
        CALL POPREAL8(meddy)
        temp1 = dtpbl*(pblsig(i)-sigmaf(1))
        a_eddyz(i, 1) = a_eddyz(i, 1) + a_meddy/temp1
        a_pblsig(i) = a_pblsig(i) - eddyz(i, 1)*dtpbl*a_meddy/temp1**2
        hovl = -(pbl(i)/mol(i))
        temp0 = karman/hovl
        temp = temp0**0.3333D0/(0.72D0*karman) + 1.D0
        a_hovl = 0.3333D0*temp0**(-0.6667D0)*temp0*a_fsacm(i)/(hovl*0.72D0*&
&          karman*temp**2)
        a_fsacm(i) = 0.0_8
        tempb = -(a_hovl/mol(i))
        a_pbl(i) = a_pbl(i) + tempb
        a_mol(i) = a_mol(i) - pbl(i)*tempb/mol(i)
      END IF
      a_fsacm(i) = 0.0_8
      a_pstar(i) = a_pstar(i) - a_pstari(i)/pstar(i)**2
      a_pstari(i) = 0.0_8
    END DO
    DEALLOCATE(vci)
    DEALLOCATE(a_vci)
    DEALLOCATE(bcbotn)
    DEALLOCATE(fs)
    DEALLOCATE(a_fs)
    DEALLOCATE(ui)
    DEALLOCATE(a_ui)
    DEALLOCATE(di)
    DEALLOCATE(a_di)
  END SUBROUTINE A_ACM

!  Differentiation of matrix in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: d e x a b c
!   with respect to varying inputs: d e x a b c
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
  SUBROUTINE A_MATRIX(a, a_a, b, a_b, c, a_c, d, a_d, e, a_e, x, a_x, kl&
&    , nsp)
    IMPLICIT NONE
!
!-- Bordered band diagonal matrix solver for ACM2
!-- ACM2 Matrix is in this form:
!   B1 E1
!   A2 B2 E2
!   A3 C3 B3 E3
!   A4    C4 B4 E4
!   A5       C5 B5 E5
!   A6          C6 B6
!--Upper Matrix is
!  U11 U12
!      U22 U23
!          U33 U34
!              U44 U45
!                  U55 U56
!                      U66
!--Lower Matrix is:
!  1
! L21  1
! L31 L32  1
! L41 L42 L43  1
! L51 L52 L53 L54  1
! L61 L62 L63 L64 L65 1
!---------------------------------------------------------
!...Arguments
    INTEGER, INTENT(IN) :: kl
    INTEGER, INTENT(IN) :: nsp
    REAL :: a(kl), b(kl), e(kl)
    REAL :: a_a(kl), a_b(kl), a_e(kl)
    REAL :: c(kl), d(nsp, kl), x(nsp, kl)
    REAL :: a_c(kl), a_d(nsp, kl), a_x(nsp, kl)
!...Locals
    REAL :: y(nsp, kl), aij, sum
    REAL :: a_y(nsp, kl), a_aij, a_sum
    REAL :: l(kl, kl), uii(kl), uiip1(kl), ruii(kl)
    REAL :: a_l(kl, kl), a_uii(kl), a_uiip1(kl), a_ruii(kl)
    INTEGER :: i, j, v
    INTEGER :: branch
    INTEGER :: ad_to
    INTEGER :: ad_to0
    REAL :: temp0b
    REAL :: tempb1
    REAL :: tempb0
    REAL :: tempb
    REAL :: temp
!-- Define Upper and Lower matrices
    l(1, 1) = 1.D0
    uii(1) = b(1)
    ruii(1) = 1./uii(1)
    DO i=2,kl
      CALL PUSHREAL8(l(i, i))
      l(i, i) = 1.D0
      CALL PUSHREAL8(l(i, 1))
      l(i, 1) = a(i)/b(1)
      uiip1(i-1) = e(i-1)
      IF (i .GE. 3) THEN
        DO j=2,i-1
          IF (i .EQ. j + 1) THEN
            CALL PUSHREAL8(aij)
            aij = c(i)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHREAL8(aij)
            aij = 0.D0
            CALL PUSHCONTROL1B(1)
          END IF
          CALL PUSHREAL8(l(i, j))
          l(i, j) = (aij-l(i, j-1)*e(j-1))/(b(j)-l(j, j-1)*e(j-1))
        END DO
        CALL PUSHINTEGER4(j - 1)
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    DO i=2,kl
      CALL PUSHREAL8(uii(i))
      uii(i) = b(i) - l(i, i-1)*e(i-1)
      ruii(i) = 1.D0/uii(i)
    END DO
!-- Forward sub for Ly=d
    DO v=1,nsp
      y(v, 1) = d(v, 1)
      DO i=2,kl
        sum = d(v, i)
        DO j=1,i-1
          sum = sum - l(i, j)*y(v, j)
        END DO
        CALL PUSHINTEGER4(j - 1)
        CALL PUSHREAL8(y(v, i))
        y(v, i) = sum
      END DO
    END DO
!-- Back sub for Ux=y
    DO v=1,nsp
      x(v, kl) = y(v, kl)*ruii(kl)
    END DO
    DO i=kl-1,1,-1
      DO v=1,nsp
        CALL PUSHREAL8(x(v, i))
        x(v, i) = (y(v, i)-uiip1(i)*x(v, i+1))*ruii(i)
      END DO
    END DO
    a_y = 0.0_8
    a_uiip1 = 0.0_8
    a_ruii = 0.0_8
    DO i=1,kl-1,1
      DO v=nsp,1,-1
        CALL POPREAL8(x(v, i))
        temp0b = ruii(i)*a_x(v, i)
        a_y(v, i) = a_y(v, i) + temp0b
        a_uiip1(i) = a_uiip1(i) - x(v, i+1)*temp0b
        a_x(v, i+1) = a_x(v, i+1) - uiip1(i)*temp0b
        a_ruii(i) = a_ruii(i) + (y(v, i)-uiip1(i)*x(v, i+1))*a_x(v, i)
        a_x(v, i) = 0.0_8
      END DO
    END DO
    DO v=nsp,1,-1
      a_y(v, kl) = a_y(v, kl) + ruii(kl)*a_x(v, kl)
      a_ruii(kl) = a_ruii(kl) + y(v, kl)*a_x(v, kl)
      a_x(v, kl) = 0.0_8
    END DO
    a_l = 0.0_8
    DO v=nsp,1,-1
      DO i=kl,2,-1
        CALL POPREAL8(y(v, i))
        a_sum = a_y(v, i)
        a_y(v, i) = 0.0_8
        CALL POPINTEGER4(ad_to0)
        DO j=ad_to0,1,-1
          a_l(i, j) = a_l(i, j) - y(v, j)*a_sum
          a_y(v, j) = a_y(v, j) - l(i, j)*a_sum
        END DO
        a_d(v, i) = a_d(v, i) + a_sum
      END DO
      a_d(v, 1) = a_d(v, 1) + a_y(v, 1)
      a_y(v, 1) = 0.0_8
    END DO
    a_uii = 0.0_8
    DO i=kl,2,-1
      a_uii(i) = a_uii(i) - a_ruii(i)/uii(i)**2
      a_ruii(i) = 0.0_8
      CALL POPREAL8(uii(i))
      a_b(i) = a_b(i) + a_uii(i)
      a_l(i, i-1) = a_l(i, i-1) - e(i-1)*a_uii(i)
      a_e(i-1) = a_e(i-1) - l(i, i-1)*a_uii(i)
      a_uii(i) = 0.0_8
    END DO
    DO i=kl,2,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        CALL POPINTEGER4(ad_to)
        DO j=ad_to,2,-1
          CALL POPREAL8(l(i, j))
          temp = b(j) - l(j, j-1)*e(j-1)
          tempb0 = a_l(i, j)/temp
          tempb1 = -((aij-l(i, j-1)*e(j-1))*tempb0/temp)
          a_aij = tempb0
          a_l(i, j-1) = a_l(i, j-1) - e(j-1)*tempb0
          a_e(j-1) = a_e(j-1) - l(j, j-1)*tempb1 - l(i, j-1)*tempb0
          a_b(j) = a_b(j) + tempb1
          a_l(j, j-1) = a_l(j, j-1) - e(j-1)*tempb1
          a_l(i, j) = 0.0_8
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL8(aij)
            a_c(i) = a_c(i) + a_aij
          ELSE
            CALL POPREAL8(aij)
          END IF
        END DO
      END IF
      a_e(i-1) = a_e(i-1) + a_uiip1(i-1)
      a_uiip1(i-1) = 0.0_8
      CALL POPREAL8(l(i, 1))
      tempb = a_l(i, 1)/b(1)
      a_a(i) = a_a(i) + tempb
      a_b(1) = a_b(1) - a(i)*tempb/b(1)
      a_l(i, 1) = 0.0_8
      CALL POPREAL8(l(i, i))
      a_l(i, i) = 0.0_8
    END DO
    a_uii(1) = a_uii(1) - a_ruii(1)/uii(1)**2
    a_b(1) = a_b(1) + a_uii(1)
  END SUBROUTINE A_MATRIX

!  Differentiation of tri in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: d l u x b
!   with respect to varying inputs: d l u x b
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
  SUBROUTINE A_TRI(l, a_l, d, a_d, u, a_u, b, a_b, x, a_x, kl, nsp)
    IMPLICIT NONE
! Arguments:
    INTEGER, INTENT(IN) :: kl
    INTEGER, INTENT(IN) :: nsp
! subdiagonal
    REAL :: l(kl)
    REAL :: a_l(kl)
! diagonal
    REAL :: d(kl)
    REAL :: a_d(kl)
! superdiagonal
    REAL :: u(kl)
    REAL :: a_u(kl)
! R.H. side
    REAL :: b(nsp, kl)
    REAL :: a_b(nsp, kl)
! solution
    REAL :: x(nsp, kl)
    REAL :: a_x(nsp, kl)
! Local Variables:
    REAL :: gam(kl)
    REAL :: a_gam(kl)
    REAL :: bet
    REAL :: a_bet
    INTEGER :: v, k
    REAL :: temp0b
    REAL :: tempb
    REAL :: temp
! Decomposition and forward substitution:
    bet = 1.0D0/d(1)
    DO v=1,nsp
      x(v, 1) = bet*b(v, 1)
    END DO
    DO k=2,kl
      gam(k) = bet*u(k-1)
      CALL PUSHREAL8(bet)
      bet = 1.0D0/(d(k)-l(k)*gam(k))
      DO v=1,nsp
        CALL PUSHREAL8(x(v, k))
        x(v, k) = bet*(b(v, k)-l(k)*x(v, k-1))
      END DO
    END DO
! Back-substitution:
    DO k=kl-1,1,-1
      DO v=1,nsp
        CALL PUSHREAL8(x(v, k))
        x(v, k) = x(v, k) - gam(k+1)*x(v, k+1)
      END DO
    END DO
    a_gam = 0.0_8
    DO k=1,kl-1,1
      DO v=nsp,1,-1
        CALL POPREAL8(x(v, k))
        a_gam(k+1) = a_gam(k+1) - x(v, k+1)*a_x(v, k)
        a_x(v, k+1) = a_x(v, k+1) - gam(k+1)*a_x(v, k)
      END DO
    END DO
    a_bet = 0.0_8
    DO k=kl,2,-1
      DO v=nsp,1,-1
        CALL POPREAL8(x(v, k))
        temp0b = bet*a_x(v, k)
        a_bet = a_bet + (b(v, k)-l(k)*x(v, k-1))*a_x(v, k)
        a_b(v, k) = a_b(v, k) + temp0b
        a_l(k) = a_l(k) - x(v, k-1)*temp0b
        a_x(v, k-1) = a_x(v, k-1) - l(k)*temp0b
        a_x(v, k) = 0.0_8
      END DO
      CALL POPREAL8(bet)
      temp = d(k) - l(k)*gam(k)
      tempb = -(a_bet/temp**2)
      a_d(k) = a_d(k) + tempb
      a_l(k) = a_l(k) - gam(k)*tempb
      a_gam(k) = a_gam(k) - l(k)*tempb
      a_bet = u(k-1)*a_gam(k)
      a_u(k-1) = a_u(k-1) + bet*a_gam(k)
      a_gam(k) = 0.0_8
    END DO
    DO v=nsp,1,-1
      a_bet = a_bet + b(v, 1)*a_x(v, 1)
      a_b(v, 1) = a_b(v, 1) + bet*a_x(v, 1)
      a_x(v, 1) = 0.0_8
    END DO
    a_d(1) = a_d(1) - a_bet/d(1)**2
  END SUBROUTINE A_TRI

!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!  Differentiation of acminit in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: rublten rqvblten rvblten rqcblten
!                rthblten rqiblten
!   with respect to varying inputs: rublten rqvblten rvblten rqcblten
!                rthblten rqiblten
!   RW status of diff variables: rublten:in-out rqvblten:in-out
!                rvblten:in-out rqcblten:in-out rthblten:in-out
!                rqiblten:in-out
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
  SUBROUTINE A_ACMINIT(rublten, a_rublten, rvblten, a_rvblten, rthblten&
&    , a_rthblten, rqvblten, a_rqvblten, rqcblten, a_rqcblten, rqiblten, &
&    a_rqiblten, p_qi, p_first_scalar, restart, allowed_to_read, ids, ide&
&    , jds, jde, kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, &
&    jte, kts, kte)
    IMPLICIT NONE
!
    LOGICAL, INTENT(IN) :: restart, allowed_to_read
    INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, its, ite, jts, jte, kts, kte
    INTEGER, INTENT(IN) :: p_qi, p_first_scalar
!   REAL , DIMENSION( kms:kme ), INTENT(IN)  :: SHALF
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: rublten, rvblten, &
&    rthblten, rqvblten, rqcblten, rqiblten
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_rublten, a_rvblten, &
&    a_rthblten, a_rqvblten, a_rqcblten, a_rqiblten
!... Local Variables
    INTEGER :: i, j, k, itf, jtf, ktf
    INTEGER :: branch
    IF (jte .GT. jde - 1) THEN
      jtf = jde - 1
    ELSE
      jtf = jte
    END IF
    IF (kte .GT. kde - 1) THEN
      ktf = kde - 1
    ELSE
      ktf = kte
    END IF
    IF (ite .GT. ide - 1) THEN
      itf = ide - 1
    ELSE
      itf = ite
    END IF
    IF (.NOT.restart) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (p_qi .GE. p_first_scalar .AND. (.NOT.restart)) THEN
      DO j=jtf,jts,-1
        DO k=ktf,kts,-1
          DO i=itf,its,-1
            a_rqiblten(i, k, j) = 0.0_8
          END DO
        END DO
      END DO
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      DO j=jtf,jts,-1
        DO k=ktf,kts,-1
          DO i=itf,its,-1
            a_rqcblten(i, k, j) = 0.0_8
            a_rqvblten(i, k, j) = 0.0_8
            a_rthblten(i, k, j) = 0.0_8
            a_rvblten(i, k, j) = 0.0_8
            a_rublten(i, k, j) = 0.0_8
          END DO
        END DO
      END DO
    END IF
  END SUBROUTINE A_ACMINIT
END MODULE A_MODULE_BL_ACM
