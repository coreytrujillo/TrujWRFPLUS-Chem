!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.6 (r4756) - 12 Feb 2013 10:43
!
!WRF:MODEL_LAYER:PHYSICS
!
MODULE A_MODULE_SF_SLAB
  IMPLICIT NONE
!-------------------------------------------------------------------          
!---SPECIFY CONSTANTS AND LAYERS FOR SOIL MODEL
!---SOIL DIFFUSION CONSTANT SET (M^2/S)
  REAL, PARAMETER :: difsl=5.e-7
!---FACTOR TO MAKE SOIL STEP MORE CONSERVATIVE
  REAL, PARAMETER :: soilfac=1.25

CONTAINS
!  Differentiation of slab in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: capg p3d tslb hfx tsk t3d qv3d
!                psfc flqc qfx flhc
!   with respect to varying inputs: capg p3d tslb hfx tsk t3d qv3d
!                psfc flqc qfx flhc
!----------------------------------------------------------------
  SUBROUTINE A_SLAB(t3d, a_t3d, qv3d, a_qv3d, p3d, a_p3d, flhc, a_flhc, &
&    flqc, a_flqc, psfc, a_psfc, xland, tmn, hfx, a_hfx, qfx, a_qfx, lh, &
&    tsk, a_tsk, qsfc, chklowq, gsw, glw, capg, a_capg, thc, snowc, emiss&
&    , mavail, deltsm, rovcp, xlv, dtmin, ifsnow, svp1, svp2, svp3, svpt0&
&    , ep2, karman, eomeg, stbolt, tslb, a_tslb, zs, dzs, num_soil_layers&
&    , radiation, p1000mb, ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, its, ite, jts, jte, kts, kte)
    IMPLICIT NONE
!----------------------------------------------------------------
!                                                                        
!     SUBROUTINE SLAB CALCULATES THE GROUND TEMPERATURE TENDENCY 
!     ACCORDING TO THE RESIDUAL OF THE SURFACE ENERGY BUDGET           
!     (BLACKADAR, 1978B).                                              
!                                                                      
!     CHANGES:                                                         
!          FOR SOIL SUB-TIMESTEPS UPDATE SURFACE HFX AND QFX AS TG     
!          CHANGES TO PREVENT POSSIBLE INSTABILITY FOR LONG MODEL      
!          STEPS (DT > ~200 SEC).                                      
!                                                                      
!          PUT SNOW COVER CHECK ON SOIL SUB-TIMESTEPS                  
!                                                                      
!          MAKE UPPER LIMIT ON SOIL SUB-STEP LENGTH MORE CONSERVATIVE  
!                                                                      
!----------------------------------------------------------------          
!-- T3D         temperature (K)
!-- QV3D        3D water vapor mixing ratio (Kg/Kg)
!-- P3D         3D pressure (Pa)
!-- FLHC        exchange coefficient for heat (m/s)
!-- FLQC        exchange coefficient for moisture (m/s)
!-- PSFC        surface pressure (Pa)
!-- XLAND       land mask (1 for land, 2 for water)
!-- TMN         soil temperature at lower boundary (K)
!-- HFX         upward heat flux at the surface (W/m^2)
!-- QFX         upward moisture flux at the surface (kg/m^2/s)
!-- LH          latent heat flux at the surface (W/m^2)
!-- TSK         surface temperature (K)
!-- GSW         downward short wave flux at ground surface (W/m^2)      
!-- GLW         downward long wave flux at ground surface (W/m^2)
!-- CAPG        heat capacity for soil (J/K/m^3)
!-- THC         thermal inertia (Cal/cm/K/s^0.5)
!-- SNOWC       flag indicating snow coverage (1 for snow cover)
!-- EMISS       surface emissivity (between 0 and 1)
!-- DELTSM      time step (second)
!-- ROVCP       R/CP
!-- XLV         latent heat of melting (J/kg)
!-- DTMIN       time step (minute)
!-- IFSNOW      ifsnow=1 for snow-cover effects
!-- SVP1        constant for saturation vapor pressure (kPa)
!-- SVP2        constant for saturation vapor pressure (dimensionless)
!-- SVP3        constant for saturation vapor pressure (K)
!-- SVPT0       constant for saturation vapor pressure (K)
!-- EP1         constant for virtual temperature (R_v/R_d - 1) (dimensionless)
!-- EP2         constant for specific humidity calculation 
!               (R_d/R_v) (dimensionless)
!-- KARMAN      Von Karman constant
!-- EOMEG       angular velocity of earth's rotation (rad/s)
!-- STBOLT      Stefan-Boltzmann constant (W/m^2/K^4)
!-- TSLB        soil temperature in 5-layer model
!-- ZS          depths of centers of soil layers
!-- DZS         thicknesses of soil layers
!-- num_soil_layers   the number of soil layers
!-- ids         start index for i in domain
!-- ide         end index for i in domain
!-- jds         start index for j in domain
!-- jde         end index for j in domain
!-- kds         start index for k in domain
!-- kde         end index for k in domain
!-- ims         start index for i in memory
!-- ime         end index for i in memory
!-- jms         start index for j in memory
!-- jme         end index for j in memory
!-- kms         start index for k in memory
!-- kme         end index for k in memory
!-- its         start index for i in tile
!-- ite         end index for i in tile
!-- jts         start index for j in tile
!-- jte         end index for j in tile
!-- kts         start index for k in tile
!-- kte         end index for k in tile
!----------------------------------------------------------------
    INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, its, ite, jts, jte, kts, kte
    INTEGER, INTENT(IN) :: num_soil_layers
    LOGICAL, INTENT(IN) :: radiation
    INTEGER, INTENT(IN) :: ifsnow
!
    REAL, INTENT(IN) :: dtmin, xlv, rovcp, deltsm
    REAL, INTENT(IN) :: svp1, svp2, svp3, svpt0
    REAL, INTENT(IN) :: ep2, karman, eomeg, stbolt
    REAL, INTENT(IN) :: p1000mb
    REAL, DIMENSION(ims:ime, num_soil_layers, jms:jme), INTENT(INOUT) ::&
&    tslb
    REAL, DIMENSION(ims:ime, num_soil_layers, jms:jme), INTENT(INOUT) ::&
&    a_tslb
    REAL, DIMENSION(num_soil_layers), INTENT(IN) :: zs, dzs
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: qv3d, p3d&
&    , t3d
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_qv3d, a_p3d, a_t3d
!
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: snowc, xland, emiss&
&    , mavail, tmn, gsw, glw, thc
!CHKLOWQ is declared as memory size
!
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: hfx, qfx, lh, &
&    capg, tsk, qsfc, chklowq
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_hfx
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: psfc
    REAL, DIMENSION(ims:ime, jms:jme) :: a_psfc
!
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: flhc, flqc
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_flhc
! LOCAL VARS
    REAL, DIMENSION(its:ite) :: qv1d, p1d, t1d
    REAL, DIMENSION(its:ite) :: a_qv1d, a_p1d, a_t1d
    INTEGER :: i, j
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_flqc
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_tsk
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_capg
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_qfx
    a_qv1d = 0.0_8
    a_p1d = 0.0_8
    a_t1d = 0.0_8
    DO j=jte,jts,-1
      DO i=its,ite
        t1d(i) = t3d(i, 1, j)
        qv1d(i) = qv3d(i, 1, j)
        p1d(i) = p3d(i, 1, j)
      END DO
      CALL A_SLAB1D(j, t1d, a_t1d, qv1d, a_qv1d, p1d, a_p1d, flhc(ims, j)&
&              , a_flhc(ims, j), flqc(ims, j), a_flqc(ims, j), psfc(its, j)&
&              , a_psfc(its, j), xland(ims, j), tmn(ims, j), hfx(ims, j), &
&              a_hfx(ims, j), qfx(ims, j), a_qfx(ims, j), tsk(ims, j), a_tsk(ims, j&
&              ), qsfc(ims, j), chklowq(ims, j), lh(ims, j), gsw(ims, j), glw(ims, &
&              j), capg(ims, j), a_capg(ims, j), thc(ims, j), snowc(ims, j), &
&              emiss(ims, j), mavail(ims, j), deltsm, rovcp, xlv, dtmin, &
&              ifsnow, svp1, svp2, svp3, svpt0, ep2, karman, eomeg, &
&              stbolt, tslb(ims, 1, j), a_tslb(ims, 1, j), zs, dzs, &
&              num_soil_layers, radiation, p1000mb, ids, ide, jds, jde, &
&              kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte&
&              , kts, kte)
      DO i=ite,its,-1
        a_p3d(i, 1, j) = a_p3d(i, 1, j) + a_p1d(i)
        a_p1d(i) = 0.0_8
        a_qv3d(i, 1, j) = a_qv3d(i, 1, j) + a_qv1d(i)
        a_qv1d(i) = 0.0_8
        a_t3d(i, 1, j) = a_t3d(i, 1, j) + a_t1d(i)
        a_t1d(i) = 0.0_8
      END DO
    END DO
  END SUBROUTINE A_SLAB
!----------------------------------------------------------------

!  Differentiation of slab1d in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: qv1d capg psfcpa hfx tsk p1d
!                flqc qfx tslb2d flhc t1d
!   with respect to varying inputs: qv1d capg psfcpa hfx tsk p1d
!                flqc qfx tslb2d flhc t1d
!----------------------------------------------------------------
  SUBROUTINE A_SLAB1D(j, t1d, a_t1d, qv1d, a_qv1d, p1d, a_p1d, flhc, &
&    a_flhc, flqc, a_flqc, psfcpa, a_psfcpa, xland, tmn, hfx, a_hfx, qfx&
&    , a_qfx, tsk, a_tsk, qsfc, chklowq, lh, gsw, glw, capg, a_capg, thc&
&    , snowc, emiss, mavail, deltsm, rovcp, xlv, dtmin, ifsnow, svp1, &
&    svp2, svp3, svpt0, ep2, karman, eomeg, stbolt, tslb2d, a_tslb2d, zs&
&    , dzs, num_soil_layers, radiation, p1000mb, ids, ide, jds, jde, kds&
&    , kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte)
    IMPLICIT NONE
!                                                                                
!----------------------------------------------------------------
!                                                                        
!     SUBROUTINE SLAB CALCULATES THE GROUND TEMPERATURE TENDENCY 
!     ACCORDING TO THE RESIDUAL OF THE SURFACE ENERGY BUDGET           
!     (BLACKADAR, 1978B).                                              
!                                                                      
!     CHANGES:                                                         
!          FOR SOIL SUB-TIMESTEPS UPDATE SURFACE HFX AND QFX AS TG     
!          CHANGES TO PREVENT POSSIBLE INSTABILITY FOR LONG MODEL      
!          STEPS (DT > ~200 SEC).                                      
!                                                                      
!          PUT SNOW COVER CHECK ON SOIL SUB-TIMESTEPS                  
!                                                                      
!          MAKE UPPER LIMIT ON SOIL SUB-STEP LENGTH MORE CONSERVATIVE  
!                                                                      
!----------------------------------------------------------------          
    INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, its, ite, jts, jte, kts, kte, j
    INTEGER, INTENT(IN) :: num_soil_layers
    LOGICAL, INTENT(IN) :: radiation
    INTEGER, INTENT(IN) :: ifsnow
!
    REAL, INTENT(IN) :: dtmin, xlv, rovcp, deltsm
    REAL, INTENT(IN) :: svp1, svp2, svp3, svpt0
    REAL, INTENT(IN) :: ep2, karman, eomeg, stbolt
    REAL, INTENT(IN) :: p1000mb
    REAL, DIMENSION(ims:ime, num_soil_layers), INTENT(INOUT) :: tslb2d
    REAL, DIMENSION(ims:ime, num_soil_layers), INTENT(INOUT) :: a_tslb2d
    REAL, DIMENSION(num_soil_layers), INTENT(IN) :: zs, dzs
!
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: hfx, qfx, lh, capg, tsk, &
&    qsfc, chklowq
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_hfx
!
    REAL, DIMENSION(ims:ime), INTENT(IN) :: snowc, xland, emiss, mavail&
&    , tmn, gsw, glw, thc
!
    REAL, DIMENSION(its:ite), INTENT(IN) :: qv1d, p1d, t1d
    REAL, DIMENSION(its:ite) :: a_qv1d, a_p1d, a_t1d
!
    REAL, DIMENSION(its:ite), INTENT(IN) :: psfcpa
    REAL, DIMENSION(its:ite) :: a_psfcpa
!
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: flhc, flqc
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_flhc
! LOCAL VARS
    REAL, DIMENSION(its:ite) :: psfc
    REAL, DIMENSION(its:ite) :: a_psfc
    REAL, DIMENSION(its:ite) :: thx, qx, scr3
    REAL, DIMENSION(its:ite) :: a_thx, a_qx, a_scr3
    REAL, DIMENSION(its:ite) :: dthgdt, tg0, thtmn, xld1, tscvn, oltg, &
&    upflux, hm, rnet, xinet, qs, dtsdt
    REAL, DIMENSION(its:ite) :: a_dthgdt, a_tg0, a_tscvn, a_upflux, a_hm&
&    , a_rnet, a_xinet, a_qs, a_dtsdt
!
    REAL, DIMENSION(its:ite, num_soil_layers) :: flux
    REAL, DIMENSION(its:ite, num_soil_layers) :: a_flux
!
    INTEGER :: i, k, nsoil, itsoil, l, nk, radswtch
    REAL :: ps, ps1, xldcol, tskx, rnsoil, rhog1, rhog2, rhog3, lamdag
    REAL :: a_ps, a_ps1, a_tskx
    REAL :: thg, esg, qsg, hfxt, qfxt, cs, csw, lamg(4), thcon, pl
    REAL :: a_thg, a_esg, a_qsg, a_hfxt, a_qfxt, a_thcon, a_pl
    INTEGER :: branch
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_flqc
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_tsk
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_capg
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_qfx
    REAL :: temp3
    REAL :: temp2
    REAL :: temp1
    REAL :: temp0
    REAL :: temp2b0
    REAL :: temp0b
    REAL :: temp2b
    REAL :: temp3b
    REAL :: temp5b2
    REAL :: temp5b1
    REAL :: temp5b0
    REAL :: temp5b
    REAL :: temp3b0
    REAL :: temp
    REAL :: temp5
    REAL :: temp4
!----------------------------------------------------------------------          
!-----DETERMINE IF ANY POINTS IN COLUMN ARE LAND (RATHER THAN OCEAN)             
!       POINTS.  IF NOT, SKIP DOWN TO THE PRINT STATEMENTS SINCE OCEAN           
!       SURFACE TEMPERATURES ARE NOT ALLOWED TO CHANGE.                          
!                                                                                
! from sfcrad   
!----------------------------------------------------------------------
    DATA csw /4.183e6/
    DATA lamg /1.407e-8, -1.455e-5, 6.290e-3, 0.16857/
    DO i=its,ite
! in cmb
      psfc(i) = psfcpa(i)/1000.
    END DO
    DO i=its,ite
! PL cmb
      pl = p1d(i)/1000.
      scr3(i) = t1d(i)
!         THCON=(100./PL)**ROVCP
      thcon = (p1000mb*0.001/pl)**rovcp
      thx(i) = scr3(i)*thcon
      qx(i) = 0.
    END DO
!     IF(IDRY.EQ.1) GOTO 81
    DO i=its,ite
      qx(i) = qv1d(i)
    END DO
!
!-----THE SLAB THERMAL CAPACITY CAPG(I) ARE DEPENDENT ON:
!     THC(I) - SOIL THERMAL INERTIAL, ONLY.
!
    DO i=its,ite
      capg(i) = 3.298e6*thc(i)
      IF (num_soil_layers .GT. 1) THEN
! CAPG REPRESENTS SOIL HEAT CAPACITY (J/K/M^3) WHEN DIFSL=5.E-7 (M^2/S)
! TO GIVE A CORRECT THERMAL INERTIA (=CAPG*DIFSL^0.5)
        capg(i) = 5.9114e7*thc(i)
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
!        
    xldcol = 2.0
    DO i=its,ite
      IF (xldcol .GT. xland(i)) THEN
        xldcol = xland(i)
      ELSE
        xldcol = xldcol
      END IF
    END DO
!                                                                                
    IF (xldcol .GT. 1.5) THEN
      a_thx = 0.0_8
      a_qx = 0.0_8
      a_psfc = 0.0_8
    ELSE
!                                                                                
!                                                                                
!-----CONVERT SLAB TEMPERATURE TO POTENTIAL TEMPERATURE AND                      
!     SET XLD1(I) = 0. FOR OCEAN POINTS:                                         
!                                                                                
!                                                                                
      DO i=its,ite
        IF (xland(i) - 1.5 .GE. 0) THEN
          xld1(i) = 0.
        ELSE
          xld1(i) = 1.
        END IF
      END DO
!                                                                                
!-----CONVERT 'TSK(THETAG)' TO 'TG' FOR 'IUP' CALCULATION ....                   
!       IF WE ARE USING THE BLACKADAR MULTI-LEVEL (HIGH-RESOLUTION)              
!       PBL MODEL                                                                
!                                                                                
      DO i=its,ite
        IF (xld1(i) .LT. 0.5) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
! PS cmb
! TSK is Temperature at gound sfc
!       TG0(I)=TSK(I)*(PS*0.01)**ROVCP                                         
          tg0(i) = tsk(i)
          CALL PUSHCONTROL1B(1)
        END IF
      END DO
      IF (radiation) THEN
        radswtch = 1
      ELSE
        radswtch = 0
      END IF
      DO i=its,ite
        IF (xld1(i) .LT. 0.5) THEN
          CALL PUSHCONTROL2B(0)
        ELSE
!        OLTG(I)=TSK(I)*(100./PSFC(I))**ROVCP
          upflux(i) = radswtch*stbolt*tg0(i)**4
          xinet(i) = emiss(i)*(glw(i)-upflux(i))
          rnet(i) = gsw(i) + xinet(i)
          hm(i) = 1.18*eomeg*(tg0(i)-tmn(i))
          CALL PUSHREAL8(esg)
!       MOISTURE FLUX CALCULATED HERE (OVERWRITES SFC LAYER VALUE FOR LAND)
          esg = svp1*EXP(svp2*(tg0(i)-svpt0)/(tg0(i)-svp3))
          qsg = ep2*esg/(psfc(i)-esg)
          thg = tsk(i)*(100./psfc(i))**rovcp
          hfx(i) = flhc(i)*(thg-thx(i))
          qfx(i) = flqc(i)*(qsg-qx(i))
          qs(i) = hfx(i) + qfx(i)*xlv
!       IF(ISOIL.EQ.0)THEN                                                       
          IF (num_soil_layers .EQ. 1) THEN
            dthgdt(i) = (rnet(i)-qs(i))/capg(i) - hm(i)
            CALL PUSHCONTROL2B(1)
          ELSE
            dthgdt(i) = 0.
            CALL PUSHCONTROL2B(2)
          END IF
        END IF
      END DO
!     IF(ISOIL.EQ.1)THEN                                                         
      IF (num_soil_layers .GT. 1) THEN
        nsoil = 1 + INT(soilfac*4*difsl/dzs(1)*deltsm/dzs(1))
        rnsoil = 1./FLOAT(nsoil)
!                                                                                
!     SOIL SUB-TIMESTEP                                                          
!                                                                                
        DO itsoil=1,nsoil
          DO i=its,ite
            DO l=1,num_soil_layers-1
              IF (xld1(i) .LT. 0.5) THEN
                CALL PUSHCONTROL2B(0)
              ELSE
                IF (l .EQ. 1 .AND. itsoil .GT. 1) THEN
                  CALL PUSHREAL8(ps1)
!                PS1=(PSFC(I)*0.01)**ROVCP    
                  ps1 = (psfcpa(i)/p1000mb)**rovcp
                  CALL PUSHREAL8(ps)
! for rk scheme A and B are the same
                  ps = psfc(i)
                  CALL PUSHREAL8(thg)
                  thg = tslb2d(i, 1)/ps1
                  CALL PUSHREAL8(esg)
                  esg = svp1*EXP(svp2*(tslb2d(i, 1)-svpt0)/(tslb2d(i, 1)&
&                    -svp3))
                  CALL PUSHREAL8(qsg)
                  qsg = ep2*esg/(ps-esg)
!     UPDATE FLUXES FOR NEW GROUND TEMPERATURE                                   
                  hfxt = flhc(i)*(thg-thx(i))
                  qfxt = flqc(i)*(qsg-qx(i))
                  CALL PUSHREAL8(qs(i))
                  qs(i) = hfxt + qfxt*xlv
!     SUM HFX AND QFX OVER SOIL TIMESTEPS                                        
                  CALL PUSHCONTROL1B(0)
                ELSE
                  CALL PUSHCONTROL1B(1)
                END IF
                CALL PUSHREAL8(flux(i, 1))
                flux(i, 1) = rnet(i) - qs(i)
                CALL PUSHREAL8(flux(i, l+1))
                flux(i, l+1) = -(difsl*capg(i)*(tslb2d(i, l+1)-tslb2d(i&
&                  , l))/(zs(l+1)-zs(l)))
                dtsdt(i) = -((flux(i, l+1)-flux(i, l))/(dzs(l)*capg(i)))
                CALL PUSHREAL8(tslb2d(i, l))
                tslb2d(i, l) = tslb2d(i, l) + dtsdt(i)*deltsm*rnsoil
                IF (ifsnow .EQ. 1 .AND. l .EQ. 1) THEN
                  IF (snowc(i) .GT. 0. .AND. tslb2d(i, 1) .GT. 273.16) &
&                  THEN
                    CALL PUSHREAL8(tslb2d(i, 1))
                    tslb2d(i, 1) = 273.16
                    CALL PUSHCONTROL2B(0)
                  ELSE
                    CALL PUSHCONTROL2B(1)
                  END IF
                ELSE
                  CALL PUSHCONTROL2B(2)
                END IF
                IF (l .EQ. 1) THEN
                  dthgdt(i) = dthgdt(i) + rnsoil*dtsdt(i)
                  CALL PUSHCONTROL1B(0)
                ELSE
                  CALL PUSHCONTROL1B(1)
                END IF
                IF (itsoil .EQ. nsoil .AND. l .EQ. 1) THEN
                  CALL PUSHCONTROL2B(1)
                ELSE
                  CALL PUSHCONTROL2B(2)
                END IF
              END IF
            END DO
          END DO
        END DO
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
!                                                                                
      DO i=its,ite
        IF (xld1(i) .LT. 0.5) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          tskx = tg0(i) + deltsm*dthgdt(i)
          CALL PUSHREAL8(tsk(i))
! TSK is temperature
!       TSK(I)=TSKX*(100./PS1)**ROVCP                                          
          tsk(i) = tskx
          CALL PUSHCONTROL1B(1)
        END IF
      END DO
!                                                                                
!-----MODIFY THE THE GROUND TEMPERATURE IF THE SNOW COVER EFFECTS ARE            
!     CONSIDERED: LIMIT THE GROUND TEMPERATURE UNDER 0 C.                        
!                                                                                
      IF (ifsnow .NE. 0) THEN
        DO i=its,ite
          IF (xld1(i) .LT. 0.5) THEN
            CALL PUSHCONTROL1B(0)
          ELSE
!       PS1=(PSFC(I)*0.01)**ROVCP             
!       TSCVN(I)=TSK(I)*PS1                                            
            tscvn(i) = tsk(i)
            IF (snowc(i) .GT. 0. .AND. tscvn(i) .GT. 273.16) THEN
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            CALL PUSHCONTROL1B(1)
          END IF
        END DO
        a_tscvn = 0.0_8
        DO i=ite,its,-1
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            a_tscvn(i) = a_tscvn(i) + a_tsk(i)
            a_tsk(i) = 0.0_8
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) a_tscvn(i) = 0.0_8
            a_tsk(i) = a_tsk(i) + a_tscvn(i)
            a_tscvn(i) = 0.0_8
          END IF
        END DO
      END IF
      a_dthgdt = 0.0_8
      a_tg0 = 0.0_8
      DO i=ite,its,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          CALL POPREAL8(tsk(i))
          a_tskx = a_tsk(i)
          a_tsk(i) = 0.0_8
          a_tg0(i) = a_tg0(i) + a_tskx
          a_dthgdt(i) = a_dthgdt(i) + deltsm*a_tskx
        END IF
      END DO
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        a_qs = 0.0_8
        a_thx = 0.0_8
        a_qx = 0.0_8
        a_rnet = 0.0_8
        a_psfc = 0.0_8
      ELSE
        a_flux = 0.0_8
        a_qs = 0.0_8
        a_thx = 0.0_8
        a_qx = 0.0_8
        a_rnet = 0.0_8
        a_psfc = 0.0_8
        a_dtsdt = 0.0_8
        DO itsoil=nsoil,1,-1
          DO i=ite,its,-1
            DO l=num_soil_layers-1,1,-1
              CALL POPCONTROL2B(branch)
              IF (branch .NE. 0) THEN
                IF (branch .EQ. 1) THEN
                  a_qfx(i) = rnsoil*a_qfx(i)
                  a_hfx(i) = rnsoil*a_hfx(i)
                END IF
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) a_dtsdt(i) = a_dtsdt(i) + rnsoil*&
&                    a_dthgdt(i)
                CALL POPCONTROL2B(branch)
                IF (branch .EQ. 0) THEN
                  CALL POPREAL8(tslb2d(i, 1))
                  a_tslb2d(i, 1) = 0.0_8
                END IF
                CALL POPREAL8(tslb2d(i, l))
                a_dtsdt(i) = a_dtsdt(i) + deltsm*rnsoil*a_tslb2d(i, l)
                temp5 = dzs(l)*capg(i)
                temp5b1 = -(a_dtsdt(i)/temp5)
                a_flux(i, l+1) = a_flux(i, l+1) + temp5b1
                a_flux(i, l) = a_flux(i, l) - temp5b1
                a_capg(i) = a_capg(i) - (tslb2d(i, l+1)-tslb2d(i, l))*&
&                  difsl*a_flux(i, l+1)/(zs(l+1)-zs(l)) - (flux(i, l+1)-&
&                  flux(i, l))*dzs(l)*temp5b1/temp5
                a_dtsdt(i) = 0.0_8
                CALL POPREAL8(flux(i, l+1))
                temp5b2 = -(difsl*capg(i)*a_flux(i, l+1)/(zs(l+1)-zs(l&
&                  )))
                a_tslb2d(i, l+1) = a_tslb2d(i, l+1) + temp5b2
                a_tslb2d(i, l) = a_tslb2d(i, l) - temp5b2
                a_flux(i, l+1) = 0.0_8
                CALL POPREAL8(flux(i, 1))
                a_rnet(i) = a_rnet(i) + a_flux(i, 1)
                a_qs(i) = a_qs(i) - a_flux(i, 1)
                a_flux(i, 1) = 0.0_8
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  a_qfxt = xlv*a_qs(i) + a_qfx(i)
                  a_hfxt = a_qs(i) + a_hfx(i)
                  CALL POPREAL8(qs(i))
                  a_qs(i) = 0.0_8
                  a_flqc(i) = a_flqc(i) + (qsg-qx(i))*a_qfxt
                  a_qsg = flqc(i)*a_qfxt
                  a_qx(i) = a_qx(i) - flqc(i)*a_qfxt
                  a_flhc(i) = a_flhc(i) + (thg-thx(i))*a_hfxt
                  a_thg = flhc(i)*a_hfxt
                  a_thx(i) = a_thx(i) - flhc(i)*a_hfxt
                  CALL POPREAL8(qsg)
                  temp5b = ep2*a_qsg/(ps-esg)
                  temp5b0 = -(esg*temp5b/(ps-esg))
                  a_esg = temp5b - temp5b0
                  a_ps = temp5b0
                  CALL POPREAL8(esg)
                  temp4 = tslb2d(i, 1) - svp3
                  temp3 = (tslb2d(i, 1)-svpt0)/temp4
                  temp3b0 = svp2*EXP(svp2*temp3)*svp1*a_esg/temp4
                  a_tslb2d(i, 1) = a_tslb2d(i, 1) + a_thg/ps1 + (1.0-&
&                    temp3)*temp3b0
                  CALL POPREAL8(thg)
                  a_ps1 = -(tslb2d(i, 1)*a_thg/ps1**2)
                  CALL POPREAL8(ps)
                  a_psfc(i) = a_psfc(i) + a_ps
                  CALL POPREAL8(ps1)
                  IF (.NOT.(psfcpa(i)/p1000mb .LE. 0.0_8 .AND. (rovcp &
&                      .EQ. 0.0_8 .OR. rovcp .NE. INT(rovcp)))) a_psfcpa(&
&                    i) = a_psfcpa(i) + rovcp*(psfcpa(i)/p1000mb)**(rovcp&
&                      -1)*a_ps1/p1000mb
                END IF
              END IF
            END DO
          END DO
        END DO
      END IF
      a_xinet = 0.0_8
      a_hm = 0.0_8
      a_upflux = 0.0_8
      DO i=ite,its,-1
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .EQ. 1) THEN
            temp3b = a_dthgdt(i)/capg(i)
            a_rnet(i) = a_rnet(i) + temp3b
            a_qs(i) = a_qs(i) - temp3b
            a_capg(i) = a_capg(i) - (rnet(i)-qs(i))*temp3b/capg(i)
            a_hm(i) = a_hm(i) - a_dthgdt(i)
            a_dthgdt(i) = 0.0_8
          ELSE
            a_dthgdt(i) = 0.0_8
          END IF
          a_xinet(i) = a_xinet(i) + a_rnet(i)
          a_upflux(i) = a_upflux(i) - emiss(i)*a_xinet(i)
          a_hfx(i) = a_hfx(i) + a_qs(i)
          a_qfx(i) = a_qfx(i) + xlv*a_qs(i)
          a_qs(i) = 0.0_8
          qsg = ep2*esg/(psfc(i)-esg)
          a_flqc(i) = a_flqc(i) + (qsg-qx(i))*a_qfx(i)
          a_qsg = flqc(i)*a_qfx(i)
          a_qx(i) = a_qx(i) - flqc(i)*a_qfx(i)
          a_qfx(i) = 0.0_8
          thg = tsk(i)*(100./psfc(i))**rovcp
          a_flhc(i) = a_flhc(i) + (thg-thx(i))*a_hfx(i)
          a_thg = flhc(i)*a_hfx(i)
          a_thx(i) = a_thx(i) - flhc(i)*a_hfx(i)
          a_hfx(i) = 0.0_8
          temp2 = 100./psfc(i)
          a_tsk(i) = a_tsk(i) + temp2**rovcp*a_thg
          temp2b0 = ep2*a_qsg/(psfc(i)-esg)
          temp2b = -(esg*temp2b0/(psfc(i)-esg))
          IF (temp2 .LE. 0.0_8 .AND. (rovcp .EQ. 0.0_8 .OR. rovcp .NE. &
&              INT(rovcp))) THEN
            a_psfc(i) = a_psfc(i) + temp2b
          ELSE
            a_psfc(i) = a_psfc(i) + temp2b - rovcp*temp2**(rovcp-1)*&
&              tsk(i)*temp2*a_thg/psfc(i)
          END IF
          a_esg = temp2b0 - temp2b
          CALL POPREAL8(esg)
          temp1 = tg0(i) - svp3
          temp0 = (tg0(i)-svpt0)/temp1
          temp0b = svp2*EXP(svp2*temp0)*svp1*a_esg/temp1
          a_tg0(i) = a_tg0(i) + eomeg*1.18*a_hm(i) + radswtch*stbolt*4*&
&            tg0(i)**3*a_upflux(i) + (1.0-temp0)*temp0b
          a_hm(i) = 0.0_8
          a_rnet(i) = 0.0_8
          a_xinet(i) = 0.0_8
          a_upflux(i) = 0.0_8
        END IF
      END DO
      DO i=ite,its,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          a_tsk(i) = a_tsk(i) + a_tg0(i)
          a_tg0(i) = 0.0_8
        END IF
      END DO
    END IF
    DO i=ite,its,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) a_capg(i) = 0.0_8
      a_capg(i) = 0.0_8
    END DO
    DO i=ite,its,-1
      a_qv1d(i) = a_qv1d(i) + a_qx(i)
      a_qx(i) = 0.0_8
    END DO
    a_scr3 = 0.0_8
    DO i=ite,its,-1
      pl = p1d(i)/1000.
      thcon = (p1000mb*0.001/pl)**rovcp
      a_scr3(i) = a_scr3(i) + thcon*a_thx(i)
      a_thcon = scr3(i)*a_thx(i)
      a_thx(i) = 0.0_8
      temp = 0.001*p1000mb/pl
      IF (temp .LE. 0.0_8 .AND. (rovcp .EQ. 0.0_8 .OR. rovcp .NE. INT(&
&          rovcp))) THEN
        a_pl = 0.0
      ELSE
        a_pl = -(rovcp*temp**(rovcp-1)*temp*a_thcon/pl)
      END IF
      a_t1d(i) = a_t1d(i) + a_scr3(i)
      a_scr3(i) = 0.0_8
      a_p1d(i) = a_p1d(i) + a_pl/1000.
    END DO
    DO i=ite,its,-1
      a_psfcpa(i) = a_psfcpa(i) + a_psfc(i)/1000.
      a_psfc(i) = 0.0_8
    END DO
  END SUBROUTINE A_SLAB1D
!----------------------------------------------------------------
END MODULE A_MODULE_SF_SLAB
