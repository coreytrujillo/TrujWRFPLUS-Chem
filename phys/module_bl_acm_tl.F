!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.6 (r4756) - 12 Feb 2013 10:43
!
!WRF:MODEL_LAYER:PHYSICS
!
MODULE G_MODULE_BL_ACM
  USE module_bl_acm, ONLY: ric, crankp
  IMPLICIT NONE
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------

CONTAINS
!  Differentiation of acmpbl in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: alloc(*vci) alloc(*fs) alloc(*ui)
!                alloc(*di) rublten pblh rqvblten rvblten chem3d
!                rqcblten rthblten rqiblten
!   with respect to varying inputs: alloc(*vci) alloc(*fs) alloc(*ui)
!                alloc(*di) rublten qc3d rr3d wspd ust u3d vd3d
!                pblh hfx rqvblten rvblten t3d chem3d qv3d qi3d
!                rqcblten qfx rthblten v3d rqiblten th3d mut dz8w
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
  SUBROUTINE G_ACMPBL(&
     xtime, dtpbl, znw, sigmah, u3d, g_u3d, v3d, g_v3d&
&    , pp3d, dz8w, g_dz8w, th3d, g_th3d, t3d, g_t3d, qv3d, g_qv3d, qc3d, &
&    g_qc3d, qi3d, g_qi3d, rr3d, g_rr3d, &
#if (WRF_CHEM == 1)
! For WRF-Chem
     chem3d, g_chem3d, vd3d, g_vd3d, nchem, kdvel, ndvel, num_vert_mix, &
! For WRF-Chem
#endif
     ust, g_ust, hfx, g_hfx, qfx, g_qfx, &
&    tsk, psfc, ep1, g, rovcp, rd, cpd, pblh, g_pblh, kpbl2d, &
&    exch_h, regime, gz1oz0, wspd, g_wspd, psim, mut, g_mut, rublten, g_rublten&
&    , rvblten, g_rvblten, rthblten, g_rthblten, rqvblten, g_rqvblten, &
&    rqcblten, g_rqcblten, rqiblten, g_rqiblten, ids, ide, jds, jde, kds&
&    , kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte)
    IMPLICIT NONE
!.......Arguments
! DECLARATIONS - INTEGER
    INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, its, ite, jts, jte, kts, kte, xtime
! DECLARATIONS - REAL
    REAL, INTENT(IN) :: dtpbl, ep1, g, rovcp, rd, cpd
    REAL, DIMENSION(kms:kme), INTENT(IN) :: znw, sigmah
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: u3d, v3d, &
&    pp3d, dz8w, t3d, qv3d, qc3d, qi3d, rr3d, th3d
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: g_u3d, &
&    g_v3d, g_dz8w, g_t3d, g_qv3d, g_qc3d, g_qi3d, g_rr3d, g_th3d

    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: psim, gz1oz0, hfx, &
&    qfx, tsk, psfc, wspd, mut
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: g_hfx, g_qfx, &
&    g_wspd, g_mut
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: pblh, regime, &
&    ust
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: g_pblh, g_ust
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: rublten&
&    , rvblten, rthblten, rqvblten, rqcblten, rqiblten
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: &
&    g_rublten, g_rvblten, g_rthblten, g_rqvblten, g_rqcblten, g_rqiblten
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: exch_h
    INTEGER, DIMENSION(ims:ime, jms:jme), INTENT(OUT) :: kpbl2d
#if (WRF_CHEM == 1)
!... Chem
    INTEGER, INTENT(IN) :: nchem, kdvel, ndvel, num_vert_mix
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme, nchem), INTENT(INOUT) :: &
&    chem3d
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme, nchem), INTENT(INOUT) :: &
&    g_chem3d
    REAL, DIMENSION(ims:ime, kdvel, jms:jme, ndvel), INTENT(IN) :: vd3d
    REAL, DIMENSION(ims:ime, kdvel, jms:jme, ndvel), INTENT(IN) :: &
&    g_vd3d
#endif
!... Local Variables
!... Integer
    INTEGER :: i, j, k, l
!... Real
    REAL, DIMENSION(kts:kte) :: dsigh, dsighi, dsigfi
    REAL, DIMENSION(kts:kte) :: g_dsigh, g_dsighi, g_dsigfi
    REAL, DIMENSION(0:kte) :: sigmaf
    REAL, DIMENSION(0:kte) :: g_sigmaf
    REAL :: rdt
    REAL, PARAMETER :: karman=0.4D0
#if (WRF_CHEM == 1)
!... Chem
    REAL, DIMENSION(ims:ime, kms:kme, nchem) :: chem2d
    REAL, DIMENSION(ims:ime, kms:kme, nchem) :: g_chem2d
    REAL, DIMENSION(ims:ime, kdvel, ndvel) :: vd2d
    REAL, DIMENSION(ims:ime, kdvel, ndvel) :: g_vd2d
#endif
!...
    rdt = 1.0D0/dtpbl
    DO k=1,kte
      g_sigmaf(k-1) = 0.0_8
      sigmaf(k-1) = znw(k)
    END DO
    g_sigmaf(kte) = 0.0_8
    sigmaf(kte) = 0.0D0
    DO k=1,kte
      g_dsigh(k) = 0.0_8
      dsigh(k) = sigmaf(k) - sigmaf(k-1)
      g_dsighi(k) = 0.0_8
      dsighi(k) = 1.0D0/dsigh(k)
    END DO
    DO k=kts,kte-1
      g_dsigfi(k) = 0.0_8
      dsigfi(k) = 1.0D0/(sigmah(k+1)-sigmah(k))
    END DO
    g_dsigfi(kte) = 0.0_8
    dsigfi(kte) = dsigfi(kte-1)
    DO j=jts,jte
#if (WRF_CHEM == 1)
      g_chem2d = 0.0_8
      g_vd2d = 0.0_8
#endif

#if (WRF_CHEM == 1)
      DO l=1,nchem
        DO k=kms,kme
          DO i=its,ite
            g_chem2d(i, k, l) = g_chem3d(i, k, j, l)
            chem2d(i, k, l) = chem3d(i, k, j, l)
          END DO
        END DO
      END DO
      DO l=1,ndvel
        DO k=1,kdvel
          DO i=its,ite
            g_vd2d(i, k, l) = g_vd3d(i, k, j, l)
            vd2d(i, k, l) = vd3d(i, k, j, l)
          END DO
        END DO
      END DO
#endif
      CALL G_ACM2D(&
                   j=j,xtime=xtime,dtpbl=dtpbl,sigmaf=sigmaf,sigmah=sigmah   &
                ,dsigfi=dsigfi,dsighi=dsighi,dsigh=dsigh                     &
                ,us=u3d(ims,kms,j),g_us=g_u3d(ims,kms,j)                     &
                ,vs=v3d(ims,kms,j),g_vs=g_v3d(ims,kms,j)                     &
                ,theta=th3d(ims,kms,j),g_theta=g_th3d(ims,kms,j)             &
                ,tt=t3d(ims,kms,j),g_tt=g_t3d(ims,kms,j)                     &
                ,qvs=qv3d(ims,kms,j),g_qvs=g_qv3d(ims,kms,j)             &
                ,qcs=qc3d(ims,kms,j),g_qcs=g_qc3d(ims,kms,j)             &
                ,qis=qi3d(ims,kms,j),g_qis=g_qi3d(ims,kms,j)             &
#if (WRF_CHEM == 1)
                ,chem=chem2d,g_chem=g_chem2d,vd=vd2d,g_vd=g_vd2d             &
                ,nchem=nchem,kdvel=kdvel,ndvel=ndvel                         &
                ,num_vert_mix=num_vert_mix                                   &
#endif
                ,dzf=dz8w(ims,kms,j),g_dzf=g_dz8w(ims,kms,j)                 &
                ,densx=rr3d(ims,kms,j),g_densx=g_rr3d(ims,kms,j)             &
                ,utnp=rublten(ims,kms,j),g_utnp=g_rublten(ims,kms,j)         &
                ,vtnp=rvblten(ims,kms,j),g_vtnp=g_rvblten(ims,kms,j)         &
                ,ttnp=rthblten(ims,kms,j),g_ttnp=g_rthblten(ims,kms,j)       &
                ,qvtnp=rqvblten(ims,kms,j),g_qvtnp=g_rqvblten(ims,kms,j)     &
                ,qctnp=rqcblten(ims,kms,j),g_qctnp=g_rqcblten(ims,kms,j)     &
                ,qitnp=rqiblten(ims,kms,j),g_qitnp=g_rqiblten(ims,kms,j)     &
                ,cpd=cpd,g=g,rovcp=rovcp,rd=rd,rdt=rdt             &
                ,psfcpa=psfc(ims,j),ust=ust(ims,j),g_ust=g_ust(ims,j)                 &
                ,pbl=pblh(ims,j),g_pbl=g_pblh(ims,j)               &
                ,exch_hx=exch_h(ims,kms,j)     &
                ,regime=regime(ims,j),psim=psim(ims,j)             &
                ,hfx=hfx(ims,j),g_hfx=g_hfx(ims,j),qfx=qfx(ims,j),g_qfx=g_qfx(ims,j)  &
                ,tg=tsk(ims,j),gz1oz0=gz1oz0(ims,j)                &
                ,wspd=wspd(ims,j),g_wspd=g_wspd(ims,j),klpbl=kpbl2d(ims,j)              &
                ,mut=mut(ims,j),g_mut=g_mut(ims,j)                           &
                ,ep1=ep1,karman=karman                                       &
                ,ids=ids,ide=ide, jds=jds,jde=jde, kds=kds,kde=kde           &
                ,ims=ims,ime=ime, jms=jms,jme=jme, kms=kms,kme=kme           &
                ,its=its,ite=ite, jts=jts,jte=jte, kts=kts,kte=kte)

#if (WRF_CHEM == 1)
      DO l=1,nchem
        DO i=its,ite
          g_chem3d(i, kms:kme, j, l) = g_chem2d(i, kms:kme, l)
          chem3d(i, kms:kme, j, l) = chem2d(i, kms:kme, l)
        END DO
      END DO
#endif
    END DO
  END SUBROUTINE G_ACMPBL

!  Differentiation of acm2d in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: alloc(*vci) alloc(*fs) alloc(*ui)
!                alloc(*di) qvtnp qitnp vtnp utnp ttnp pbl qctnp
!                chem
!   with respect to varying inputs: alloc(*vci) alloc(*fs) alloc(*ui)
!                alloc(*di) qvtnp tt wspd ust hfx qitnp vtnp us
!                utnp ttnp theta vd qis qvs vs qfx qcs pbl qctnp
!                dzf densx mut chem
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
  SUBROUTINE G_ACM2D(&
j, xtime, dtpbl, sigmaf, sigmah, dsigfi, dsighi, &
&    dsigh, us, g_us, vs, g_vs, theta, g_theta, tt, g_tt, qvs, g_qvs, qcs&
&    , g_qcs, qis, g_qis, &
#if (WRF_CHEM == 1)
     chem, g_chem, vd, g_vd, nchem, kdvel, ndvel, num_vert_mix, &
#endif
     dzf, g_dzf, densx, g_densx, utnp, g_utnp, vtnp, g_vtnp&
&    , ttnp, g_ttnp, qvtnp, g_qvtnp, qctnp, g_qctnp, qitnp, g_qitnp, cpd&
&    , g, rovcp, rd, rdt, psfcpa, ust, g_ust, pbl, g_pbl, exch_hx, regime&
&    , psim, hfx, g_hfx, qfx, g_qfx, tg, gz1oz0, wspd, g_wspd, klpbl, mut&
&    , g_mut, ep1, karman, ids, ide, jds, jde, kds, kde, ims, ime, jms, jme, kms&
&    , kme, its, ite, jts, jte, kts, kte)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, its, ite, jts, jte, kts, kte, j
!.......Arguments
!... Real
    REAL, DIMENSION(0:kte), INTENT(IN) :: sigmaf
    REAL, DIMENSION(kms:kme), INTENT(IN) :: sigmah
    REAL, DIMENSION(kts:kte), INTENT(IN) :: dsigh, dsighi, dsigfi
    REAL, INTENT(IN) :: dtpbl, g, rd, ep1, karman, cpd, rovcp, rdt
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: pbl, ust
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: g_pbl, g_ust
    REAL, DIMENSION(ims:ime, kms:kme), INTENT(IN) :: us, vs, theta, tt, &
&    qvs, qcs, qis, densx
    REAL, DIMENSION(ims:ime, kms:kme), INTENT(IN) :: g_us, g_vs, g_theta&
&    , g_tt, g_qvs, g_qcs, g_qis, g_densx

    REAL, DIMENSION(ims:ime, kms:kme), INTENT(IN) :: dzf
    REAL, DIMENSION(ims:ime, kms:kme), INTENT(IN) :: g_dzf
    REAL, DIMENSION(ims:ime, kms:kme), INTENT(INOUT) :: utnp, vtnp, ttnp&
&    , qvtnp, qctnp, qitnp
    REAL, DIMENSION(ims:ime, kms:kme), INTENT(INOUT) :: g_utnp, g_vtnp, &
&    g_ttnp, g_qvtnp, g_qctnp, g_qitnp
    REAL, DIMENSION(ims:ime), INTENT(IN) :: psfcpa
    REAL, DIMENSION(ims:ime), INTENT(IN) :: tg
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: regime
    REAL, DIMENSION(ims:ime), INTENT(IN) :: wspd, psim, gz1oz0
    REAL, DIMENSION(ims:ime), INTENT(IN) :: g_wspd
    REAL, DIMENSION(ims:ime), INTENT(IN) :: hfx, qfx
    REAL, DIMENSION(ims:ime), INTENT(IN) :: g_hfx, g_qfx
    REAL, DIMENSION(ims:ime), INTENT(IN) :: mut
    REAL, DIMENSION(ims:ime), INTENT(IN) :: g_mut
    REAL, DIMENSION(ims:ime, kms:kme), INTENT(INOUT) :: exch_hx
!... Integer
    INTEGER, DIMENSION(ims:ime), INTENT(OUT) :: klpbl
    INTEGER, INTENT(IN) :: xtime
#if (WRF_CHEM == 1)
!....Chem
    INTEGER, INTENT(IN) :: nchem, kdvel, ndvel, num_vert_mix
    REAL, DIMENSION(ims:ime, kms:kme, nchem), INTENT(INOUT) :: chem
    REAL, DIMENSION(ims:ime, kms:kme, nchem), INTENT(INOUT) :: g_chem
    REAL, DIMENSION(ims:ime, kdvel, ndvel), INTENT(IN) :: vd
    REAL, DIMENSION(ims:ime, kdvel, ndvel), INTENT(IN) :: g_vd
#endif
!--------------------------------------------------------------------
!--Local 
    INTEGER :: i, k
    INTEGER :: kpblht
    INTEGER, DIMENSION(its:ite) :: kpblh, noconv
!... Real
    REAL :: tvcon, wss, tconv, th1, tog, dtmp, wssq
    REAL :: g_tvcon, g_wss, g_tconv, g_th1, g_tog, g_dtmp, g_wssq
    REAL :: psix, thv1
    REAL :: g_thv1
    REAL, DIMENSION(its:ite) :: fint, pstar, cpair
    REAL, DIMENSION(its:ite) :: g_fint, g_pstar, g_cpair
    REAL, DIMENSION(its:ite, kts:kte) :: thetav, rib, eddyz, ux, vx, &
&    thetax, qvx, qcx, qix, za
    REAL, DIMENSION(its:ite, kts:kte) :: g_thetav, g_rib, g_eddyz, g_ux&
&    , g_vx, g_thetax, g_qvx, g_qcx, g_qix, g_za
    REAL, DIMENSION(its:ite, 0:kte) :: zf
    REAL, DIMENSION(its:ite, 0:kte) :: g_zf
    REAL, DIMENSION(its:ite) :: wst, tst, qst, ustm, tstv
    REAL, DIMENSION(its:ite) :: g_wst, g_tst, g_qst, g_ustm, g_tstv
    REAL, DIMENSION(its:ite) :: pblsig, mol
    REAL, DIMENSION(its:ite) :: g_pblsig, g_mol
    REAL :: fintt, zmix, umix, vmix
    REAL :: g_fintt, g_zmix, g_umix, g_vmix
    REAL :: tmpfx, tmpvtcon, tmpp, tmpths, tmpth1, tmpvconv, ws1, dth
    REAL :: g_tmpfx, g_tmpvtcon, g_ws1
    REAL :: a, tst12, rl, zfunc, densf
!    REAL, PARAMETER :: KARMAN = 0.4
!... Integer
    INTEGER :: kl, jtf, ktf, itf, kmix, ksrc
!...
    CHARACTER(len=256) :: message
    REAL :: arg1
    REAL :: g_arg1
    INTRINSIC SIGN
    REAL :: g_abs2
    REAL :: g_abs1
    INTRINSIC ABS
    REAL :: abs2
    REAL :: abs1
    REAL :: abs0
    INTRINSIC SQRT

!-----initialize vertical tendencies and
    DO i=its,ite
      DO k=kts,kte
        g_utnp(i, k) = 0.0_8
        utnp(i, k) = 0.D0
        g_vtnp(i, k) = 0.0_8
        vtnp(i, k) = 0.D0
        g_ttnp(i, k) = 0.0_8
        ttnp(i, k) = 0.D0
      END DO
    END DO
    DO k=kts,kte
      DO i=its,ite
        g_qvtnp(i, k) = 0.0_8
        qvtnp(i, k) = 0.D0
      END DO
    END DO
    DO k=kts,kte
      DO i=its,ite
        g_qctnp(i, k) = 0.0_8
        qctnp(i, k) = 0.D0
        g_qitnp(i, k) = 0.0_8
        qitnp(i, k) = 0.D0
      END DO
    END DO
    g_wst = 0.0_8
    g_tst = 0.0_8
    g_cpair = 0.0_8
    g_ustm = 0.0_8
    g_qst = 0.0_8
    g_tstv = 0.0_8
    g_mol = 0.0_8
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!  Compute Micromet Scaling variables, not availiable in WRF for ACM
    DO i=its,ite
! J/(K KG)
      g_cpair(i) = cpd*0.84D0*g_qvs(i, 1)
      cpair(i) = cpd*(1.0D0+0.84D0*qvs(i, 1))
      g_tmpfx = (g_hfx(i)*cpair(i)*densx(i, 1)-hfx(i)*(g_cpair(i)*densx(&
&        i, 1)+cpair(i)*g_densx(i, 1)))/(cpair(i)*densx(i, 1))**2
      tmpfx = hfx(i)/(cpair(i)*densx(i, 1))
! COnversion factor for virtual temperature
      g_tmpvtcon = ep1*g_qvs(i, 1)
      tmpvtcon = 1.0D0 + ep1*qvs(i, 1)
! Level 1 wind speed
      g_arg1 = 2.D0*us(i, 1)*g_us(i, 1) + 2.D0*vs(i, 1)*g_vs(i, 1)
      arg1 = us(i, 1)**2 + vs(i, 1)**2
      IF (arg1 .EQ. 0.0_8) THEN
        g_ws1 = 0.0_8
      ELSE
        g_ws1 = g_arg1/(2.0D0*SQRT(arg1))
      END IF
      ws1 = SQRT(arg1)
      g_tst(i) = -((g_tmpfx*ust(i)-tmpfx*g_ust(i))/ust(i)**2)
      tst(i) = -(tmpfx/ust(i))
      g_qst(i) = -((g_qfx(i)*ust(i)*densx(i, 1)-qfx(i)*(g_ust(i)*densx(i&
&        , 1)+ust(i)*g_densx(i, 1)))/(ust(i)*densx(i, 1))**2)
      qst(i) = -(qfx(i)/(ust(i)*densx(i, 1)))
      g_ustm(i) = ((g_ust(i)*ws1+ust(i)*g_ws1)*wspd(i)-ust(i)*ws1*g_wspd&
&        (i))/wspd(i)**2
      ustm(i) = ust(i)*ws1/wspd(i)
      g_thv1 = g_tmpvtcon*theta(i, 1) + tmpvtcon*g_theta(i, 1)
      thv1 = tmpvtcon*theta(i, 1)
      g_tstv(i) = g_tst(i)*tmpvtcon + tst(i)*g_tmpvtcon + ep1*(g_thv1*&
&        qst(i)+thv1*g_qst(i))
      tstv(i) = tst(i)*tmpvtcon + thv1*ep1*qst(i)
      IF (tstv(i) .GE. 0.) THEN
        abs0 = tstv(i)
      ELSE
        abs0 = -tstv(i)
      END IF
      IF (abs0 .LT. 1.0d-6) THEN
        g_tstv(i) = 0.0_8
        tstv(i) = SIGN(1.0d-6, tstv(i))
      END IF
      g_mol(i) = ((g_thv1*ust(i)**2+thv1*2.D0*ust(i)*g_ust(i))*karman*g*&
&        tstv(i)-thv1*ust(i)**2*karman*g*g_tstv(i))/(karman*g*tstv(i))**2
      mol(i) = thv1*ust(i)**2/(karman*g*tstv(i))
      IF (mol(i) .GE. 0.) THEN
        g_abs1 = g_mol(i)
        abs1 = mol(i)
      ELSE
        g_abs1 = -g_mol(i)
        abs1 = -mol(i)
      END IF
      IF( pbl(i) .LE. 0.D0 ) THEN
        g_wst(i) = 0.D0
      ELSE
        g_wst(i) = g_ust(i)*(pbl(i)/(karman*abs1))**0.333333D0 + ust(i)*&
&          0.333333D0*(pbl(i)/(karman*abs1))**(-0.666667D0)*(g_pbl(i)*karman*&
&          abs1-pbl(i)*karman*g_abs1)/(karman**2*abs1**2)
      ENDIF
      wst(i) = ust(i)*(pbl(i)/(karman*abs1))**0.333333D0
! P* in cb 
      g_pstar(i) = g_mut(i)/1000.D0
      pstar(i) = mut(i)/1000.D0
    END DO
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!... Compute PBL height
!... compute the height of full- and half-sigma level above ground level
    DO i=its,ite
      g_zf(i, 0) = 0.0_8
      zf(i, 0) = 0.0D0
      klpbl(i) = 1
    END DO
    g_za = 0.0_8
    g_zf = 0.0_8
    DO k=kts,kte
      DO i=its,ite
        g_zf(i, k) = g_dzf(i, k) + g_zf(i, k-1)
        zf(i, k) = dzf(i, k) + zf(i, k-1)
        g_za(i, k) = 0.5D0*(g_zf(i, k)+g_zf(i, k-1))
        za(i, k) = 0.5D0*(zf(i, k)+zf(i, k-1))
      END DO
    END DO
    g_thetav = 0.0_8
    DO k=kts,kte
      DO i=its,ite
        g_tvcon = ep1*g_qvs(i, k)
        tvcon = 1.0D0 + ep1*qvs(i, k)
        g_thetav(i, k) = g_theta(i, k)*tvcon + theta(i, k)*g_tvcon
        thetav(i, k) = theta(i, k)*tvcon
      END DO
    END DO
    g_rib = 0.0_8
!...  COMPUTE PBL WHERE RICHARDSON NUMBER = RIC (0.25) HOLTSLAG ET AL 1990  
    DO i=its,ite
      DO k=1,kte
        ksrc = k
        IF (sigmaf(k) .LT. 0.9955) GOTO 69
      END DO
 69   th1 = 0.0D0
      g_th1 = 0.0_8
      DO k=1,ksrc
        g_th1 = g_th1 + g_thetav(i, k)
        th1 = th1 + thetav(i, k)
      END DO
      g_th1 = g_th1/ksrc
      th1 = th1/ksrc
      IF (mol(i) .LT. 0.0 .AND. xtime .GT. 1) THEN
        IF (ust(i)**3 + 0.6D0*wst(i)**3 .GT. 0.0_8) THEN
          g_wss = 0.33333D0*(ust(i)**3+0.6D0*wst(i)**3)**(-0.66667D0)*(3.D0*ust(i&
&            )**2*g_ust(i)+0.6D0*3.D0*wst(i)**2*g_wst(i))
        ELSE
          g_wss = 0.0_8
        END IF
        wss = (ust(i)**3+0.6D0*wst(i)**3)**0.33333D0
        g_tconv = -((8.5D0*(g_ust(i)*tstv(i)+ust(i)*g_tstv(i))*wss-8.5D0*ust&
&          (i)*tstv(i)*g_wss)/wss**2)
        tconv = -(8.5D0*ust(i)*tstv(i)/wss)
        g_th1 = g_th1 + g_tconv
        th1 = th1 + tconv
      END IF
      kmix = 1
      DO k=1,kte
        dtmp = thetav(i, k) - th1
        IF (dtmp .LT. 0.0) kmix = k
      END DO
      IF (kmix .GT. 1) THEN
        g_fintt = ((g_th1-g_thetav(i, kmix))*(thetav(i, kmix+1)-thetav(i&
&          , kmix))-(th1-thetav(i, kmix))*(g_thetav(i, kmix+1)-g_thetav(i&
&          , kmix)))/(thetav(i, kmix+1)-thetav(i, kmix))**2
        fintt = (th1-thetav(i, kmix))/(thetav(i, kmix+1)-thetav(i, kmix)&
&          )
        g_zmix = g_fintt*(za(i, kmix+1)-za(i, kmix)) + fintt*(g_za(i, &
&          kmix+1)-g_za(i, kmix)) + g_za(i, kmix)
        zmix = fintt*(za(i, kmix+1)-za(i, kmix)) + za(i, kmix)
        g_umix = g_fintt*(us(i, kmix+1)-us(i, kmix)) + fintt*(g_us(i, &
&          kmix+1)-g_us(i, kmix)) + g_us(i, kmix)
        umix = fintt*(us(i, kmix+1)-us(i, kmix)) + us(i, kmix)
        g_vmix = g_fintt*(vs(i, kmix+1)-vs(i, kmix)) + fintt*(g_vs(i, &
&          kmix+1)-g_vs(i, kmix)) + g_vs(i, kmix)
        vmix = fintt*(vs(i, kmix+1)-vs(i, kmix)) + vs(i, kmix)
      ELSE
        g_zmix = g_za(i, 1)
        zmix = za(i, 1)
        g_umix = g_us(i, 1)
        umix = us(i, 1)
        g_vmix = g_vs(i, 1)
        vmix = vs(i, 1)
      END IF
      DO k=kmix,kte
        g_dtmp = g_thetav(i, k) - g_th1
        dtmp = thetav(i, k) - th1
        g_tog = 0.5D0*(g_thetav(i, k)+g_th1)/g
        tog = 0.5D0*(thetav(i, k)+th1)/g
        g_wssq = 2.D0*(us(i, k)-umix)*(g_us(i, k)-g_umix) + 2.D0*(vs(i, k)-&
&          vmix)*(g_vs(i, k)-g_vmix)
        wssq = (us(i, k)-umix)**2 + (vs(i, k)-vmix)**2
        IF (kmix .EQ. 1) THEN
          g_wssq = g_wssq + 100.D0*(g_ust(i)*ust(i)+ust(i)*g_ust(i))
          wssq = wssq + 100.D0*ust(i)*ust(i)
        END IF
        IF (wssq .LT. 0.1) THEN
          wssq = 0.1D0
          g_wssq = 0.0_8
        ELSE
          wssq = wssq
        END IF
        IF (za(i, k) - zmix .GE. 0.) THEN
          g_abs2 = g_za(i, k) - g_zmix
          abs2 = za(i, k) - zmix
        ELSE
          g_abs2 = -(g_za(i, k)-g_zmix)
          abs2 = -(za(i, k)-zmix)
        END IF
        g_rib(i, k) = ((g_abs2*dtmp+abs2*g_dtmp)*tog*wssq-abs2*dtmp*(&
&          g_tog*wssq+tog*g_wssq))/(tog*wssq)**2
        rib(i, k) = abs2*dtmp/(tog*wssq)
        IF (rib(i, k) .GE. ric) GOTO 201
      END DO
!       write (message, *)' RIBX never exceeds RIC, RIB(i,kte) = ',rib(i,5),        &
!               ' THETAV(i,1) = ',thetav(i,1),' MOL=',mol(i),            &
!               ' TCONV = ',TCONV,' WST = ',WST(I),                      &
!               ' KMIX = ',kmix,' UST = ',UST(I),                       &
!               ' TST = ',TST(I),' U,V = ',US(I,1),VS(I,1),              &
!               ' I,J=',I,J
!       CALL wrf_error_fatal ( message )
 201  kpblh(i) = k
    END DO
    g_fint = 0.0_8
    g_pblsig = 0.0_8
    DO i=its,ite
      IF (kpblh(i) .NE. 1) THEN
!---------INTERPOLATE BETWEEN LEVELS -- jp 7/93
        g_fint(i) = (-(g_rib(i, kpblh(i)-1)*(rib(i, kpblh(i))-rib(i, &
&          kpblh(i)-1)))-(ric-rib(i, kpblh(i)-1))*(g_rib(i, kpblh(i))-&
&          g_rib(i, kpblh(i)-1)))/(rib(i, kpblh(i))-rib(i, kpblh(i)-1))**&
&          2
        fint(i) = (ric-rib(i, kpblh(i)-1))/(rib(i, kpblh(i))-rib(i, &
&          kpblh(i)-1))
        IF (fint(i) .GT. 0.5) THEN
          kpblht = kpblh(i)
          fint(i) = fint(i) - 0.5D0
        ELSE
          kpblht = kpblh(i) - 1
          fint(i) = fint(i) + 0.5D0
        END IF
        g_pbl(i) = g_fint(i)*(zf(i, kpblht)-zf(i, kpblht-1)) + fint(i)*(&
&          g_zf(i, kpblht)-g_zf(i, kpblht-1)) + g_zf(i, kpblht-1)
        pbl(i) = fint(i)*(zf(i, kpblht)-zf(i, kpblht-1)) + zf(i, kpblht-&
&          1)
        klpbl(i) = kpblht
! sigma at PBL height
        g_pblsig(i) = dsigh(kpblht)*g_fint(i)
        pblsig(i) = fint(i)*dsigh(kpblht) + sigmaf(kpblht-1)
      ELSE
        klpbl(i) = 1
        g_pbl(i) = g_zf(i, 1)
        pbl(i) = zf(i, 1)
        g_pblsig(i) = 0.0_8
        pblsig(i) = sigmaf(1)
      END IF
    END DO

    DO i=its,ite
      noconv(i) = 0
! Check for CBL and identify conv. vs. non-conv cells
      IF (pbl(i)/mol(i) .LT. -0.02 .AND. klpbl(i) .GT. 3 .AND. thetav(i&
&          , 1) .GT. thetav(i, 2) .AND. xtime .GT. 1) THEN
        noconv(i) = 1
! FREE CONVECTIVE - ACM
        regime(i) = 4.0
      END IF
    END DO
!... Calculate Kz
    CALL G_EDDYX(dtpbl, zf, g_zf, za, g_za, mol, g_mol, pbl, g_pbl, ust&
&           , g_ust, us, g_us, vs, g_vs, tt, g_tt, thetav, g_thetav, &
&           densx, g_densx, pstar, g_pstar, qvs, g_qvs, qcs, qis, dsigfi, g, rd, &
&           cpair, g_cpair, eddyz, g_eddyz, its, ite, kts, kte, ims, ime&
&           , kms, kme)
    CALL G_ACM(dtpbl, pstar, g_pstar, noconv, sigmaf, dsigh, dsighi, j, klpbl, &
&         pbl, g_pbl, pblsig, g_pblsig, mol, g_mol, ust, g_ust, tst, &
&         g_tst, qst, g_qst, ustm, g_ustm, eddyz, g_eddyz, densx, g_densx&
&         , us, g_us, vs, g_vs, theta, g_theta, qvs, g_qvs, qcs, g_qcs, &
&         qis, g_qis, ux, g_ux, vx, g_vx, thetax, g_thetax, qvx, g_qvx, &
&         qcx, g_qcx, qix, g_qix, &
#if (WRF_CHEM == 1)
          chem, g_chem, vd, g_vd, nchem, kdvel, ndvel, num_vert_mix, &
#endif
          ids, ide, jds, jde, kds, kde, ims, ime, &
&         jms, jme, kms, kme, its, ite, jts, jte, kts, kte)
!.. Load exch_h for use in CCN activation
    DO k=kts,kte-1
      DO i=its,ite
        densf = 0.5D0*(densx(i, k+1)+densx(i, k))
        exch_hx(i, k) = eddyz(i, k)/((densf*g/pstar(i))**2*dtpbl*dsigfi(&
&          k)*1.d-6)
      END DO
    END DO
!... Calculate tendency due to PBL parameterization
    DO k=kts,kte
      DO i=its,ite
        g_utnp(i, k) = g_utnp(i, k) + rdt*(g_ux(i, k)-g_us(i, k))
        utnp(i, k) = utnp(i, k) + (ux(i, k)-us(i, k))*rdt
        g_vtnp(i, k) = g_vtnp(i, k) + rdt*(g_vx(i, k)-g_vs(i, k))
        vtnp(i, k) = vtnp(i, k) + (vx(i, k)-vs(i, k))*rdt
        g_ttnp(i, k) = g_ttnp(i, k) + rdt*(g_thetax(i, k)-g_theta(i, k))
        ttnp(i, k) = ttnp(i, k) + (thetax(i, k)-theta(i, k))*rdt
        g_qvtnp(i, k) = g_qvtnp(i, k) + rdt*(g_qvx(i, k)-g_qvs(i, k))
        qvtnp(i, k) = qvtnp(i, k) + (qvx(i, k)-qvs(i, k))*rdt
        g_qctnp(i, k) = g_qctnp(i, k) + rdt*(g_qcx(i, k)-g_qcs(i, k))
        qctnp(i, k) = qctnp(i, k) + (qcx(i, k)-qcs(i, k))*rdt
        g_qitnp(i, k) = g_qitnp(i, k) + rdt*(g_qix(i, k)-g_qis(i, k))
        qitnp(i, k) = qitnp(i, k) + (qix(i, k)-qis(i, k))*rdt
      END DO
    END DO
  END SUBROUTINE G_ACM2D

!  Differentiation of eddyx in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: eddyz
!   with respect to varying inputs: tt pstar ust us cpair qvs vs pbl
!                za zf densx thetav mol
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!-------------------------------------------------------------------          
  SUBROUTINE G_EDDYX(dtpbl, zf, g_zf, za, g_za, mol, g_mol, pbl, g_pbl, &
&    ust, g_ust, us, g_us, vs, g_vs, tt, g_tt, thetav, g_thetav, densx, &
&    g_densx, pstar, g_pstar, qvs, g_qvs, qcs, qis, dsigfi, g, rd, cpair, g_cpair&
&    , eddyz, g_eddyz, its, ite, kts, kte, ims, ime, kms, kme)
    IMPLICIT NONE
!.......Arguments
!... Integer
    INTEGER, INTENT(IN) :: its, ite, kts, kte, ims, ime, kms, kme
!... Real
    REAL, DIMENSION(ims:ime), INTENT(IN) :: pbl, ust
    REAL, DIMENSION(ims:ime), INTENT(IN) :: g_pbl, g_ust
    REAL, INTENT(IN) :: dtpbl, g, rd
    REAL, DIMENSION(kts:kte), INTENT(IN) :: dsigfi
    REAL, DIMENSION(its:ite), INTENT(IN) :: mol, pstar, cpair
    REAL, DIMENSION(its:ite), INTENT(IN) :: g_mol, g_pstar, g_cpair
    REAL, DIMENSION(ims:ime, kms:kme), INTENT(IN) :: us, vs, tt, qvs, &
&    qcs, qis, densx
    REAL, DIMENSION(ims:ime, kms:kme), INTENT(IN) :: g_us, g_vs, g_tt, &
&    g_qvs, g_densx
    REAL, DIMENSION(its:ite, kts:kte), INTENT(IN) :: za, thetav
    REAL, DIMENSION(its:ite, kts:kte), INTENT(IN) :: g_za, g_thetav
    REAL, DIMENSION(its:ite, 0:kte), INTENT(IN) :: zf
    REAL, DIMENSION(its:ite, 0:kte), INTENT(IN) :: g_zf
    REAL, DIMENSION(its:ite, kts:kte), INTENT(OUT) :: eddyz
    REAL, DIMENSION(its:ite, kts:kte), INTENT(OUT) :: g_eddyz
!.......Local variables
!... Integer
    INTEGER :: ilx, kl, klm, k, i
!... Real
    REAL :: zovl, phih, wt, zsol, zfunc, dzf, ss, goth, edyz
    REAL :: g_zovl, g_phih, g_wt, g_zsol, g_zfunc, g_dzf, g_ss, g_goth, &
&    g_edyz
    REAL :: ri, qmean, tmean, xlv, alph, chi, zk, sql, densf, kzo
    REAL :: g_ri, g_qmean, g_tmean, g_xlv, g_alph, g_chi, g_zk, g_sql, &
&    g_densf
    REAL :: fh
    REAL :: g_fh
!... Parameters
    REAL, PARAMETER :: rv=461.5D0
    REAL, PARAMETER :: rc=0.25D0
    REAL, PARAMETER :: rlam=80.0D0
!15.0  !  Holtslag and Boville (1993)
    REAL, PARAMETER :: gamh=16.0D0
!  Holtslag and Boville (1993)
    REAL, PARAMETER :: betah=5.0D0
    REAL, PARAMETER :: karman=0.4D0
! New Min Kz
    REAL, PARAMETER :: edyz0=0.01D0
!      REAL, PARAMETER :: EDYZ0  = 0.1
!--   IMVDIF      imvdif=1 for moist adiabat vertical diffusion
    INTEGER, PARAMETER :: imvdif=1
    REAL :: arg1
    REAL :: g_arg1
    REAL :: result1
    REAL :: g_result1
    REAL :: pwr1
    REAL :: g_pwr1
    REAL :: result10
    REAL :: g_result10
    REAL :: g_max2
    REAL :: g_max3
    INTRINSIC SQRT
    REAL :: max2
    REAL :: max3
!
    ilx = ite
    kl = kte
    klm = kte - 1
    g_eddyz = 0.0_8
    g_phih = 0.0_8
    DO k=kts,klm
      DO i=its,ilx
        edyz = 0.0D0
        zovl = 0.0D0
        g_dzf = g_za(i, k+1) - g_za(i, k)
        dzf = za(i, k+1) - za(i, k)
        kzo = edyz0
!--------------------------------------------------------------------------
        IF (zf(i, k) .LT. pbl(i)) THEN
          g_zovl = (g_zf(i, k)*mol(i)-zf(i, k)*g_mol(i))/mol(i)**2
          zovl = zf(i, k)/mol(i)
          IF (zovl .LT. 0.0) THEN
            IF (zf(i, k) .LT. 0.1D0*pbl(i)) THEN
              g_arg1 = -(gamh*g_zovl)
              arg1 = 1.0D0 - gamh*zovl
              IF (arg1 .EQ. 0.0_8) THEN
                g_result1 = 0.0_8
              ELSE
                g_result1 = g_arg1/(2.0D0*SQRT(arg1))
              END IF
              result1 = SQRT(arg1)
              g_phih = -(g_result1/result1**2)
              phih = 1.0D0/result1
              g_wt = (g_ust(i)*phih-ust(i)*g_phih)/phih**2
              wt = ust(i)/phih
            ELSE
              g_zsol = (0.1D0*g_pbl(i)*mol(i)-0.1D0*pbl(i)*g_mol(i))/mol(i)&
&                **2
              zsol = 0.1D0*pbl(i)/mol(i)
              g_arg1 = -(gamh*g_zsol)
              arg1 = 1.0D0 - gamh*zsol
              IF (arg1 .EQ. 0.0_8) THEN
                g_result1 = 0.0_8
              ELSE
                g_result1 = g_arg1/(2.0D0*SQRT(arg1))
              END IF
              result1 = SQRT(arg1)
              g_phih = -(g_result1/result1**2)
              phih = 1.0D0/result1
              g_wt = (g_ust(i)*phih-ust(i)*g_phih)/phih**2
              wt = ust(i)/phih
            END IF
          ELSE IF (zovl .LT. 1.0) THEN
            g_phih = betah*g_zovl
            phih = 1.0D0 + betah*zovl
            g_wt = (g_ust(i)*phih-ust(i)*g_phih)/phih**2
            wt = ust(i)/phih
          ELSE
            g_phih = g_zovl
            phih = betah + zovl
            g_wt = (g_ust(i)*phih-ust(i)*g_phih)/phih**2
            wt = ust(i)/phih
          END IF
          g_zfunc = g_zf(i, k)*(1.0D0-zf(i, k)/pbl(i))**2 - zf(i, k)*2.D0*(&
&            1.0D0-zf(i, k)/pbl(i))*(g_zf(i, k)*pbl(i)-zf(i, k)*g_pbl(i))/&
&            pbl(i)**2
          zfunc = zf(i, k)*(1.0D0-zf(i, k)/pbl(i))**2
          g_edyz = karman*(g_wt*zfunc+wt*g_zfunc)
          edyz = karman*wt*zfunc
        ELSE
          g_edyz = 0.0_8
        END IF
!--------------------------------------------------------------------------
        g_ss = ((2.D0*(us(i, k+1)-us(i, k))*(g_us(i, k+1)-g_us(i, k))+2.D0*(vs&
&          (i, k+1)-vs(i, k))*(g_vs(i, k+1)-g_vs(i, k)))*dzf**2-((us(i, k&
&          +1)-us(i, k))**2+(vs(i, k+1)-vs(i, k))**2)*(g_dzf*dzf+dzf*&
&          g_dzf))/(dzf*dzf)**2
        ss = ((us(i, k+1)-us(i, k))**2+(vs(i, k+1)-vs(i, k))**2)/(dzf*&
&          dzf) + 1.0d-9
        g_goth = -(2.0D0*g*(g_thetav(i, k+1)+g_thetav(i, k))/(thetav(i, k+&
&          1)+thetav(i, k))**2)
        goth = 2.0D0*g/(thetav(i, k+1)+thetav(i, k))
        g_ri = ((g_goth*(thetav(i, k+1)-thetav(i, k))+goth*(g_thetav(i, &
&          k+1)-g_thetav(i, k)))*dzf*ss-goth*(thetav(i, k+1)-thetav(i, k)&
&          )*(g_dzf*ss+dzf*g_ss))/(dzf*ss)**2
        ri = goth*(thetav(i, k+1)-thetav(i, k))/(dzf*ss)
!--------------------------------------------------------------------------
!         Adjustment to vert diff in Moist air
        IF (imvdif .EQ. 1) THEN
          IF (qcs(i, k) + qis(i, k) .GT. 0.01d-3 .OR. qcs(i, k+1) + qis(&
&              i, k+1) .GT. 0.01d-3) THEN
            g_qmean = 0.5D0*(g_qvs(i, k)+g_qvs(i, k+1))
            qmean = 0.5D0*(qvs(i, k)+qvs(i, k+1))
            g_tmean = 0.5D0*(g_tt(i, k)+g_tt(i, k+1))
            tmean = 0.5D0*(tt(i, k)+tt(i, k+1))
            g_xlv = -(1.d6*0.00237D0*g_tmean)
            xlv = (2.501D0-0.00237D0*(tmean-273.15D0))*1.d6
            g_alph = ((g_xlv*qmean+xlv*g_qmean)*tmean/rd-xlv*qmean*&
&              g_tmean/rd)/tmean**2
            alph = xlv*qmean/rd/tmean
            g_chi = (((((g_xlv*xlv+xlv*g_xlv)*qmean+xlv**2*g_qmean)*&
&              cpair(i)-xlv**2*qmean*g_cpair(i))*tmean/(cpair(i)**2*rv)-&
&              xlv**2*qmean*g_tmean/(cpair(i)*rv))/tmean-xlv**2*qmean*&
&              g_tmean/(cpair(i)*rv*tmean))/tmean**2
            chi = xlv*xlv*qmean/cpair(i)/rv/tmean/tmean
            g_ri = g_alph*(ri-g*g/ss/tmean/cpair(i)*((chi-alph)/(1.0D0+chi&
&              ))) + (1.0D0+alph)*(g_ri-((-(g**2*g_ss*tmean/ss**2)-g**2*&
&              g_tmean/ss)*cpair(i)/tmean**2-g**2*g_cpair(i)/(ss*tmean))*&
&              (chi-alph)/(cpair(i)**2*(1.0D0+chi))-g**2*((g_chi-g_alph)*(&
&              1.0D0+chi)-(chi-alph)*g_chi)/(ss*tmean*cpair(i)*(1.0D0+chi)**2&
&              ))
            ri = (1.0D0+alph)*(ri-g*g/ss/tmean/cpair(i)*((chi-alph)/(1.0D0+&
&              chi)))
          END IF
        END IF
!--------------------------------------------------------------------------
        g_zk = 0.4D0*g_zf(i, k)
        zk = 0.4D0*zf(i, k)
        g_sql = 2.D0*zk*rlam*(rlam*g_zk*(rlam+zk)-zk*rlam*g_zk)/(rlam+zk)**&
&          3
        sql = (zk*rlam/(rlam+zk))**2
        IF (ri .GE. 0.0) THEN
          IF (zf(i, k) .LT. pbl(i) .AND. zovl .GT. 0.0) THEN
            IF ((1.-zf(i, k)/pbl(i))**2 .LT. 0.01) THEN
              max3 = 0.01D0
              g_max3 = 0.0_8
            ELSE
              g_max3 = -(2.D0*(1.-zf(i, k)/pbl(i))*(g_zf(i, k)*pbl(i)-zf(i&
&                , k)*g_pbl(i))/pbl(i)**2)
              max3 = (1.D0-zf(i, k)/pbl(i))**2
            END IF
            IF (phih .NE. 0.0_8) THEN
              g_pwr1 = -(2.D0*g_phih/phih**3)
            ELSE
              g_pwr1 = 0.0_8
            END IF
            pwr1 = phih**(-2)
            g_fh = g_max3*pwr1 + max3*g_pwr1
            fh = max3*pwr1
            g_sql = 2.D0*zk*g_zk
            sql = zk**2
          ELSE
            IF (1.D0 - ri/rc .LT. 0.01) THEN
              max2 = 0.01D0
              g_max2 = 0.0_8
            ELSE
              g_max2 = -(g_ri/rc)
              max2 = 1.D0 - ri/rc
            END IF
            g_fh = 2.D0*max2*g_max2
            fh = max2**2
          END IF
          IF (ss .EQ. 0.0_8) THEN
            g_result10 = 0.0_8
          ELSE
            g_result10 = g_ss/(2.0D0*SQRT(ss))
          END IF
          result10 = SQRT(ss)
          g_eddyz(i, k) = (g_result10*fh+result10*g_fh)*sql + result10*&
&            fh*g_sql
          eddyz(i, k) = kzo + result10*fh*sql
        ELSE
          g_arg1 = g_ss*(1.0D0-25.0D0*ri) - ss*25.0D0*g_ri
          arg1 = ss*(1.0D0-25.0D0*ri)
          IF (arg1 .EQ. 0.0_8) THEN
            g_result10 = 0.0_8
          ELSE
            g_result10 = g_arg1/(2.0D0*SQRT(arg1))
          END IF
          result10 = SQRT(arg1)
          g_eddyz(i, k) = g_result10*sql + result10*g_sql
          eddyz(i, k) = kzo + result10*sql
        END IF
        IF (edyz .GT. eddyz(i, k)) THEN
          g_eddyz(i, k) = g_edyz
          eddyz(i, k) = edyz
        END IF
        IF (1000.0D0 .GT. eddyz(i, k)) THEN
          eddyz(i, k) = eddyz(i, k)
        ELSE
          g_eddyz(i, k) = 0.0_8
          eddyz(i, k) = 1000.0D0
        END IF
        IF (kzo .LT. eddyz(i, k)) THEN
          eddyz(i, k) = eddyz(i, k)
        ELSE
          g_eddyz(i, k) = 0.0_8
          eddyz(i, k) = kzo
        END IF
        g_densf = 0.5D0*(g_densx(i, k+1)+g_densx(i, k))
        densf = 0.5D0*(densx(i, k+1)+densx(i, k))
        g_eddyz(i, k) = dtpbl*dsigfi(k)*1.d-6*(g_eddyz(i, k)*densf**2*g**&
&          2/pstar(i)**2+eddyz(i, k)*2.D0*densf*g*(g*g_densf*pstar(i)-densf*&
&          g*g_pstar(i))/pstar(i)**3)
        eddyz(i, k) = eddyz(i, k)*(densf*g/pstar(i))**2*dtpbl*dsigfi(k)*&
&          1.d-6
      END DO
    END DO
! for I loop
! for k loop
!
    DO i=its,ilx
! EDDYZ(I,KLM) -- changed jp 3/08
      g_eddyz(i, kl) = 0.0_8
      eddyz(i, kl) = 0.0D0
    END DO
  END SUBROUTINE G_EDDYX

!  Differentiation of acm in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: alloc(*vci) alloc(*fs) alloc(*ui)
!                alloc(*di) ux qix qvx vx qcx chem thetax
!   with respect to varying inputs: alloc(*vci) alloc(*fs) alloc(*ui)
!                alloc(*di) pstar ust us theta tst vd qis qvs ustm vs
!                qst pblsig qcs pbl densx chem eddyz mol
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!-------------------------------------------------------------------          
  SUBROUTINE G_ACM(dtpbl, pstar, g_pstar, noconv, sigmaf, dsigh, dsighi, jx, &
&    klpbl, pbl, g_pbl, pblsig, g_pblsig, mol, g_mol, ust, g_ust, tst, &
&    g_tst, qst, g_qst, ustm, g_ustm, eddyz, g_eddyz, densx, g_densx, us&
&    , g_us, vs, g_vs, theta, g_theta, qvs, g_qvs, qcs, g_qcs, qis, g_qis&
&    , ux, g_ux, vx, g_vx, thetax, g_thetax, qvx, g_qvx, qcx, g_qcx, qix&
&    , g_qix &
#if (WRF_CHEM == 1)
     , chem, g_chem, vd, g_vd, nchem, kdvel, ndvel, num_vert_mix &
#endif
&    , ids, ide, jds, jde, kds, kde, ims, ime, jms, jme, kms, kme, its, ite&
&    , jts, jte, kts, kte)
    IMPLICIT NONE
!.......Arguments
!... Integer
    INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, its, ite, jts, jte, kts, kte, jx
    INTEGER, DIMENSION(its:ite), INTENT(IN) :: noconv
    INTEGER, DIMENSION(ims:ime), INTENT(IN) :: klpbl
!... Real
    REAL, DIMENSION(ims:ime), INTENT(IN) :: pbl, ust
    REAL, DIMENSION(ims:ime), INTENT(IN) :: g_pbl, g_ust
    REAL, INTENT(IN) :: dtpbl
    REAL, DIMENSION(its:ite), INTENT(IN) :: pstar, pblsig, mol, tst, qst&
&    , ustm
    REAL, DIMENSION(its:ite), INTENT(IN) :: g_pstar, g_pblsig, g_mol, g_tst, &
&    g_qst, g_ustm
    REAL, DIMENSION(kts:kte), INTENT(IN) :: dsighi, dsigh
    REAL, DIMENSION(0:kte), INTENT(IN) :: sigmaf
    REAL, DIMENSION(its:ite, kts:kte), INTENT(INOUT) :: eddyz
    REAL, DIMENSION(its:ite, kts:kte), INTENT(INOUT) :: g_eddyz
    REAL, DIMENSION(ims:ime, kms:kme), INTENT(IN) :: us, vs, theta, qvs&
&    , qcs, qis, densx
    REAL, DIMENSION(ims:ime, kms:kme), INTENT(IN) :: g_us, g_vs, g_theta&
&    , g_qvs, g_qcs, g_qis, g_densx
    REAL, DIMENSION(its:ite, kts:kte), INTENT(OUT) :: ux, vx, thetax, &
&    qvx, qcx, qix
    REAL, DIMENSION(its:ite, kts:kte), INTENT(OUT) :: g_ux, g_vx, &
&    g_thetax, g_qvx, g_qcx, g_qix
#if (WRF_CHEM == 1)
!......Chem
    INTEGER, INTENT(IN) :: nchem, kdvel, ndvel, num_vert_mix
    REAL, DIMENSION(ims:ime, kms:kme, nchem), INTENT(INOUT) :: chem
    REAL, DIMENSION(ims:ime, kms:kme, nchem), INTENT(INOUT) :: g_chem
    REAL, DIMENSION(ims:ime, kdvel, ndvel), INTENT(IN) :: vd
    REAL, DIMENSION(ims:ime, kdvel, ndvel), INTENT(IN) :: g_vd
#endif
!.......Local variables
!... Parameters
    INTEGER, PARAMETER :: nsp=6
!
!......ACM2 Parameters
!     INTEGER, PARAMETER :: IFACM = 0
!
    REAL, PARAMETER :: g1000=9.8d-3
! FACTOR APPLIED TO CONV MIXING TIME STEP
    REAL, PARAMETER :: xx=0.5D0
    REAL, PARAMETER :: karman=0.4D0
!... Integer
    INTEGER :: ilx, kl, klm, i, k, nspx, nlp, nl, jj, l, ll
    INTEGER :: kcblmx
    INTEGER, DIMENSION(its:ite) :: kcbl
!... Real
    REAL :: g1000i, mbmax, hovl, meddy, mbar
    REAL :: g_hovl, g_meddy, g_mbar
    REAL :: ekz, rz, fm, wspd, dts, dtrat, f1
    REAL :: g_fm, g_wspd, g_f1
    REAL, DIMENSION(its:ite) :: pstari, fsacm, dtlim
    REAL, DIMENSION(its:ite) :: g_pstari, g_fsacm
    REAL, DIMENSION(kts:kte, its:ite) :: mbarks, mdwn
    REAL, DIMENSION(kts:kte, its:ite) :: g_mbarks, g_mdwn
    REAL, DIMENSION(kts:kte) :: xplus, xminus
    REAL, DIMENSION(kts:kte) :: g_xplus, g_xminus
    REAL :: delc
    REAL :: g_delc
!, Y
    REAL, DIMENSION(kts:kte) :: ai, bi, ci, ei
    REAL, DIMENSION(kts:kte) :: g_ai, g_bi, g_ci, g_ei
    REAL, DIMENSION(:, :), ALLOCATABLE :: di, ui
    REAL, DIMENSION(:, :), ALLOCATABLE :: g_di, g_ui
    REAL, DIMENSION(:, :), ALLOCATABLE :: fs, bcbotn
    REAL, DIMENSION(:, :), ALLOCATABLE :: g_fs
    REAL, DIMENSION(:, :, :), ALLOCATABLE :: vci
    REAL, DIMENSION(:, :, :), ALLOCATABLE :: g_vci
    CHARACTER(len=80) :: message
    REAL :: arg1
    REAL :: g_arg1
    REAL :: result1
    REAL :: g_result1
    INTRINSIC INT
    INTRINSIC SQRT
!
!--Start Exicutable ----
    ilx = ite
    kl = kte
    klm = kte - 1
    nspx = nsp
#if (WRF_CHEM == 1)
    nspx = nspx + num_vert_mix
#endif
    g1000i = 1.0D0/g1000
    kcblmx = 0
    mbmax = 0.0D0
!...Allocate species variables
    ALLOCATE(g_di(1:nspx, kts:kte))
    ALLOCATE(di(1:nspx, kts:kte))
    ALLOCATE(g_ui(1:nspx, kts:kte))
    ALLOCATE(ui(1:nspx, kts:kte))
    ALLOCATE(g_fs(1:nspx, its:ite))
    ALLOCATE(fs(1:nspx, its:ite))
    ALLOCATE(bcbotn(1:nspx, its:ite))
    ALLOCATE(g_vci(1:nspx, its:ite, kts:kte))
    ALLOCATE(vci(1:nspx, its:ite, kts:kte))
    g_ui=0.0_8
    g_fs=0.0_8
    g_vci=0.0_8
    g_fsacm = 0.0_8
    g_mdwn = 0.0_8
    g_mbarks = 0.0_8
    g_pstari = 0.0_8
!---COMPUTE ACM MIXING RATE
    DO i=its,ilx
      dtlim(i) = dtpbl
      g_pstari(i) = -(g_pstar(i)/pstar(i)**2)
      pstari(i) = 1.0D0/pstar(i)
      kcbl(i) = 1
      g_fsacm(i) = 0.0_8
      fsacm(i) = 0.0D0
      IF (noconv(i) .EQ. 1) THEN
        kcbl(i) = klpbl(i)
!-------MBARKS IS UPWARD MIXING RATE; MDWN IS DOWNWARD MIXING RATE
!--New couple ACM & EDDY-------------------------------------------------------------
        g_hovl = -((g_pbl(i)*mol(i)-pbl(i)*g_mol(i))/mol(i)**2)
        hovl = -(pbl(i)/mol(i))
        g_fsacm(i) = -((-(0.3333D0*(karman/hovl)**(-0.6667D0)*g_hovl/(hovl**&
&          2*0.72D0)))/(1.+(karman/hovl)**0.3333D0/(0.72D0*karman))**2)
        fsacm(i) = 1./(1.+(karman/hovl)**0.3333D0/(0.72D0*karman))
        g_meddy = (g_eddyz(i, 1)*dtpbl*(pblsig(i)-sigmaf(1))-eddyz(i, 1)&
&          *dtpbl*g_pblsig(i))/(dtpbl*(pblsig(i)-sigmaf(1)))**2
        meddy = eddyz(i, 1)/(dtpbl*(pblsig(i)-sigmaf(1)))
        g_mbar = g_meddy*fsacm(i) + meddy*g_fsacm(i)
        mbar = meddy*fsacm(i)
        DO k=kts,kcbl(i)-1
          g_eddyz(i, k) = g_eddyz(i, k)*(1.0D0-fsacm(i)) - eddyz(i, k)*&
&            g_fsacm(i)
          eddyz(i, k) = eddyz(i, k)*(1.0D0-fsacm(i))
        END DO
        IF (mbmax .LT. mbar) THEN
          mbmax = mbar
        ELSE
          mbmax = mbmax
        END IF
        DO k=kts+1,kcbl(i)
          g_mbarks(k, i) = g_mbar
          mbarks(k, i) = mbar
          g_mdwn(k, i) = dsighi(k)*(g_mbar*(pblsig(i)-sigmaf(k-1))+mbar*&
&            g_pblsig(i))
          mdwn(k, i) = mbar*(pblsig(i)-sigmaf(k-1))*dsighi(k)
        END DO
        g_mbarks(1, i) = g_mbar
        mbarks(1, i) = mbar
        g_mbarks(kcbl(i), i) = g_mdwn(kcbl(i), i)
        mbarks(kcbl(i), i) = mdwn(kcbl(i), i)
        g_mdwn(kcbl(i)+1, i) = 0.0_8
        mdwn(kcbl(i)+1, i) = 0.0D0
      END IF
    END DO
! end of I loop
    DO k=kts,klm
      DO i=its,ilx
        ekz = eddyz(i, k)/dtpbl*dsighi(k)
        IF (0.75D0/ekz .GT. dtlim(i)) THEN
          dtlim(i) = dtlim(i)
        ELSE
          dtlim(i) = 0.75D0/ekz
        END IF
      END DO
    END DO
    DO i=its,ilx
      IF (noconv(i) .EQ. 1) THEN
        kcblmx = AMAX0(klpbl(i), kcblmx)
        rz = (sigmaf(kcbl(i))-sigmaf(1))*dsighi(1)
        IF (xx/(mbarks(1, i)*rz) .GT. dtlim(i)) THEN
          dtlim(i) = dtlim(i)
        ELSE
          dtlim(i) = xx/(mbarks(1, i)*rz)
        END IF
      END IF
    END DO
    DO k=kts,kl
      DO i=its,ilx
        g_vci(1, i, k) = g_theta(i, k)
        vci(1, i, k) = theta(i, k)
        g_vci(2, i, k) = g_qvs(i, k)
        vci(2, i, k) = qvs(i, k)
        g_vci(3, i, k) = g_us(i, k)
        vci(3, i, k) = us(i, k)
        g_vci(4, i, k) = g_vs(i, k)
        vci(4, i, k) = vs(i, k)
! -- Also mix cloud water and ice IF necessary
! IF (IMOISTX.NE.1.AND.IMOISTX.NE.3) THEN  !!! Check other PBL models
        g_vci(5, i, k) = g_qcs(i, k)
        vci(5, i, k) = qcs(i, k)
        g_vci(6, i, k) = g_qis(i, k)
        vci(6, i, k) = qis(i, k)

#if (WRF_CHEM == 1)
        DO l=7,nspx
          g_vci(l, i, k) = g_chem(i, k, l-nsp)
          vci(l, i, k) = chem(i, k, l-nsp)
        END DO
#endif
      END DO
    END DO
    DO i=its,ilx
      g_fs(1, i) = -((g_ust(i)*tst(i)+ust(i)*g_tst(i))*densx(i, 1)*&
&        pstari(i)+ust(i)*tst(i)*(g_densx(i, 1)*pstari(i)+densx(i, 1)*&
&        g_pstari(i)))
      fs(1, i) = -(ust(i)*tst(i)*densx(i, 1)*pstari(i))
      g_fs(2, i) = -((g_ust(i)*qst(i)+ust(i)*g_qst(i))*densx(i, 1)*&
&        pstari(i)+ust(i)*qst(i)*(g_densx(i, 1)*pstari(i)+densx(i, 1)*&
&        g_pstari(i)))
      fs(2, i) = -(ust(i)*qst(i)*densx(i, 1)*pstari(i))
      g_fm = -((g_ustm(i)*ustm(i)+ustm(i)*g_ustm(i))*densx(i, 1)*pstari(&
&        i)+ustm(i)**2*(g_densx(i, 1)*pstari(i)+densx(i, 1)*g_pstari(i)))
      fm = -(ustm(i)*ustm(i)*densx(i, 1)*pstari(i))
      g_arg1 = g_us(i, 1)*us(i, 1) + us(i, 1)*g_us(i, 1) + g_vs(i, 1)*vs&
&        (i, 1) + vs(i, 1)*g_vs(i, 1)
      arg1 = us(i, 1)*us(i, 1) + vs(i, 1)*vs(i, 1)
      IF (arg1 .EQ. 0.0_8) THEN
        g_result1 = 0.0_8
      ELSE
        g_result1 = g_arg1/(2.0D0*SQRT(arg1))
      END IF
      result1 = SQRT(arg1)
      g_wspd = g_result1
      wspd = result1 + 1.d-9
      g_fs(3, i) = ((g_fm*us(i, 1)+fm*g_us(i, 1))*wspd-fm*us(i, 1)*&
&        g_wspd)/wspd**2
      fs(3, i) = fm*us(i, 1)/wspd
      g_fs(4, i) = ((g_fm*vs(i, 1)+fm*g_vs(i, 1))*wspd-fm*vs(i, 1)*&
&        g_wspd)/wspd**2
      fs(4, i) = fm*vs(i, 1)/wspd
      g_fs(5, i) = 0.0_8
      fs(5, i) = 0.0D0
! SURFACE FLUXES OF CLOUD WATER AND ICE = 0
      g_fs(6, i) = 0.0_8
      fs(6, i) = 0.0D0
#if (WRF_CHEM == 1)
      DO l=7,nspx
        g_fs(l, i) = -((g_vd(i, 1, l-nsp)*chem(i, 1, l-nsp)+vd(i, 1, l-&
&          nsp)*g_chem(i, 1, l-nsp))*densx(i, 1)*pstari(i)+vd(i, 1, l-nsp&
&          )*chem(i, 1, l-nsp)*(g_densx(i, 1)*pstari(i)+densx(i, 1)*&
&          g_pstari(i)))
        fs(l, i) = -(vd(i, 1, l-nsp)*chem(i, 1, l-nsp)*densx(i, 1)*&
&          pstari(i))
      END DO
#endif
    END DO
    g_ai = 0.0_8
    g_xminus = 0.0_8
    g_ei = 0.0_8
    g_xplus = 0.0_8
    g_bi = 0.0_8
    g_ci = 0.0_8
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    DO i=its,ilx
      nlp = INT(dtpbl/dtlim(i) + 1.0D0)
      dts = dtpbl/nlp
      dtrat = dts/dtpbl
! LOOP OVER SUB TIME LOOP              
      DO nl=1,nlp
!-- COMPUTE ARRAY ELEMENTS THAT ARE INDEPENDANT OF SPECIES
        DO k=kts,kte
          g_ai(k) = 0.0_8
          ai(k) = 0.0D0
          g_bi(k) = 0.0_8
          bi(k) = 0.0D0
          g_ci(k) = 0.0_8
          ci(k) = 0.0D0
          g_ei(k) = 0.0_8
          ei(k) = 0.0D0
        END DO
        DO k=2,kcbl(i)
          g_ei(k-1) = -(crankp*dts*dsigh(k)*dsighi(k-1)*g_mdwn(k, i))
          ei(k-1) = -(crankp*mdwn(k, i)*dts*dsigh(k)*dsighi(k-1))
          g_bi(k) = crankp*dts*g_mdwn(k, i)
          bi(k) = 1.0D0 + crankp*mdwn(k, i)*dts
          g_ai(k) = -(crankp*dts*g_mbarks(k, i))
          ai(k) = -(crankp*mbarks(k, i)*dts)
        END DO
        g_ei(1) = g_ei(1) - crankp*dsighi(1)*dtrat*g_eddyz(i, 1)
        ei(1) = ei(1) - eddyz(i, 1)*crankp*dsighi(1)*dtrat
        g_ai(2) = g_ai(2) - crankp*dsighi(2)*dtrat*g_eddyz(i, 1)
        ai(2) = ai(2) - eddyz(i, 1)*crankp*dsighi(2)*dtrat
        DO k=kcbl(i)+1,kl
          g_bi(k) = 0.0_8
          bi(k) = 1.0D0
        END DO
        DO k=2,kl
          g_xplus(k) = dsighi(k)*dtrat*g_eddyz(i, k)
          xplus(k) = eddyz(i, k)*dsighi(k)*dtrat
          g_xminus(k) = dsighi(k)*dtrat*g_eddyz(i, k-1)
          xminus(k) = eddyz(i, k-1)*dsighi(k)*dtrat
          g_ci(k) = -(crankp*g_xminus(k))
          ci(k) = -(xminus(k)*crankp)
          g_ei(k) = g_ei(k) - crankp*g_xplus(k)
          ei(k) = ei(k) - xplus(k)*crankp
          g_bi(k) = g_bi(k) + crankp*g_xplus(k) + crankp*g_xminus(k)
          bi(k) = bi(k) + xplus(k)*crankp + xminus(k)*crankp
        END DO
        IF (noconv(i) .EQ. 1) THEN
          g_bi(1) = crankp*dts*dsighi(1)*(g_mbarks(1, i)*(pblsig(i)-&
&            sigmaf(1))+mbarks(1, i)*g_pblsig(i)) + dsighi(1)*crankp*&
&            dtrat*g_eddyz(i, 1)
          bi(1) = 1.0D0 + crankp*mbarks(1, i)*(pblsig(i)-sigmaf(1))*dts*&
&            dsighi(1) + eddyz(i, 1)*dsighi(1)*crankp*dtrat
        ELSE
          g_bi(1) = dsighi(1)*crankp*dtrat*g_eddyz(i, 1)
          bi(1) = 1.0D0 + eddyz(i, 1)*dsighi(1)*crankp*dtrat
        END IF
        DO k=1,kl
          DO l=1,nspx
            g_di(l, k) = 0.0_8
            di(l, k) = 0.0D0
          END DO
        END DO
!
!**   COMPUTE TENDENCY OF CBL CONCENTRATIONS - SEMI-IMPLICIT SOLUTION
        DO k=2,kcbl(i)
          DO l=1,nspx
            g_delc = dts*(g_mbarks(k, i)*vci(l, i, 1)+mbarks(k, i)*g_vci&
&              (l, i, 1)-g_mdwn(k, i)*vci(l, i, k)-mdwn(k, i)*g_vci(l, i&
&              , k)+dsigh(k+1)*dsighi(k)*(g_mdwn(k+1, i)*vci(l, i, k+1)+&
&              mdwn(k+1, i)*g_vci(l, i, k+1)))
            delc = dts*(mbarks(k, i)*vci(l, i, 1)-mdwn(k, i)*vci(l, i, k&
&              )+dsigh(k+1)*dsighi(k)*mdwn(k+1, i)*vci(l, i, k+1))
            g_di(l, k) = g_vci(l, i, k) + (1.0D0-crankp)*g_delc
            di(l, k) = vci(l, i, k) + (1.0D0-crankp)*delc
          END DO
        END DO
        DO k=kcbl(i)+1,kl
          DO l=1,nspx
            g_di(l, k) = g_vci(l, i, k)
            di(l, k) = vci(l, i, k)
          END DO
        END DO
        DO k=2,kl
          IF (k .EQ. kl) THEN
            DO l=1,nspx
              g_di(l, k) = g_di(l, k) - (1.0D0-crankp)*(g_xminus(k)*(vci(l&
&                , i, k)-vci(l, i, k-1))+xminus(k)*(g_vci(l, i, k)-g_vci(&
&                l, i, k-1)))
              di(l, k) = di(l, k) - (1.0D0-crankp)*xminus(k)*(vci(l, i, k)&
&                -vci(l, i, k-1))
            END DO
          ELSE
            DO l=1,nspx
              g_di(l, k) = g_di(l, k) + (1.0D0-crankp)*(g_xplus(k)*(vci(l&
&                , i, k+1)-vci(l, i, k))+xplus(k)*(g_vci(l, i, k+1)-g_vci&
&                (l, i, k))) - (1.0D0-crankp)*(g_xminus(k)*(vci(l, i, k)-&
&                vci(l, i, k-1))+xminus(k)*(g_vci(l, i, k)-g_vci(l, i, k-&
&                1)))
              di(l, k) = di(l, k) + (1.0D0-crankp)*xplus(k)*(vci(l, i, k+1&
&                )-vci(l, i, k)) - (1.0D0-crankp)*xminus(k)*(vci(l, i, k)-&
&                vci(l, i, k-1))
            END DO
          END IF
        END DO
        IF (noconv(i) .EQ. 1) THEN
          DO l=1,nspx
            g_f1 = -(g1000i*((g_mbarks(1, i)*(pblsig(i)-sigmaf(1))+&
&              mbarks(1, i)*g_pblsig(i))*vci(l, i, 1)+mbarks(1, i)*(&
&              pblsig(i)-sigmaf(1))*g_vci(l, i, 1)-dsigh(2)*(g_mdwn(2, i)&
&              *vci(l, i, 2)+mdwn(2, i)*g_vci(l, i, 2))))
            f1 = -(g1000i*(mbarks(1, i)*(pblsig(i)-sigmaf(1))*vci(l, i, &
&              1)-mdwn(2, i)*vci(l, i, 2)*dsigh(2)))
            g_di(l, 1) = g_vci(l, i, 1) - g1000*dsighi(1)*dts*(g_fs(l, i&
&              )-(1.0D0-crankp)*g_f1)
            di(l, 1) = vci(l, i, 1) - g1000*(fs(l, i)-(1.0D0-crankp)*f1)*&
&              dsighi(1)*dts
          END DO
        ELSE
          DO l=1,nspx
            g_di(l, 1) = g_vci(l, i, 1) - g1000*dsighi(1)*dts*g_fs(l, i)
            di(l, 1) = vci(l, i, 1) - g1000*fs(l, i)*dsighi(1)*dts
          END DO
        END IF
        DO l=1,nspx
          g_di(l, 1) = g_di(l, 1) + (1.0D0-crankp)*dsighi(1)*dtrat*(&
&            g_eddyz(i, 1)*(vci(l, i, 2)-vci(l, i, 1))+eddyz(i, 1)*(g_vci&
&            (l, i, 2)-g_vci(l, i, 1)))
          di(l, 1) = di(l, 1) + (1.0D0-crankp)*eddyz(i, 1)*dsighi(1)*dtrat&
&            *(vci(l, i, 2)-vci(l, i, 1))
        END DO
        IF (noconv(i) .EQ. 1) THEN
          CALL G_MATRIX(ai, g_ai, bi, g_bi, ci, g_ci, di, g_di, ei, g_ei&
&                  , ui, g_ui, kl, nspx)
        ELSE
          CALL G_TRI(ci, g_ci, bi, g_bi, ei, g_ei, di, g_di, ui, g_ui, &
&               kl, nspx)
        END IF
!
!-- COMPUTE NEW THETAV AND Q
        DO k=1,kl
          DO l=1,nspx
            g_vci(l, i, k) = g_ui(l, k)
            vci(l, i, k) = ui(l, k)
          END DO
        END DO
      END DO
    END DO
    g_ux = 0.0_8
    g_qix = 0.0_8
    g_qvx = 0.0_8
    g_vx = 0.0_8
    g_qcx = 0.0_8
    g_thetax = 0.0_8
! END I LOOP
! END SUB TIME LOOP
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
    DO k=kts,kl
      DO i=its,ilx
        g_thetax(i, k) = g_vci(1, i, k)
        thetax(i, k) = vci(1, i, k)
        g_qvx(i, k) = g_vci(2, i, k)
        qvx(i, k) = vci(2, i, k)
        g_ux(i, k) = g_vci(3, i, k)
        ux(i, k) = vci(3, i, k)
        g_vx(i, k) = g_vci(4, i, k)
        vx(i, k) = vci(4, i, k)
        g_qcx(i, k) = g_vci(5, i, k)
        qcx(i, k) = vci(5, i, k)
        g_qix(i, k) = g_vci(6, i, k)
        qix(i, k) = vci(6, i, k)
#if (WRF_CHEM == 1)
        DO ll=7,nspx
          g_chem(i, k, ll-nsp) = g_vci(ll, i, k)
          chem(i, k, ll-nsp) = vci(ll, i, k)
        END DO
#endif
      END DO
    END DO
    DEALLOCATE(g_di)
    DEALLOCATE(di)
    DEALLOCATE(g_ui)
    DEALLOCATE(ui)
    DEALLOCATE(g_fs)
    DEALLOCATE(fs)
    DEALLOCATE(bcbotn)
    DEALLOCATE(g_vci)
    DEALLOCATE(vci)
  END SUBROUTINE G_ACM

!  Differentiation of matrix in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: x
!   with respect to varying inputs: d e x a b c
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
  SUBROUTINE G_MATRIX(a, g_a, b, g_b, c, g_c, d, g_d, e, g_e, x, g_x, kl&
&    , nsp)
    IMPLICIT NONE
!
!-- Bordered band diagonal matrix solver for ACM2
!-- ACM2 Matrix is in this form:
!   B1 E1
!   A2 B2 E2
!   A3 C3 B3 E3
!   A4    C4 B4 E4
!   A5       C5 B5 E5
!   A6          C6 B6
!--Upper Matrix is
!  U11 U12
!      U22 U23
!          U33 U34
!              U44 U45
!                  U55 U56
!                      U66
!--Lower Matrix is:
!  1
! L21  1
! L31 L32  1
! L41 L42 L43  1
! L51 L52 L53 L54  1
! L61 L62 L63 L64 L65 1
!---------------------------------------------------------
!...Arguments
    INTEGER, INTENT(IN) :: kl
    INTEGER, INTENT(IN) :: nsp
    REAL :: a(kl), b(kl), e(kl)
    REAL :: g_a(kl), g_b(kl), g_e(kl)
    REAL :: c(kl), d(nsp, kl), x(nsp, kl)
    REAL :: g_c(kl), g_d(nsp, kl), g_x(nsp, kl)
!...Locals
    REAL :: y(nsp, kl), aij, sum
    REAL :: g_y(nsp, kl), g_aij, g_sum
    REAL :: l(kl, kl), uii(kl), uiip1(kl), ruii(kl)
    REAL :: g_l(kl, kl), g_uii(kl), g_uiip1(kl), g_ruii(kl)
    INTEGER :: i, j, v
!-- Define Upper and Lower matrices
    g_l(1, 1) = 0.0_8
    l(1, 1) = 1.D0
    g_uii = 0.0_8
    g_uii(1) = g_b(1)
    uii(1) = b(1)
    g_ruii = 0.0_8
    g_ruii(1) = -(g_uii(1)/uii(1)**2)
    ruii(1) = 1.D0/uii(1)
    g_l = 0.0_8
    g_uiip1 = 0.0_8
    DO i=2,kl
      g_l(i, i) = 0.0_8
      l(i, i) = 1.D0
      g_l(i, 1) = (g_a(i)*b(1)-a(i)*g_b(1))/b(1)**2
      l(i, 1) = a(i)/b(1)
      g_uiip1(i-1) = g_e(i-1)
      uiip1(i-1) = e(i-1)
      IF (i .GE. 3) THEN
        DO j=2,i-1
          IF (i .EQ. j + 1) THEN
            g_aij = g_c(i)
            aij = c(i)
          ELSE
            aij = 0.D0
            g_aij = 0.0_8
          END IF
          g_l(i, j) = ((g_aij-g_l(i, j-1)*e(j-1)-l(i, j-1)*g_e(j-1))*(b(&
&            j)-l(j, j-1)*e(j-1))-(aij-l(i, j-1)*e(j-1))*(g_b(j)-g_l(j, j&
&            -1)*e(j-1)-l(j, j-1)*g_e(j-1)))/(b(j)-l(j, j-1)*e(j-1))**2
          l(i, j) = (aij-l(i, j-1)*e(j-1))/(b(j)-l(j, j-1)*e(j-1))
        END DO
      END IF
    END DO
    DO i=2,kl
      g_uii(i) = g_b(i) - g_l(i, i-1)*e(i-1) - l(i, i-1)*g_e(i-1)
      uii(i) = b(i) - l(i, i-1)*e(i-1)
      g_ruii(i) = -(g_uii(i)/uii(i)**2)
      ruii(i) = 1.D0/uii(i)
    END DO
    g_y = 0.0_8
!-- Forward sub for Ly=d
    DO v=1,nsp
      g_y(v, 1) = g_d(v, 1)
      y(v, 1) = d(v, 1)
      DO i=2,kl
        g_sum = g_d(v, i)
        sum = d(v, i)
        DO j=1,i-1
          g_sum = g_sum - g_l(i, j)*y(v, j) - l(i, j)*g_y(v, j)
          sum = sum - l(i, j)*y(v, j)
        END DO
        g_y(v, i) = g_sum
        y(v, i) = sum
      END DO
    END DO
!-- Back sub for Ux=y
    DO v=1,nsp
      g_x(v, kl) = g_y(v, kl)*ruii(kl) + y(v, kl)*g_ruii(kl)
      x(v, kl) = y(v, kl)*ruii(kl)
    END DO
    DO i=kl-1,1,-1
      DO v=1,nsp
        g_x(v, i) = (g_y(v, i)-g_uiip1(i)*x(v, i+1)-uiip1(i)*g_x(v, i+1)&
&          )*ruii(i) + (y(v, i)-uiip1(i)*x(v, i+1))*g_ruii(i)
        x(v, i) = (y(v, i)-uiip1(i)*x(v, i+1))*ruii(i)
      END DO
    END DO
  END SUBROUTINE G_MATRIX

!  Differentiation of tri in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: x
!   with respect to varying inputs: d l u x b
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
  SUBROUTINE G_TRI(l, g_l, d, g_d, u, g_u, b, g_b, x, g_x, kl, nsp)
    IMPLICIT NONE
! Arguments:
    INTEGER, INTENT(IN) :: kl
    INTEGER, INTENT(IN) :: nsp
! subdiagonal
    REAL :: l(kl)
    REAL :: g_l(kl)
! diagonal
    REAL :: d(kl)
    REAL :: g_d(kl)
! superdiagonal
    REAL :: u(kl)
    REAL :: g_u(kl)
! R.H. side
    REAL :: b(nsp, kl)
    REAL :: g_b(nsp, kl)
! solution
    REAL :: x(nsp, kl)
    REAL :: g_x(nsp, kl)
! Local Variables:
    REAL :: gam(kl)
    REAL :: g_gam(kl)
    REAL :: bet
    REAL :: g_bet
    INTEGER :: v, k
! Decomposition and forward substitution:
    g_bet = -(g_d(1)/d(1)**2)
    bet = 1.0/d(1)
    DO v=1,nsp
      g_x(v, 1) = g_bet*b(v, 1) + bet*g_b(v, 1)
      x(v, 1) = bet*b(v, 1)
    END DO
    g_gam = 0.0_8
    DO k=2,kl
      g_gam(k) = g_bet*u(k-1) + bet*g_u(k-1)
      gam(k) = bet*u(k-1)
      g_bet = -((g_d(k)-g_l(k)*gam(k)-l(k)*g_gam(k))/(d(k)-l(k)*gam(k))&
&        **2)
      bet = 1.0D0/(d(k)-l(k)*gam(k))
      DO v=1,nsp
        g_x(v, k) = g_bet*(b(v, k)-l(k)*x(v, k-1)) + bet*(g_b(v, k)-g_l(&
&          k)*x(v, k-1)-l(k)*g_x(v, k-1))
        x(v, k) = bet*(b(v, k)-l(k)*x(v, k-1))
      END DO
    END DO
! Back-substitution:
    DO k=kl-1,1,-1
      DO v=1,nsp
        g_x(v, k) = g_x(v, k) - g_gam(k+1)*x(v, k+1) - gam(k+1)*g_x(v, k&
&          +1)
        x(v, k) = x(v, k) - gam(k+1)*x(v, k+1)
      END DO
    END DO
  END SUBROUTINE G_TRI

!  Differentiation of acminit in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: rublten rqvblten rvblten rqcblten
!                rthblten rqiblten
!   with respect to varying inputs: rublten rqvblten rvblten rqcblten
!                rthblten rqiblten
!   RW status of diff variables: rublten:in-out rqvblten:in-out
!                rvblten:in-out rqcblten:in-out rthblten:in-out
!                rqiblten:in-out
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
  SUBROUTINE G_ACMINIT(rublten, g_rublten, rvblten, g_rvblten, rthblten&
&    , g_rthblten, rqvblten, g_rqvblten, rqcblten, g_rqcblten, rqiblten, &
&    g_rqiblten, p_qi, p_first_scalar, restart, allowed_to_read, ids, ide&
&    , jds, jde, kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, &
&    jte, kts, kte)
    IMPLICIT NONE
!
    LOGICAL, INTENT(IN) :: restart, allowed_to_read
    INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, its, ite, jts, jte, kts, kte
    INTEGER, INTENT(IN) :: p_qi, p_first_scalar
!   REAL , DIMENSION( kms:kme ), INTENT(IN)  :: SHALF
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(OUT) :: rublten, &
&    rvblten, rthblten, rqvblten, rqcblten, rqiblten
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(OUT) :: g_rublten&
&    , g_rvblten, g_rthblten, g_rqvblten, g_rqcblten, g_rqiblten
!... Local Variables
    INTEGER :: i, j, k, itf, jtf, ktf
    IF (jte .GT. jde - 1) THEN
      jtf = jde - 1
    ELSE
      jtf = jte
    END IF
    IF (kte .GT. kde - 1) THEN
      ktf = kde - 1
    ELSE
      ktf = kte
    END IF
    IF (ite .GT. ide - 1) THEN
      itf = ide - 1
    ELSE
      itf = ite
    END IF
    IF (.NOT.restart) THEN
      DO j=jts,jtf
        DO k=kts,ktf
          DO i=its,itf
            g_rublten(i, k, j) = 0.0_8
            rublten(i, k, j) = 0.D0
            g_rvblten(i, k, j) = 0.0_8
            rvblten(i, k, j) = 0.D0
            g_rthblten(i, k, j) = 0.0_8
            rthblten(i, k, j) = 0.D0
            g_rqvblten(i, k, j) = 0.0_8
            rqvblten(i, k, j) = 0.D0
            g_rqcblten(i, k, j) = 0.0_8
            rqcblten(i, k, j) = 0.D0
          END DO
        END DO
      END DO
    END IF
    IF (p_qi .GE. p_first_scalar .AND. (.NOT.restart)) THEN
      DO j=jts,jtf
        DO k=kts,ktf
          DO i=its,itf
            g_rqiblten(i, k, j) = 0.0_8
            rqiblten(i, k, j) = 0.D0
          END DO
        END DO
      END DO
    END IF
  END SUBROUTINE G_ACMINIT
END MODULE G_MODULE_BL_ACM
