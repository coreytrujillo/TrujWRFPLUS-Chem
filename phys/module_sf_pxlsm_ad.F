!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.6 (r4756) - 12 Feb 2013 10:43
!
MODULE A_MODULE_SF_PXLSM
  USE module_sf_pxlsm_data
  USE module_sf_pxlsm, only: PXSNOW, VEGELAND, SOILPROP, QFLUX, SMASS, SURFPX

  USE module_model_constants
  IMPLICIT NONE
!------------------------------------------------------------------------------------------
!------------------------------------------------------------------------------------------
  INTEGER, PARAMETER :: nsold=20
  REAL, PARAMETER :: rd=287.04D0, cpd=1004.67D0, cph2o=4.218d+3, cpice=&
&    2.106d+3, lsubf=3.335d+5, sigma=5.67d-8, rovcp=rd/cpd
! CRANK-NIC PARAMETER
  REAL, PARAMETER :: crankp=0.5D0
! critical Richardson number
  REAL, PARAMETER :: ric=0.25D0
! water density in KG/M3                  
  REAL, PARAMETER :: denw=1000.0D0
! 1/1DAY(SEC)
  REAL, PARAMETER :: tauinv=1.0D0/86400.0D0
! Bottom soil temp response factor
  REAL, PARAMETER :: t2tfac=1.0D0/10.0D0
  REAL, PARAMETER :: pi=3.1415926535897932384626433
  REAL, PARAMETER :: pr0=0.95D0
  REAL, PARAMETER :: czo=0.032D0
  REAL, PARAMETER :: ozo=1.d-4

CONTAINS
!  Differentiation of pxlsm in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: lai capg tslb ust pblh hfx
!                vegf_px tsk t3d qv3d znt psfc rmol qfx smois th3d
!                canwat rho dz8w
!   with respect to varying inputs: lai capg tslb ust pblh hfx
!                vegf_px tsk t3d qv3d znt psfc rmol qfx smois th3d
!                canwat rho dz8w
!
!-------------------------------------------------------------------------
!-------------------------------------------------------------------------
  SUBROUTINE A_PXLSM(u3d, v3d, dz8w, a_dz8w, qv3d, a_qv3d, t3d, a_t3d, &
&    th3d, a_th3d, rho, a_rho, psfc, a_psfc, gsw, glw, rainbl, emiss, &
&    itimestep, curr_secs, nsoil, dt, anal_interval, xland, xice, albbck&
&    , albedo, snoalb, smois, a_smois, tslb, a_tslb, mavail, ta2, qa2, zs&
&    , dzs, psih, landusef, soilctop, soilcbot, vegfra, vegf_px, &
&    a_vegf_px, isltyp, ra, rs, lai, a_lai, nlcat, nscat, hfx, a_hfx, qfx&
&    , a_qfx, lh, tsk, a_tsk, sst, znt, a_znt, canwat, a_canwat, grdflx, &
&    shdmin, shdmax, snowc, pblh, a_pblh, rmol, a_rmol, ust, a_ust, capg&
&    , a_capg, dtbl, t2_ndg_old, t2_ndg_new, q2_ndg_old, q2_ndg_new, &
&    sn_ndg_old, sn_ndg_new, snow, snowh, snowncv, t2obs, q2obs, &
&    pxlsm_smois_init, pxlsm_soil_nudge, ids, ide, jds, jde, kds, kde, &
&    ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte)
    IMPLICIT NONE
!------------------------------------------------------
!.......Arguments
! DECLARATIONS - INTEGER
    INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, its, ite, jts, jte, kts, kte
    INTEGER, INTENT(IN) :: nsoil, itimestep, nlcat, nscat, anal_interval&
&    , pxlsm_smois_init, pxlsm_soil_nudge
    REAL, INTENT(IN), OPTIONAL :: curr_secs
    REAL, INTENT(IN) :: dt, dtbl
    INTEGER, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: isltyp
! DECLARATIONS - REAL
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: u3d, v3d, &
&    rho, t3d, th3d, dz8w, qv3d
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_rho, a_t3d, a_th3d, &
&    a_dz8w, a_qv3d
    REAL, DIMENSION(nsoil), INTENT(IN) :: zs, dzs
    REAL, DIMENSION(ims:ime, nsoil, jms:jme), INTENT(INOUT) :: smois, &
&    tslb
    REAL, DIMENSION(ims:ime, nsoil, jms:jme), INTENT(INOUT) :: a_smois
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: ra, rs, lai, znt
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_lai
    REAL, DIMENSION(ims:ime, jms:jme) :: grdflx, tsk, ta2, qa2
    REAL, DIMENSION(ims:ime, jms:jme) :: a_tsk
    REAL, DIMENSION(ims:ime, nlcat, jms:jme), INTENT(IN) :: landusef
    REAL, DIMENSION(ims:ime, nscat, jms:jme), INTENT(IN) :: soilctop, &
&    soilcbot
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: psfc, gsw, glw, &
&    rainbl, emiss, snoalb, albbck, shdmin, shdmax, pblh, rmol, snowncv, &
&    ust, mavail, sst
    REAL, DIMENSION(ims:ime, jms:jme) :: a_psfc, a_pblh, a_rmol, a_ust
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: t2_ndg_old, &
&    t2_ndg_new, q2_ndg_old, q2_ndg_new, sn_ndg_old, sn_ndg_new
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(OUT) :: t2obs
    REAL, DIMENSION(ims:ime, jms:jme) :: q2obs

    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: capg, canwat, &
&    qfx, hfx, lh, psih, vegfra, vegf_px, snow, snowh, snowc, albedo, &
&    xland, xice
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_capg
    LOGICAL :: radiation
!-------------------------------------------------------------------------
!     ---------- Local Variables --------------------------------
!----  PARAMETERS
! max. soil types
    INTEGER, PARAMETER :: nstps=11
! Max PX timestep = 40 sec
    REAL, PARAMETER :: dtpblx=40.0D0
!----  INTEGERS
    INTEGER, DIMENSION(nstps) :: jp
    INTEGER :: j, i, ns, nudge, isti, weight
    INTEGER :: ntsps, it
!----  REALS
    REAL, DIMENSION(ims:ime, jms:jme) :: xlai, xlaimn, rstmin, xveg, &
&    xvegmn, xsnup, xalb
    REAL, DIMENSION(ims:ime, jms:jme) :: radnet, eg, er, etr, qst
    REAL :: sfcprs, ta1, dens1, qv1, zlvl, soldn, lwdn, emissi, precip, &
&    theta1, vapprs, qsbt, wg, w2, wr, tg, t2, ustar, molx, z0, rair, &
&    cpair, ifland, isnow, es, qss, betap, rh2_old, rh2_new, t2_old, &
&    t2_new, core, corb, time_between_analysis, g1000, aln10, rh2obs, hu&
&    , snobs, fwsat, fwfc, fwwlt, fb, fcgsat, fjp, fas, fseas, t2i, &
&    hc_snow, snow_fra, snowalb, qst12, zfunc, zf1, za2, qv2, dt_fdda, &
&    fc2r, fc1sat, dtpbl
    REAL :: a_sfcprs, a_ta1, a_dens1, a_qv1, a_zlvl, a_theta1, a_qsbt, &
&    a_wr, a_ustar, a_molx, a_z0, a_cpair, a_es, a_qss, a_betap, &
&    a_rh2_old, a_rh2_new, a_rh2obs, a_fseas, a_t2i, a_qst12, a_zfunc, &
&    a_zf1, a_za2, a_qv2
    CHARACTER(len=6) :: land_use_type
    INTEGER :: branch
    INTEGER :: ad_to
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_hfx
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_canwat
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_vegf_px
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_znt
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_qfx
    REAL, DIMENSION(ims:ime, nsoil, jms:jme), INTENT(INOUT) :: a_tslb
    REAL :: temp3
    REAL :: temp2
    REAL :: temp1
    REAL :: temp0
    REAL :: temp0b
    REAL :: temp2b
    REAL :: temp4b
    REAL :: temp0b0
    REAL :: a_max1
    REAL :: temp4b0
    REAL :: tempb
    REAL :: temp
    REAL :: max2
    REAL :: temp4
!-------------------------------------------------------------------------
!-------------------------------Executable starts here--------------------
!
! G/1000
    weight = 0
! Determine Landuse Dataset by the number of categories
    IF (nlcat .EQ. 50) THEN
      land_use_type = 'NLCD50'
    ELSE IF (nlcat .EQ. 40) THEN
      land_use_type = 'NLCD40'
    ELSE IF (nlcat .EQ. 20) THEN
      land_use_type = 'MODIS'
    ELSE IF (nlcat .EQ. 24) THEN
      land_use_type = 'USGS'
    END IF
!-----------------------------------------------------------------------------------
! Kill WRF if user specifies soil nudging but provides no analysis interval, then provide helpful message.
    IF (anal_interval .LE. 0.0 .AND. pxlsm_soil_nudge .EQ. 1) THEN
      STOP
    ELSE
!-----------------------------------------------------------------------------------
!--- Compute time relatve to old and new analysis time for timestep interpolation
      IF (pxlsm_soil_nudge .EQ. 1) THEN
! Convert DT of Analysis to real 
        dt_fdda = anal_interval*1.0D0
        time_between_analysis = MOD(curr_secs, dt_fdda)
        IF (time_between_analysis .EQ. 0.0) THEN
          corb = 1.0D0
          core = 0.0D0
        ELSE
          core = time_between_analysis/dt_fdda
          corb = 1.0D0 - core
        END IF
      END IF
      CALL PUSHREAL8ARRAY(xland, (ime-ims+1)*(jme-jms+1))
      CALL VEGELAND(landusef, vegfra, shdmin, shdmax, soilctop, soilcbot&
&              , nlcat, nscat, znt, xlai, xlaimn, rstmin, xveg, xvegmn, &
&              xsnup, xland, xalb, ids, ide, jds, jde, kds, kde, ims, ime&
&              , jms, jme, kms, kme, its, ite, jts, jte, kts, kte, &
&              land_use_type)
!-----------------------------------------------------------------------------------
! Compute vegetation and land-use characteristics by land-use fraction weighting
! These parameters include LAI, VEGF, ZNT, ALBEDO, RS, etc.
!-----------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------
! Main loop over individual grid cells
!-- J LOOP
      DO j=jts,jte
!-- I LOOP
        DO i=its,ite
          CALL PUSHREAL8(ifland)
          ifland = xland(i, j)
! Compute soil properties via weighting of fractional components
          IF (ifland .LT. 1.5) THEN
            CALL PUSHREAL8(fc1sat)
            CALL PUSHREAL8(fc2r)
            CALL PUSHREAL8(fas)
            CALL PUSHREAL8(fjp)
            CALL PUSHREAL8(fcgsat)
            CALL PUSHREAL8(fb)
            CALL PUSHREAL8(fwwlt)
            CALL PUSHREAL8(fwfc)
            CALL PUSHREAL8(fwsat)
!---------------------------------------------------------
            CALL SOILPROP(soilcbot(i, :, j), weight, itimestep, mavail(i&
&                    , j), pxlsm_smois_init, fwsat, fwfc, fwwlt, fb, &
&                    fcgsat, fjp, fas, fc2r, fc1sat, isti, smois(i, 2, j)&
&                   )
!----------------------------------------------------------
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
!--  Variables Sub. SURFPX needs
! surface pressure in cb
          sfcprs = psfc(i, j)/1000.0D0
! air temperature at first layer
          ta1 = t3d(i, 1, j)
! air density at first layer
          dens1 = rho(i, 1, j)
! water vapor mixing ratio at first layer
          qv1 = qv3d(i, 1, j)
          qv2 = qv3d(i, 2, j)
! thickness of lowest half level
          zlvl = 0.5D0*dz8w(i, 1, j)
          zf1 = dz8w(i, 1, j)
          za2 = zf1 + 0.5D0*dz8w(i, 2, j)
! longwave radiation
          lwdn = glw(i, j)
! emissivity
          emissi = emiss(i, j)
          IF (1.0d-3*rainbl(i, j)/dtbl .LT. 0.0) THEN
            CALL PUSHREAL8(precip)
            precip = 0.0D0
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHREAL8(precip)
            precip = 1.0d-3*rainbl(i, j)/dtbl
            CALL PUSHCONTROL1B(1)
          END IF
! convert RAINBL from mm to m for PXLSM
! convert CANWAT from mm to m for PXLSM
          wr = 1.0d-3*canwat(i, j)
! potential temp at first layer
          theta1 = th3d(i, 1, j)
! Set snow cover to existing model value
          snobs = snow(i, j)
!   this is overwritten below if snow analysis is availiable
!   otherwise snow cover remains constant through simulation
          IF (pxlsm_soil_nudge .EQ. 1) THEN
!-- 2 m Temp and RH for Nudging
            t2_old = t2_ndg_old(i, j)
            t2_new = t2_ndg_new(i, j)
            CALL PUSHREAL8(vapprs)
            vapprs = svp1*EXP(svp2*(t2_old-svpt0)/(t2_old-svp3))
            CALL PUSHREAL8(qsbt)
            qsbt = ep_2*vapprs/(sfcprs-vapprs)
            rh2_old = q2_ndg_old(i, j)/qsbt
            CALL PUSHREAL8(vapprs)
            vapprs = svp1*EXP(svp2*(t2_new-svpt0)/(t2_new-svp3))
            CALL PUSHREAL8(qsbt)
            qsbt = ep_2*vapprs/(sfcprs-vapprs)
            rh2_new = q2_ndg_new(i, j)/qsbt
            CALL PUSHREAL8(rh2obs)
            rh2obs = corb*rh2_old + core*rh2_new
            t2obs(i, j) = corb*t2_old + core*t2_new
            snobs = corb*sn_ndg_old(i, j) + core*sn_ndg_new(i, j)
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
          IF (ust(i, j) .LT. 0.005) THEN
            CALL PUSHREAL8(ustar)
            ustar = 0.005D0
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHREAL8(ustar)
            ustar = ust(i, j)
            CALL PUSHCONTROL1B(1)
          END IF
          IF (ifland .GT. 1.5) THEN
! if over water                            
            znt(i, j) = czo*ust(i, j)*ust(i, j)/g + ozo
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          CALL PUSHREAL8(z0)
          z0 = znt(i, j)
! J/(K KG)
          cpair = cpd*(1.0D0+0.84D0*qv1)
          CALL PUSHREAL8(snowc(i, j))
          CALL PUSHREAL8(snow_fra)
!-------------------------------------------------------------
! Compute fractional snow area and snow albedo
          CALL PXSNOW(itimestep, snobs, snowncv(i, j), snow(i, j), snowh&
&                (i, j), xsnup(i, j), xalb(i, j), snoalb(i, j), vegf_px(i&
&                , j), shdmin(i, j), hc_snow, snow_fra, snowc(i, j), &
&                albedo(i, j))
!-------------------------------------------------------------
!-------------------------------------------------------------
! Sea Ice from analysis and water cells that are very cold, but more than 50% water
! are converted to ice/snow for more reasonable treatment.
          IF (xice(i, j) .GE. 0.5D0 .OR. (sst(i, j) .LE. 270.0D0 .AND. xland&
&              (i, j) .GT. 1.50)) THEN
            ifland = 1.0D0
!  Ice
! FWSAT
            smois(i, 1, j) = 1.0D0
! FWSAT
            smois(i, 2, j) = 1.0D0
            xice(i, j) = 1.0D0
            albedo(i, j) = 0.7D0
            snowc(i, j) = 1.0D0
            snow_fra = 1.0D0
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
          CALL PUSHREAL8(t2i)
!-------------------------------------------------------------
!-------------------------------------------------------------
!-- Note that when IFGROW = 0 is selected in Vegeland then max and min           
!-- LAI and Veg are the same                                                     
          t2i = tslb(i, 2, j)
          IF (1.0D0 - 0.015625D0*(290.0D0-t2i)**2 .LT. 0.0D0) THEN
            fseas = 0.0D0
            CALL PUSHCONTROL1B(0)
          ELSE
            fseas = 1.0D0 - 0.015625D0*(290.0D0-t2i)**2
            CALL PUSHCONTROL1B(1)
          END IF
          IF (t2i .GE. 290.0) THEN
            fseas = 1.0D0
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          lai(i, j) = xlaimn(i, j) + fseas*(xlai(i, j)-xlaimn(i, j))
          vegf_px(i, j) = xvegmn(i, j) + fseas*(xveg(i, j)-xvegmn(i, j))
! Ensure veg algorithms not used for water 
          IF (ifland .GT. 1.5) THEN
            vegf_px(i, j) = 0.0
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
!-------------------------------------------------------------
! downward shortwave radiaton
          soldn = gsw(i, j)/(1.0D0-albedo(i, j))
          isnow = snowc(i, j)
          CALL PUSHINTEGER4(nudge)
          nudge = pxlsm_soil_nudge
          IF (j .LE. 2 .OR. j .GE. jde - 1) nudge = 0
          IF (i .LE. 2 .OR. i .GE. ide - 1) nudge = 0
          IF (rmol(i, j) .GT. 0.0) THEN
            IF (1.D0/rmol(i, j) .GT. 1000.0D0) THEN
              CALL PUSHREAL8(molx)
              molx = 1000.0D0
              CALL PUSHCONTROL3B(2)
            ELSE
              CALL PUSHREAL8(molx)
              molx = 1.D0/rmol(i, j)
              CALL PUSHCONTROL3B(1)
            END IF
          ELSE IF (rmol(i, j) .LT. 0.0) THEN
            IF (1.D0/rmol(i, j) .LT. -1000.0D0) THEN
              CALL PUSHREAL8(molx)
              molx = -1000.0D0
              CALL PUSHCONTROL3B(4)
            ELSE
              CALL PUSHREAL8(molx)
              molx = 1.D0/rmol(i, j)
              CALL PUSHCONTROL3B(3)
            END IF
          ELSE
            CALL PUSHREAL8(molx)
            molx = 1000.D0
            CALL PUSHCONTROL3B(0)
          END IF
          IF (100. .LT. pblh(i, j)) THEN
            CALL PUSHREAL8(max2)
            max2 = pblh(i, j)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHREAL8(max2)
            max2 = 100.D0
            CALL PUSHCONTROL1B(1)
          END IF
          zfunc = zf1*(1.0D0-zf1/max2)**2
          qst12 = karman*zfunc*(qv2-qv1)/(za2-zlvl)
!--- LSM sub-time loop too prevent dt > 40 sec       
          ntsps = INT(dt/(dtpblx+0.000001D0) + 1.0D0)
          CALL PUSHREAL8(dtpbl)
          dtpbl = dt/ntsps
          DO it=1,ntsps
!... SATURATION VAPOR PRESSURE (MB) 
            IF (tslb(i, 1, j) .LE. svpt0) THEN
              CALL PUSHREAL8(es)
! For ground that is below freezing
! cb
              es = svp1*EXP(22.514D0-6.15d3/tslb(i, 1, j))
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREAL8(es)
              es = svp1*EXP(svp2*(tslb(i, 1, j)-svpt0)/(tslb(i, 1, j)-&
&                svp3))
              CALL PUSHCONTROL1B(1)
            END IF
            qss = es*0.622D0/(sfcprs-es)
!... beta method, Lee & Pielke (JAM,May1992)
            betap = 1.0D0
            IF (ifland .LT. 1.5 .AND. isnow .LT. 0.5 .AND. smois(i, 1, j&
&                ) .LE. fwfc) THEN
              betap = 0.25D0*(1.0D0-COS(smois(i, 1, j)/fwfc*pi))**2
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            CALL PUSHREAL8(wr)
            CALL PUSHREAL8(smois(i, 2, j))
            CALL PUSHREAL8(smois(i, 1, j))
            CALL PUSHREAL8(tslb(i, 2, j))
            CALL PUSHREAL8(tslb(i, 1, j))
            CALL PUSHREAL8(betap)
!-------------------------------------------------------------------------
            CALL SURFPX(dtpbl, ifland, snowc(i, j), nudge, xice(i, j), &
&                  soldn, gsw(i, j), lwdn, emissi, zlvl, molx, z0, ustar&
&                  , sfcprs, dens1, qv1, qss, ta1, theta1, precip, cpair&
&                  , psih(i, j), rh2obs, t2obs(i, j), vegf_px(i, j), isti&
&                  , lai(i, j), betap, rstmin(i, j), hc_snow, snow_fra, &
&                  fwwlt, fwfc, fcgsat, fwsat, fb, fc1sat, fc2r, fas, fjp&
&                  , dzs(1), dzs(2), qst12, radnet(i, j), grdflx(i, j), &
&                  hfx(i, j), qfx(i, j), lh(i, j), eg(i, j), er(i, j), &
&                  etr(i, j), qst(i, j), capg(i, j), rs(i, j), ra(i, j), &
&                  tslb(i, 1, j), tslb(i, 2, j), smois(i, 1, j), smois(i&
&                  , 2, j), wr, ta2(i, j), qa2(i, j), land_use_type)
          END DO
          CALL PUSHINTEGER4(it - 1)
        END DO
      END DO
      a_rh2obs = 0.0_8
      DO j=jte,jts,-1
        DO i=ite,its,-1
          a_wr = 1000.D0*a_canwat(i, j)
          a_canwat(i, j) = 0.0_8
          a_tslb(i, 1, j) = a_tslb(i, 1, j) + a_tsk(i, j)
          a_tsk(i, j) = 0.0_8


!Recalculate Input Variables (may not be needed)
          qv1 = qv3d(i, 1, j)
          qv2 = qv3d(i, 2, j)
          sfcprs = psfc(i, j)/1000.0D0
          soldn = gsw(i, j)/(1.0D0-albedo(i, j))
          dens1 = rho(i, 1, j)
          theta1 = th3d(i, 1, j)
          ta1 = t3d(i, 1, j)
          zf1 = dz8w(i, 1, j)
          zlvl = 0.5D0*dz8w(i, 1, j)
          cpair = cpd*(1.0D0+0.84D0*qv1)
          zfunc = zf1*(1.0D0-zf1/max2)**2
          za2 = zf1 + 0.5D0*dz8w(i, 2, j)
          qst12 = karman*zfunc*(qv2-qv1)/(za2-zlvl)
          emissi = emiss(i, j)
          lwdn = glw(i, j)



          a_qv1 = 0.0_8
          a_sfcprs = 0.0_8
          a_dens1 = 0.0_8
          a_ustar = 0.0_8
          a_theta1 = 0.0_8
          a_z0 = 0.0_8
          a_ta1 = 0.0_8
          a_zlvl = 0.0_8
          a_cpair = 0.0_8
          a_molx = 0.0_8
          a_qst12 = 0.0_8
          CALL POPINTEGER4(ad_to)
          DO it=ad_to,1,-1
            qss = es*0.622D0/(sfcprs-es)
            CALL POPREAL8(betap)
            CALL POPREAL8(tslb(i, 1, j))
            CALL POPREAL8(tslb(i, 2, j))
            CALL POPREAL8(smois(i, 1, j))
            CALL POPREAL8(smois(i, 2, j))
            CALL POPREAL8(wr)
            CALL A_SURFPX(dtpbl, ifland, snowc(i, j), nudge, xice(i, j)&
&                    , soldn, gsw(i, j), lwdn, emissi, zlvl, a_zlvl, molx&
&                    , a_molx, z0, a_z0, ustar, a_ustar, sfcprs, a_sfcprs&
&                    , dens1, a_dens1, qv1, a_qv1, qss, a_qss, ta1, a_ta1&
&                    , theta1, a_theta1, precip, cpair, a_cpair, psih(i, &
&                    j), rh2obs, a_rh2obs, t2obs(i, j), vegf_px(i, j), &
&                    a_vegf_px(i, j), isti, lai(i, j), a_lai(i, j), betap&
&                    , a_betap, rstmin(i, j), hc_snow, snow_fra, fwwlt, &
&                    fwfc, fcgsat, fwsat, fb, fc1sat, fc2r, fas, fjp, dzs&
&                    (1), dzs(2), qst12, a_qst12, radnet(i, j), grdflx(i&
&                    , j), hfx(i, j), a_hfx(i, j), qfx(i, j), a_qfx(i, j)&
&                    , lh(i, j), eg(i, j), er(i, j), etr(i, j), qst(i, j)&
&                    , capg(i, j), a_capg(i, j), rs(i, j), ra(i, j), tslb&
&                    (i, 1, j), a_tslb(i, 1, j), tslb(i, 2, j), a_tslb(i&
&                    , 2, j), smois(i, 1, j), a_smois(i, 1, j), smois(i, &
&                    2, j), a_smois(i, 2, j), wr, a_wr, ta2(i, j), qa2(i&
&                    , j), land_use_type,i,j)
            a_hfx(i, j) = 0.0_8
            a_qfx(i, j) = 0.0_8
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              temp4 = pi*smois(i, 1, j)/fwfc
              a_smois(i, 1, j) = a_smois(i, 1, j) + pi*SIN(temp4)*2*(1.0D0&
&                -COS(temp4))*0.25D0*a_betap/fwfc
            END IF
            temp4b = 0.622D0*a_qss/(sfcprs-es)
            temp4b0 = -(es*temp4b/(sfcprs-es))
            a_es = temp4b - temp4b0
            a_sfcprs = a_sfcprs + temp4b0
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREAL8(es)
              temp1 = tslb(i, 1, j)
              temp0 = 6.15d3/temp1
              a_tslb(i, 1, j) = a_tslb(i, 1, j) + EXP(22.514D0-temp0)*svp1&
&                *temp0*a_es/temp1
            ELSE
              CALL POPREAL8(es)
              temp3 = tslb(i, 1, j) - svp3
              temp2 = (tslb(i, 1, j)-svpt0)/temp3
              temp2b = svp2*EXP(svp2*temp2)*svp1*a_es/temp3
              a_tslb(i, 1, j) = a_tslb(i, 1, j) + (1.0D0-temp2)*temp2b
            END IF
          END DO
          CALL POPREAL8(dtpbl)
          temp0b = karman*a_qst12/(za2-zlvl)
          temp0b0 = -(zfunc*(qv2-qv1)*temp0b/(za2-zlvl))
          a_zfunc = (qv2-qv1)*temp0b
          a_qv2 = zfunc*temp0b
          a_qv1 = a_qv1 - zfunc*temp0b
          a_za2 = temp0b0
          a_zlvl = a_zlvl - temp0b0
          temp = zf1/max2
          tempb = -(2.D0*(1.0D0-temp)*zf1*a_zfunc/max2)
          a_zf1 = tempb + (1.0D0-temp)**2*a_zfunc
          a_max1 = -(temp*tempb)
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL8(max2)
            a_pblh(i, j) = a_pblh(i, j) + a_max1
          ELSE
            CALL POPREAL8(max2)
          END IF
          CALL POPCONTROL3B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              CALL POPREAL8(molx)
            ELSE
              CALL POPREAL8(molx)
              a_rmol(i, j) = a_rmol(i, j) - a_molx/rmol(i, j)**2
            END IF
          ELSE IF (branch .EQ. 2) THEN
            CALL POPREAL8(molx)
          ELSE IF (branch .EQ. 3) THEN
            CALL POPREAL8(molx)
            a_rmol(i, j) = a_rmol(i, j) - a_molx/rmol(i, j)**2
          ELSE
            CALL POPREAL8(molx)
          END IF
          CALL POPINTEGER4(nudge)
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) a_vegf_px(i, j) = 0.0_8
          a_fseas = (xlai(i, j)-xlaimn(i, j))*a_lai(i, j) + (xveg(i, j)-&
&            xvegmn(i, j))*a_vegf_px(i, j)
          a_vegf_px(i, j) = 0.0_8
          a_lai(i, j) = 0.0_8
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) a_fseas = 0.0_8
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            a_t2i = 0.0_8
          ELSE
            a_t2i = 2.D0*(290.0D0-t2i)*0.015625D0*a_fseas
          END IF
          CALL POPREAL8(t2i)
          a_tslb(i, 2, j) = a_tslb(i, 2, j) + a_t2i
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            a_lai(i, j) = 0.0_8
            a_vegf_px(i, j) = 0.0_8
            a_smois(i, 2, j) = 0.0_8
            a_smois(i, 1, j) = 0.0_8
            a_znt(i, j) = 0.0_8
          END IF
          CALL POPREAL8(snow_fra)
          CALL POPREAL8(snowc(i, j))
          a_qv1 = a_qv1 + cpd*0.84D0*a_cpair
          CALL POPREAL8(z0)
          a_znt(i, j) = a_znt(i, j) + a_z0
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            a_ust(i, j) = a_ust(i, j) + czo*2.D0*ust(i, j)*a_znt(i, j)/g
            a_znt(i, j) = 0.0_8
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL8(ustar)
          ELSE
            CALL POPREAL8(ustar)
            a_ust(i, j) = a_ust(i, j) + a_ustar
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            CALL POPREAL8(rh2obs)
            a_rh2_old = corb*a_rh2obs
            a_rh2_new = core*a_rh2obs
            a_qsbt = -(q2_ndg_new(i, j)*a_rh2_new/qsbt**2)
            CALL POPREAL8(qsbt)
            a_sfcprs = a_sfcprs - ep_2*vapprs*a_qsbt/(sfcprs-vapprs)**2
            CALL POPREAL8(vapprs)
            a_qsbt = -(q2_ndg_old(i, j)*a_rh2_old/qsbt**2)
            CALL POPREAL8(qsbt)
            a_sfcprs = a_sfcprs - ep_2*vapprs*a_qsbt/(sfcprs-vapprs)**2
            CALL POPREAL8(vapprs)
            a_rh2obs = 0.0_8
          END IF
          a_th3d(i, 1, j) = a_th3d(i, 1, j) + a_theta1
          a_canwat(i, j) = a_canwat(i, j) + 1.0d-3*a_wr
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL8(precip)
          ELSE
            CALL POPREAL8(precip)
          END IF
          a_zf1 = a_zf1 + a_za2
          a_dz8w(i, 2, j) = a_dz8w(i, 2, j) + 0.5D0*a_za2
          a_dz8w(i, 1, j) = a_dz8w(i, 1, j) + 0.5D0*a_zlvl + a_zf1
          a_qv3d(i, 2, j) = a_qv3d(i, 2, j) + a_qv2
          a_qv3d(i, 1, j) = a_qv3d(i, 1, j) + a_qv1
          a_rho(i, 1, j) = a_rho(i, 1, j) + a_dens1
          a_t3d(i, 1, j) = a_t3d(i, 1, j) + a_ta1
          a_psfc(i, j) = a_psfc(i, j) + a_sfcprs/1000.0D0
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            CALL POPREAL8(fwsat)
            CALL POPREAL8(fwfc)
            CALL POPREAL8(fwwlt)
            CALL POPREAL8(fb)
            CALL POPREAL8(fcgsat)
            CALL POPREAL8(fjp)
            CALL POPREAL8(fas)
            CALL POPREAL8(fc2r)
            CALL POPREAL8(fc1sat)
            CALL A_SOILPROP(soilcbot(i, :, j), weight, itimestep, mavail&
&                      (i, j), pxlsm_smois_init, fwsat, fwfc, fwwlt, fb, &
&                      fcgsat, fjp, fas, fc2r, fc1sat, isti, smois(i, 2, &
&                      j), a_smois(i, 2, j))
          END IF
          CALL POPREAL8(ifland)
        END DO
      END DO
      CALL POPREAL8ARRAY(xland, (ime-ims+1)*(jme-jms+1))
      CALL A_VEGELAND(landusef, vegfra, shdmin, shdmax, soilctop, &
&                soilcbot, nlcat, nscat, znt, a_znt, xlai, xlaimn, rstmin&
&                , xveg, xvegmn, xsnup, xland, xalb, ids, ide, jds, jde, &
&                kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, &
&                jte, kts, kte, land_use_type)
    END IF
  END SUBROUTINE A_PXLSM
!
!-------------------------------------------------------------------------
!-------------------------------------------------------------------------

!  Differentiation of vegeland in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: znt
!   with respect to varying inputs: znt
!-------------------------------------------------------------------------
!-------------------------------------------------------------------------
!-------------------------------------------------------------------------
!-------------------------------------------------------------------------
  SUBROUTINE A_VEGELAND(landusef, vegfra, shdmin, shdmax, soilctop, &
&    soilcbot, nlcat, nscat, znt, a_znt, xlai, xlaimn, rstmin, xveg, &
&    xvegmn, xsnup, xland, xalb, ids, ide, jds, jde, kds, kde, ims, ime, &
&    jms, jme, kms, kme, its, ite, jts, jte, kts, kte, land_use_type)
    IMPLICIT NONE
! END LOOP THROUGH GRID CELLS
! END LOOP THROUGH GRID CELLS
!--------------------------------------------------------------------
!... 
    INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, its, ite, jts, jte, kts, kte
    INTEGER, INTENT(IN) :: nscat, nlcat
    REAL, DIMENSION(ims:ime, nlcat, jms:jme), INTENT(IN) :: landusef
    REAL, DIMENSION(ims:ime, nscat, jms:jme), INTENT(IN) :: soilctop, &
&    soilcbot
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: vegfra, shdmin, &
&    shdmax
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: znt
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_znt
    REAL, DIMENSION(ims:ime, jms:jme) :: xlai, xlaimn, &
&    rstmin, xalb, xveg, xvegmn, xsnup, xland
    CHARACTER(len=6), INTENT(IN) :: land_use_type
!... local variables
    INTEGER :: itf, jtf, k, j, i
    REAL :: sumlai, sumlmn, sumrsi, sumlz0, sumveg, sumvmn, alai, vegf, &
&    sumsnup
    REAL :: vfmx, vfmn, vseas, farea, fwat, znotc, sumalb
    REAL, DIMENSION(nlcat) :: laimx, laimn, z0, veg, vegmn, snup
! CM, MIN Zo FOR CROPS
    REAL, PARAMETER :: znotcmn=5.0D0
! CM, MAX Zo FOR CROPS
    REAL, PARAMETER :: znotcmx=15.0D0
    REAL, DIMENSION(:), SAVE, POINTER :: rsmin, z00, veg0, vegmn0, lai0&
&    , laimn0, snup0, albf
!---- INITIALIZE PARAMETERS
    INTEGER, SAVE :: kwat
    INTEGER, SAVE :: limit1, limit2
    INTEGER :: branch
! Initialize LU characteristics by LU Dataset
    IF (land_use_type .EQ. 'USGS') THEN
      kwat = 16
    ELSE IF (land_use_type .EQ. 'NLCD50') THEN
      kwat = 1
    ELSE IF (land_use_type .EQ. 'NLCD40') THEN
      kwat = 17
    ELSE IF (land_use_type .EQ. 'MODIS') THEN
      kwat = 17
    END IF
!--------------------------------------------------------------------
    DO j=jts,jte
      DO i=its,ite
!-- CHECK FOR WATER
        fwat = landusef(i, kwat, j)
        IF (fwat .GT. 0.999) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (fwat .GT. 0.50) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
      END DO
    END DO
    DO j=jte,jts,-1
      DO i=ite,its,-1
        a_znt(i, j) = 0.01D0*a_znt(i, j)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) a_znt(i, j) = 0.0_8
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          a_znt(i, j) = 0.0_8
        ELSE
          a_znt(i, j) = 0.0_8
        END IF
      END DO
    END DO
  END SUBROUTINE A_VEGELAND
!-------------------------------------------------------------------------
!-------------------------------------------------------------------------
!-------------------------------------------------------------------------
!-------------------------------------------------------------------------

!  Differentiation of surfpx in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: lai qv1 capg wr dens1 ust hfx
!                theta1 z1 ta1 w2 t2 cpair znt vegfrc qfx rh2obs
!                qst12 psurf wg mol tg
!   with respect to varying inputs: lai qv1 capg wr dens1 ust theta1
!                z1 ta1 w2 betap t2 cpair znt vegfrc qss rh2obs
!                qst12 psurf wg mol tg
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
  SUBROUTINE A_SURFPX(dtpbl, ifland, isnow, nudgex, xice1, soldn, gsw, &
&    lwdn, emissi, z1, a_z1, mol, a_mol, znt, a_znt, ust, a_ust, psurf, &
&    a_psurf, dens1, a_dens1, qv1, a_qv1, qss, a_qss, ta1, a_ta1, theta1&
&    , a_theta1, precip, cpair, a_cpair, psih, rh2obs, a_rh2obs, t2obs, &
&    vegfrc, a_vegfrc, isti, lai, a_lai, betap, a_betap, rstmin, hc_snow&
&    , snow_fra, wwlt, wfc, cgsat, wsat, b, c1sat, c2r, as, jp, ds1, ds2&
&    , qst12, a_qst12, radnet, grdflx, hfx, a_hfx, qfx, a_qfx, lh, eg, er&
&    , etr, qst, capg, a_capg, rs, ra, tg, a_tg, t2, a_t2, wg, a_wg, w2, &
&    a_w2, wr, a_wr, ta2, qa2, land_use_type,iout,jout)
    IMPLICIT NONE
!.......Arguments
!.. Integer
    INTEGER, INTENT(IN) :: iout,jout
    INTEGER, INTENT(IN) :: isti, nudgex
!... Real
    REAL, INTENT(IN) :: dtpbl, ds1, ds2
    REAL, INTENT(IN) :: ifland, isnow, xice1
    REAL, INTENT(IN) :: soldn, gsw, lwdn, emissi, z1
    REAL :: a_z1
    REAL, INTENT(IN) :: znt
    REAL :: a_znt
    REAL, INTENT(IN) :: psurf, dens1, qv1, qss, ta1, theta1, precip
    REAL :: a_psurf, a_dens1, a_qv1, a_qss, a_ta1, a_theta1
    REAL, INTENT(IN) :: cpair
    REAL :: a_cpair
    REAL, INTENT(IN) :: vegfrc, lai
    REAL :: a_vegfrc, a_lai
    REAL, INTENT(IN) :: rstmin, hc_snow, snow_fra
    REAL, INTENT(IN) :: wwlt, wfc, cgsat, wsat, b, c1sat, c2r, as, jp
    REAL, INTENT(IN) :: rh2obs, t2obs
    REAL :: a_rh2obs
    REAL, INTENT(IN) :: qst12
    REAL :: a_qst12
    REAL :: radnet, eg, er, etr
    REAL :: a_eg, a_er, a_etr
    REAL :: qst, capg, rs, ta2, qa2
    REAL :: a_qst, a_capg, a_ta2, a_qa2
    REAL, INTENT(INOUT) :: tg, t2, wg, w2, wr, ust, ra, betap
    REAL, INTENT(INOUT) :: a_tg
    REAL, INTENT(INOUT) :: grdflx, qfx, hfx, lh, psih, mol
    REAL, INTENT(INOUT) :: a_qfx
    CHARACTER(len=5), INTENT(IN) :: land_use_type
!... Local Variables
!... Real
    REAL :: hf, lv, cq4
    REAL :: a_hf, a_lv, a_cq4
    REAL :: rah, raw, et, w2cg, cg, ct, soilflx, cpot, thetag
    REAL :: a_rah, a_raw, a_et, a_w2cg, a_cg, a_ct, a_cpot, a_thetag
    REAL :: zol, zobol, zntol, y, y0, psih15, ynt
    REAL :: a_zol, a_zobol, a_zntol, a_y, a_y0, a_psih15, a_ynt
    REAL :: wgnudg, w2nudg, alph1, alph2, bet1, bet2, t1p5
    REAL :: a_wgnudg, a_w2nudg, a_alph1, a_alph2, a_bet1, a_bet2
    REAL :: cq1, cq2, cq3, coeffnp1, coeffn, tsnew, tshlf, t2new
    REAL :: a_cq1, a_cq2, a_cq3, a_coeffnp1, a_coeffn, a_tsnew, a_tshlf&
&    , a_t2new
    REAL :: roff, wrmax, pc, dwr, pnet, tendwr, wrnew
    REAL :: a_roff, a_wrmax, a_pc, a_dwr, a_pnet, a_tendwr, a_wrnew
    REAL :: cof1, cfnp1wr, cfnwr, pg, fass
    REAL :: a_cof1, a_cfnp1wr, a_cfnwr, a_pg, a_fass
    REAL :: tendw2, w2new, w2hlf, w2rel, c1, c2, weq, cfnp1, cfn, wgnew
    REAL :: a_tendw2, a_w2new, a_w2hlf, a_w2rel, a_c1, a_c2, a_weq, &
&    a_cfnp1, a_cfn, a_wgnew
    REAL :: aln10, tmp1, tmp2, tmp3, aa, ab, tst, rbh, ctveg
    REAL :: a_tst
    REAL :: qst1, phih, psiob
    REAL :: a_qst1, a_phih, a_psiob
    REAL :: t2nud, t2nudf
    REAL :: a_t2nud
    REAL :: vapprs, qsbt, rh2mod
    REAL :: a_vapprs, a_qsbt, a_rh2mod
!... Parameters
    REAL :: zobs, gamah, betah, sigf, bh, ct_snow
! K-M2/J
    REAL, PARAMETER :: cv=8.0d-6
    PARAMETER (zobs=1.5D0)
    PARAMETER (bh=15.7D0)
! height for observed screen temp., (m)
    PARAMETER (gamah=16.D0)
    PARAMETER (betah=5.0D0)
!11.6)
    PARAMETER (sigf=0.5D0)
!8.21)
    PARAMETER (ct_snow=2.0d-5)
! rain interception see LSM (can be 0-1)
!PARAMETER (CT_SNOW  = 5.54E-5)   
! New value of CT_SNOW calibrated using multilayer soil model where csnow=6.9E5 J/(m3 K) 
! from NCAR CSM                                         
    INTEGER :: branch
    REAL, INTENT(INOUT) :: a_ust
    REAL, INTENT(INOUT) :: a_hfx
    REAL, INTENT(INOUT) :: a_wg
    REAL, INTENT(INOUT) :: a_wr
    REAL, INTENT(INOUT) :: a_betap
    REAL, INTENT(INOUT) :: a_w2
    REAL, INTENT(INOUT) :: a_t2
    REAL, INTENT(INOUT) :: a_mol
    REAL :: temp3
    REAL :: temp20b0
    REAL :: temp2
    REAL :: temp1
    REAL :: temp13b
    REAL :: temp0
    REAL :: temp0b
    REAL :: temp2b0
    REAL :: temp20
    REAL :: temp14b
    REAL :: temp1b
    REAL :: temp6b0
    REAL :: temp15b
    REAL :: temp2b
    REAL :: temp16b2
    REAL :: temp16b1
    REAL :: temp16b0
    REAL :: temp16b
    REAL :: temp11b1
    REAL :: temp11b0
    REAL :: temp3b
    REAL :: temp19
    REAL :: temp18
    REAL :: temp17
    REAL :: temp16
    REAL :: temp15
    REAL :: temp14
    REAL :: temp13
    REAL :: temp12
    REAL :: temp17b
    REAL :: temp11
    REAL :: temp10
    REAL :: temp5b0
    REAL :: temp15b1
    REAL :: a_ra
    REAL :: temp15b0
    REAL :: temp18b
    REAL :: temp5b
    REAL :: temp20b
    REAL :: temp6b
    REAL :: temp21b
    REAL :: temp7b
    REAL :: tempb
    REAL :: temp3b5
    REAL :: temp21b1
    REAL :: temp3b4
    REAL :: temp21b0
    REAL :: temp3b3
    REAL :: temp3b2
    REAL :: temp3b1
    REAL :: temp3b0
    REAL :: temp11b
    REAL :: a_psih
    REAL :: temp
    REAL :: temp20b9
    REAL :: temp20b8
    REAL :: temp20b7
    REAL :: temp9
    REAL :: temp20b6
    REAL :: temp8
    REAL :: temp20b5
    REAL :: temp7
    REAL :: temp20b4
    REAL :: temp6
    REAL :: temp20b3
    REAL :: temp5
    REAL :: temp20b2
    REAL :: temp4
    REAL :: temp20b1
    aln10 = ALOG(10.0D0)
! NET RADIATION                             
!--------------------------------------------------------------------
! rcp is global constant(module_model_constants)                            
    cpot = (100.0D0/psurf)**rovcp
    thetag = tg*cpot
    zol = z1/mol
    zobol = zobs/mol
    zntol = znt/mol
!-----------------------------------------------------------------------------------------
    IF (mol .LT. 0.0) THEN
      y = (1.0D0-gamah*zol)**0.5D0
      y0 = (1.0D0-gamah*zobol)**0.5D0
      ynt = (1.0D0-gamah*zntol)**0.5D0
      psih15 = 2.0D0*ALOG((y+1.0D0)/(y0+1.0D0))
      psih = 2.0D0*ALOG((y+1.0D0)/(ynt+1.0D0))
      psiob = 2.0D0*ALOG((y0+1.0D0)/(ynt+1.0D0))
      phih = 1.0D0/y
      CALL PUSHCONTROL2B(0)
    ELSE
      IF (zol - zntol .LE. 1.0) THEN
        psih = -(betah*(zol-zntol))
        CALL PUSHCONTROL1B(0)
      ELSE
        psih = 1.D0 - betah - (zol-zntol)
        CALL PUSHCONTROL1B(1)
      END IF
      IF (zobol - zntol .LE. 1.0) THEN
        psiob = -(betah*(zobol-zntol))
        CALL PUSHCONTROL1B(0)
      ELSE
        psiob = 1.0D0 - betah - (zobol-zntol)
        CALL PUSHCONTROL1B(1)
      END IF
      psih15 = psih - psiob
      IF (zol .LE. 1.0) THEN
        phih = 1.0D0 + betah*zol
        CALL PUSHCONTROL2B(1)
      ELSE
        phih = betah + zol
        CALL PUSHCONTROL2B(2)
      END IF
    END IF
!-----------------------------------------------------------------------------------------
!-- ADD RA AND RB FOR HEAT AND MOISTURE
!... RB FOR HEAT = 5 /UST
!... RB FOR WATER VAPOR =  5*(0.599/0.709)^2/3 /UST = 4.503/UST
    ra = pr0*(ALOG(z1/znt)-psih)/(karman*ust)
    rah = ra + 5.0D0/ust
    raw = ra + 4.503D0/ust
    CALL PUSHREAL8(betap)
!--------------------------------------------------------------------
!--  COMPUTE MOISTURE FLUX
    CALL QFLUX(dens1, qv1, ta1, soldn, raw, qss, vegfrc, isnow, isti, &
&         ifland, lai, betap, wg, w2, wr, rstmin, wwlt, wfc, eg, er, etr&
&         , cq4, rs, fass)
!--------------------------------------------------------------------
!--------------------------------------------------------------------
!..........Total evaporation (ET)
    et = eg + er + etr
    qst = -(et/(dens1*ust))
!-- LATENT HEAT OF SUBLIMATION AT 0C FROM STULL(1988)
    lv = 2.83d6
!-- FROM STULL(1988) in J/KG
    IF (isnow .LT. 0.5 .AND. tg .GT. 273.15) THEN
      lv = (2.501D0-0.00237D0*(tg-273.15D0))*1.d6
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
! IF (IFLAND .LT. 1.5 )  QFX = ET     !-- Recaculate QFX over land to account for P-X LSM EG, ER and ETR
!-----------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------
! Surface sensible heat flux
    tst = (theta1-thetag)/(ust*rah)
    hf = ust*tst
    IF (-(dens1*cpair*hf) .LT. -250.0) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
!-----------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------
! Compute the diagnosed 2m Q and T consistent with PX LSM
    qst1 = 0.5D0*(qst+qst12/phih)
    ta2 = (thetag+tst*(pr0/karman*(ALOG(zobs/znt)-psiob)+5.D0))/cpot
    qa2 = qv1 - qst1*pr0/karman*(ALOG(z1/zobs)-psih15)
    IF (qa2 .LE. 0.0) THEN
      qa2 = qv1
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
!--  Relative humidity
    vapprs = svp1*EXP(svp2*(ta2-svpt0)/(ta2-svp3))
    qsbt = ep_2*vapprs/(psurf-vapprs)
    rh2mod = qa2/qsbt
!-----------------------------------------------------------------------------------------
    IF (ifland .LT. 1.5) THEN
      IF (w2 .LT. wwlt) THEN
        CALL PUSHCONTROL1B(0)
        w2cg = wwlt
      ELSE
        w2cg = w2
        CALL PUSHCONTROL1B(1)
      END IF
      cg = cgsat*1.0d-6*(wsat/w2cg)**(0.5D0*b/aln10)
      ct = 1.D0/((1.D0-vegfrc)/cg+vegfrc/cv)
      CALL PUSHREAL8(ct)
      ct = 1.D0/(snow_fra/ct_snow+(1.D0-snow_fra)/ct)
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
!-----------------------------------------------------------------------------------------
!--------------------------------------------------------------------
!-- ASSIMILATION --- COMPUTE SOIL MOISTURE NUDGING FROM TA2 and RH2               
!-------COMPUTE ASSIMILATION COEFFICIENTS FOR ALL I                            
    IF (ifland .LT. 1.5) THEN
      IF (nudgex .EQ. 0) THEN
!-- NO NUDGING CASE                
        wgnudg = 0.0D0
        w2nudg = 0.0D0
        CALL PUSHCONTROL2B(0)
      ELSE
!-- NUDGING CASE        
        CALL SMASS(isti, fass, soldn, vegfrc, ra, wwlt, wfc, alph1, &
&             alph2, bet1, bet2, t2nudf)
!--COMPUTE MODEL RH
        wgnudg = alph1*(t2obs-ta2) + alph2*(rh2obs-rh2mod)*100.D0
        w2nudg = bet1*(t2obs-ta2) + bet2*(rh2obs-rh2mod)*100.D0
        IF (w2 .GE. wfc) THEN
          IF (w2nudg .GT. 0.0) THEN
            w2nudg = 0.0D0
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHCONTROL2B(1)
            w2nudg = w2nudg
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
        IF (w2 .LE. wwlt) THEN
          IF (w2nudg .LT. 0.0) THEN
            w2nudg = 0.0
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHCONTROL2B(1)
            w2nudg = w2nudg
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B(2)
    END IF
!-----------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------
!-- Compute new values for TS,T2,WG,W2 and WR. No change over ice or water (XLAND > 1)
    IF (ifland .LT. 1.5) THEN
!-- SOLVE BY CRANK-NIC --   TENDTS=CT*(RADNET-HFX-QFX)-SOILFLX 
!-- Calculate the coefficients for implicit calculation of TG
      cq1 = (1.0D0-0.622D0*lv*crankp/(r_d*tg))*qss
      cq2 = 0.622D0*lv*qss*crankp/(r_d*tg*tg)
      cq3 = dens1*betap*(1.0D0-vegfrc)/raw
      coeffnp1 = 1.0D0 + dtpbl*crankp*(4.0D0*emissi*stbolt*tg**3*ct+dens1*&
&        cpair/rah*cpot*ct+2.0D0*pi*tauinv) + dtpbl*(ct*lv*cq2*(cq3+cq4))
!NET RAD
!SFC HEAT FLUX 
!SOIL FLUX
      coeffn = ct*(gsw+emissi*(stbolt*(4.0D0*crankp-1.0D0)*tg*tg*tg*tg+lwdn)&
&        +dens1*cpair/rah*(theta1-(1.0D0-crankp)*thetag)-lv*(cq3*(cq1-qv1)+&
&        cq4*(cq1-qv1))) - 2.0D0*pi*tauinv*((1.0D0-crankp)*tg-t2)
      tsnew = (tg+dtpbl*coeffn)/coeffnp1
!-- FOR SNOW COVERED SURFACE TEMPERATURE IS NOT MORE THAN ZERO
! Re-added Jan 2010 to keep ice surface at or below freezing (J. Pleim)
      IF (xice1 .GT. 0.5) THEN
        IF (tsnew .GT. 273.15) THEN
          CALL PUSHCONTROL2B(2)
        ELSE
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
!-----------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------
! Compute new subsurface soil and canopy moisture values DENS1. No change required over ocean.
    IF (ifland .LT. 1.5 .AND. xice1 .LT. 0.5) THEN
!-- Compute WR
! max. WRMAX IN m
      wrmax = 0.2d-3*vegfrc*lai
      IF (wrmax .GT. 0.0) THEN
!--  PC is precip. intercepted by veg.(M/S)
        pc = vegfrc*sigf*precip
!the tendency to reach max.
        dwr = (wrmax-wr)/dtpbl
! residual of precip. and evap.
        pnet = pc - er/denw
        IF (pnet .GT. dwr) THEN
          roff = pnet - dwr
          pc = pc - roff
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (qss .LT. qv1) THEN
          tendwr = pc - er/denw
          wrnew = wr + dtpbl*tendwr
          CALL PUSHCONTROL2B(2)
        ELSE
          cof1 = dens1/denw*vegfrc*(qss-qv1)/raw
!-- using delta=wr/wrmax
          cfnp1wr = 1.0D0 + dtpbl*cof1*crankp/wrmax
          cfnwr = pc - cof1*(1.0D0-crankp)*wr/wrmax
          wrnew = (wr+dtpbl*cfnwr)/cfnp1wr
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        pc = 0.0D0
        wrnew = 0.0D0
        CALL PUSHCONTROL2B(0)
      END IF
!---------------------------------------------
!-- Compute W2
! PG is precip. reaching soil (PC already including ROFF)
      pg = denw*(precip-pc)
! NUDGING
      tendw2 = 1.0D0/(denw*ds2)*(pg-eg-etr) + (w2nudg+wgnudg)/ds2
      w2new = w2 + dtpbl*tendw2
      IF (w2new .GT. wsat) THEN
        w2new = wsat
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
        w2new = w2new
      END IF
      IF (w2new .LT. 0.05) THEN
        w2new = 0.05D0
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
        w2new = w2new
      END IF
      w2hlf = 0.5D0*(w2+w2new)
!.. new values
      IF (wrmax .GT. wrnew) THEN
        CALL PUSHCONTROL2B(2)
      ELSE
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B(0)
    END IF
!endif for XLAND
!-----------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------
! Compute new surface soil moisture values (WR).
    IF (ifland .LT. 1.5 .AND. xice1 .LT. 0.5) THEN
!endif for ISNOW
! over ocean no change to wg w2,wr
!--    FOR SNOW COVERED SURFACE, ASSUME SURFACE IS SATURATED AND
!      WG AND W2 ARE NOT CHANGED
      IF (isnow .GT. 0.5) THEN
        a_eg = 0.0_8
        a_wg = 0.0_8
        a_w2hlf = 0.0_8
        a_pg = 0.0_8
        a_wgnudg = 0.0_8
      ELSE
        w2rel = w2hlf/wsat
        IF (wg .GT. wwlt) THEN
          c1 = c1sat*(wsat/wg)**(0.5D0*b+1.0D0)
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
! elimilate C1 for wg < wilting point
          c1 = c1sat*(wsat/wwlt)**(0.5D0*b+1.0D0)
        END IF
        c2 = c2r*w2hlf/(wsat-w2hlf+1.d-11)
        IF (w2hlf .EQ. wsat) THEN
          weq = wsat
          CALL PUSHCONTROL1B(1)
        ELSE
          weq = w2hlf - as*wsat*w2rel**jp*(1.0D0-w2rel**(8.0D0*jp))
          CALL PUSHCONTROL1B(0)
        END IF
!.... The beta method, Lee & Pielke (JAM, May 1992)
        cfnp1 = 1.0D0 + dtpbl*c2*tauinv*crankp
        cfn = c1/(denw*ds1)*(pg-eg) - c2*tauinv*((1.0D0-crankp)*wg-weq) + &
&          wgnudg/ds1
        IF ((wg+dtpbl*cfn)/cfnp1 .LT. 0.001) THEN
          wgnew = 0.001D0
          CALL PUSHCONTROL1B(0)
        ELSE
          wgnew = (wg+dtpbl*cfn)/cfnp1
          CALL PUSHCONTROL1B(1)
        END IF
        IF (wgnew .GT. wsat) THEN
          a_wgnew = 0.0_8
        ELSE
          a_wgnew = a_wg
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          a_wg = 0.0_8
          a_cfn = 0.0_8
          a_cfnp1 = 0.0_8
        ELSE
          temp21b1 = a_wgnew/cfnp1
          a_wg = temp21b1
          a_cfn = dtpbl*temp21b1
          a_cfnp1 = -((wg+dtpbl*cfn)*temp21b1/cfnp1)
        END IF
        temp21b = a_cfn/(denw*ds1)
        temp21b0 = -(tauinv*a_cfn)
        a_c1 = (pg-eg)*temp21b
        a_pg = c1*temp21b
        a_eg = -(c1*temp21b)
        a_c2 = dtpbl*tauinv*crankp*a_cfnp1 + ((1.0D0-crankp)*wg-weq)*&
&          temp21b0
        a_wg = a_wg + c2*(1.0D0-crankp)*temp21b0
        a_weq = -(c2*temp21b0)
        a_wgnudg = a_cfn/ds1
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          temp20 = 8.0D0*jp
          temp20b9 = -(as*wsat*a_weq)
          a_w2hlf = a_weq
          IF (w2rel .LE. 0.0_8 .AND. (jp .EQ. 0.0_8 .OR. jp .NE. INT(jp)&
&              )) THEN
            a_w2rel = 0.0D0
          ELSE
            a_w2rel = ((1.0D0-w2rel**temp20)*jp*w2rel**(jp-1.D0)-w2rel**jp*&
&              temp20*w2rel**(temp20-1.D0))*temp20b9
          END IF
        ELSE
          a_w2rel = 0.0_8
          a_w2hlf = 0.0_8
        END IF
        temp20b8 = c2r*a_c2/(wsat-w2hlf+1.d-11)
        a_w2hlf = a_w2hlf + (w2hlf/(wsat-w2hlf+1.d-11)+1.0D0)*temp20b8
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          IF (.NOT.(wsat/wg .LE. 0.0_8 .AND. (b*0.5D0 + 1.0D0 .EQ. 0.0_8 &
&              .OR. b*0.5D0 + 1.0D0 .NE. INT(b*0.5D0 + 1.0D0)))) a_wg = a_wg - (b&
&              *0.5D0+1.0D0)*(wsat/wg)**(b*0.5D0)*c1sat*wsat*a_c1/wg**2
        END IF
        a_w2hlf = a_w2hlf + a_w2rel/wsat
      END IF
    ELSE
      a_eg = 0.0_8
      a_w2hlf = 0.0_8
      a_pg = 0.0_8
      a_wgnudg = 0.0_8
    END IF
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      a_er = 0.0_8
      a_etr = 0.0_8
      a_qss = 0.0_8
      a_w2nudg = 0.0_8
      a_raw = 0.0_8
    ELSE
      IF (branch .EQ. 1) THEN
        a_wrmax = a_wr
        a_wrnew = 0.0_8
      ELSE
        a_wrnew = a_wr
        a_wrmax = 0.0_8
      END IF
      a_w2new = 0.5*a_w2hlf + a_w2
      a_w2 = 0.5*a_w2hlf
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) a_w2new = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) a_w2new = 0.0_8
      a_w2 = a_w2 + a_w2new
      a_tendw2 = dtpbl*a_w2new
      temp20b7 = a_tendw2/(denw*ds2)
      a_pg = a_pg + temp20b7
      a_eg = a_eg - temp20b7
      a_etr = -temp20b7
      a_w2nudg = a_tendw2/ds2
      a_wgnudg = a_wgnudg + a_tendw2/ds2
      a_pc = -(denw*a_pg)
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        a_wr = 0.0_8
        a_er = 0.0_8
        a_qss = 0.0_8
        a_raw = 0.0_8
      ELSE
        IF (branch .EQ. 1) THEN
          temp20b2 = a_wrnew/cfnp1wr
          a_cfnwr = dtpbl*temp20b2
          a_cfnp1wr = -((wr+dtpbl*cfnwr)*temp20b2/cfnp1wr)
          temp20b3 = -((1.0D0-crankp)*a_cfnwr/wrmax)
          a_wr = cof1*temp20b3 + temp20b2
          a_pc = a_pc + a_cfnwr
          temp20b4 = dtpbl*crankp*a_cfnp1wr/wrmax
          a_cof1 = temp20b4 + wr*temp20b3
          a_wrmax = a_wrmax - cof1*temp20b4/wrmax - cof1*wr*temp20b3&
&            /wrmax
          temp20b5 = a_cof1/(denw*raw)
          temp20b6 = dens1*vegfrc*temp20b5
          a_dens1 = a_dens1 + (qss-qv1)*vegfrc*temp20b5
          a_vegfrc = a_vegfrc + (qss-qv1)*dens1*temp20b5
          a_qss = temp20b6
          a_qv1 = a_qv1 - temp20b6
          a_raw = -(dens1*vegfrc*(qss-qv1)*temp20b5/raw)
          a_er = 0.0_8
        ELSE
          a_wr = a_wrnew
          a_tendwr = dtpbl*a_wrnew
          a_pc = a_pc + a_tendwr
          a_er = -(a_tendwr/denw)
          a_qss = 0.0_8
          a_raw = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          a_roff = -a_pc
          a_pnet = a_roff
          a_dwr = -a_roff
        ELSE
          a_dwr = 0.0_8
          a_pnet = 0.0_8
        END IF
        a_pc = a_pc + a_pnet
        a_er = a_er - a_pnet/denw
        a_wrmax = a_wrmax + a_dwr/dtpbl
        a_wr = a_wr - a_dwr/dtpbl
        a_vegfrc = a_vegfrc + sigf*precip*a_pc
      END IF
      a_vegfrc = a_vegfrc + 0.2d-3*lai*a_wrmax
      a_lai = a_lai + 0.2d-3*vegfrc*a_wrmax
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      a_t2new = a_t2
      temp20b0 = a_t2new/(dtpbl*tauinv*(t2tfac*crankp)+1.0D0)
      temp20b1 = dtpbl*tauinv*t2tfac*temp20b0
      a_t2 = temp20b0 - (1-crankp)*temp20b1
      a_tshlf = temp20b1
      a_tsnew = 0.5D0*a_tshlf + a_tg
      a_t2nud = dtpbl*temp20b0
      a_tg = 0.5D0*a_tshlf
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .NE. 1) a_tsnew = 0.0_8
      END IF
      temp12 = r_d*tg
      temp11 = lv/temp12
      temp14 = (-vegfrc+1.0D0)/raw
      temp20b = a_tsnew/coeffnp1
      a_coeffn = dtpbl*temp20b
      a_coeffnp1 = -((tg+dtpbl*coeffn)*temp20b/coeffnp1)
      temp17 = cq3*(cq1-qv1) + cq4*(cq1-qv1)
      temp19 = theta1 - (-crankp+1.0D0)*thetag
      temp16 = dens1*cpair/rah
      temp18 = stbolt*(4.0D0*crankp-1.0D0)
      temp16b = ct*a_coeffn
      temp16b0 = temp19*temp16b/rah
      temp17b = -(lv*temp16b)
      temp18b = -(pi*2.0D0*tauinv*a_coeffn)
      a_theta1 = a_theta1 + temp16*temp16b
      a_thetag = -(temp16*(1.0D0-crankp)*temp16b)
      a_cq1 = (cq4+cq3)*temp17b
      a_qv1 = a_qv1 + (-cq4-cq3)*temp17b
      a_t2 = a_t2 - temp18b
      temp15 = dens1*cpair/rah
      temp15b0 = dtpbl*crankp*a_coeffnp1
      temp15b = emissi*4.0D0*stbolt*temp15b0
      temp15b1 = cpot*ct*temp15b0/rah
      a_cpair = a_cpair + dens1*temp15b1 + dens1*temp16b0
      a_rah = -(temp15*temp15b1) - temp16*temp16b0
      temp16b1 = dtpbl*cq2*(cq3+cq4)*a_coeffnp1
      a_ct = tg**3*temp15b + temp15*cpot*temp15b0 + lv*temp16b1 + &
&        (gsw+emissi*(lwdn+temp18*tg**4)+temp16*temp19-lv*temp17)*&
&        a_coeffn
      temp16b2 = dtpbl*ct*lv*a_coeffnp1
      a_cq3 = cq2*temp16b2 + (cq1-qv1)*temp17b
      a_dens1 = a_dens1 + cpair*temp15b1 + temp14*betap*a_cq3 + cpair*&
&        temp16b0
      a_cq4 = cq2*temp16b2 + (cq1-qv1)*temp17b
      a_cpot = temp15*ct*temp15b0
      a_cq2 = (cq3+cq4)*temp16b2
      temp14b = dens1*betap*a_cq3/raw
      a_betap = temp14*dens1*a_cq3
      a_vegfrc = a_vegfrc - temp14b
      a_raw = a_raw - temp14*temp14b
      temp13 = r_d*tg**2
      temp13b = crankp*0.622D0*a_cq2/temp13
      a_qss = a_qss + (1.0D0-crankp*0.622D0*temp11)*a_cq1 + lv*temp13b
      temp11b1 = -(crankp*0.622D0*qss*a_cq1/temp12)
      a_tg = a_tg + temp18*emissi*4*tg**3*temp16b + (1.0D0-crankp)*&
&        temp18b - r_d*lv*qss*2.D0*tg*temp13b/temp13 - temp11*r_d*&
&        temp11b1 + ct*3.D0*tg**2*temp15b + temp20b
      a_lv = ct*temp16b1 + temp11b1 + qss*temp13b - temp17*&
&        temp16b
    ELSE
      a_betap = 0.0_8
      a_t2nud = 0.0_8
      a_rah = 0.0_8
      a_lv = 0.0_8
      a_thetag = 0.0_8
      a_ct = 0.0_8
      a_cq4 = 0.0_8
      a_cpot = 0.0_8
    END IF
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      a_ra = 0.0_8
      a_ta2 = 0.0_8
      a_rh2mod = 0.0_8
      a_fass = 0.0_8
    ELSE IF (branch .EQ. 1) THEN
      a_ta2 = -(t2nudf*a_t2nud)
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .NE. 1) a_w2nudg = 0.0_8
      END IF
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .NE. 1) a_w2nudg = 0.0_8
      END IF
      temp11b0 = 100.D0*alph2*a_wgnudg
      temp11b = 100.D0*bet2*a_w2nudg
      a_bet1 = (t2obs-ta2)*a_w2nudg
      a_ta2 = a_ta2 - alph1*a_wgnudg - bet1*a_w2nudg
      a_bet2 = 100.D0*(rh2obs-rh2mod)*a_w2nudg
      a_rh2obs = a_rh2obs + temp11b0 + temp11b
      a_rh2mod = -temp11b0 - temp11b
      a_alph1 = (t2obs-ta2)*a_wgnudg
      a_alph2 = 100.D0*(rh2obs-rh2mod)*a_wgnudg
      CALL A_SMASS(isti, fass, a_fass, soldn, vegfrc, a_vegfrc, ra, a_ra&
&             , wwlt, wfc, alph1, a_alph1, alph2, a_alph2, bet1, a_bet1, &
&             bet2, a_bet2, t2nudf)
    ELSE
      a_ra = 0.0_8
      a_ta2 = 0.0_8
      a_rh2mod = 0.0_8
      a_fass = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      a_ct = a_ct - a_capg/ct**2
      CALL POPREAL8(ct)
      temp10 = (-snow_fra+1.D0)/ct
      temp9 = snow_fra/ct_snow + temp10
      a_ct = temp10*a_ct/(ct*temp9**2)
      temp8 = (-vegfrc+1.D0)/cg
      temp7 = temp8 + vegfrc/cv
      temp7b = -(a_ct/temp7**2)
      a_vegfrc = a_vegfrc + (1.0D0/cv-1.0D0/cg)*temp7b
      a_cg = -(temp8*temp7b/cg)
      temp6 = 0.5D0*b/aln10
      IF (wsat/w2cg .LE. 0.0_8 .AND. (temp6 .EQ. 0.0_8 .OR. temp6 .NE. &
&          INT(temp6))) THEN
        a_w2cg = 0.0D0
      ELSE
        a_w2cg = -(temp6*(wsat/w2cg)**(temp6-1.D0)*cgsat*1.0d-6*wsat*a_cg/&
&          w2cg**2)
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) a_w2 = a_w2 + a_w2cg
      a_capg = 0.0_8
    END IF
    a_qa2 = a_rh2mod/qsbt
    a_qsbt = -(qa2*a_rh2mod/qsbt**2)
    temp6b = ep_2*a_qsbt/(psurf-vapprs)
    temp6b0 = -(vapprs*temp6b/(psurf-vapprs))
    a_vapprs = temp6b - temp6b0
    a_psurf = a_psurf + temp6b0
    temp5 = (ta2-svpt0)/(ta2-svp3)
    temp5b0 = svp2*EXP(svp2*temp5)*svp1*a_vapprs/(ta2-svp3)
    a_ta2 = a_ta2 + (1.0D0-temp5)*temp5b0
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      a_qv1 = a_qv1 + a_qa2
      a_qa2 = 0.0_8
    END IF
    temp5b = -(pr0*qst1*a_qa2/karman)
    a_qv1 = a_qv1 + a_qa2
    a_z1 = a_z1 + temp5b/z1
    a_psih15 = -temp5b
    a_qst1 = -((ALOG(z1/zobs)-psih15)*pr0*a_qa2/karman)
    temp3b3 = a_ta2/cpot
    temp4 = zobs/znt
    temp3 = pr0*(ALOG(temp4)-psiob)/karman + 5.D0
    temp3b4 = pr0*tst*temp3b3/karman
    a_thetag = a_thetag + temp3b3
    a_tst = temp3*temp3b3
    a_znt = a_znt - temp3b4/znt
    a_psiob = -temp3b4
    a_cpot = a_cpot - (thetag+tst*temp3)*temp3b3/cpot
    temp3b5 = 0.5D0*a_qst1/phih
    a_qst = 0.5D0*a_qst1
    a_qst12 = a_qst12 + temp3b5
    a_phih = -(qst12*temp3b5/phih)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      a_hf = 0.0_8
    ELSE
      a_dens1 = a_dens1 - hf*cpair*a_hfx
      a_cpair = a_cpair - hf*dens1*a_hfx
      a_hf = -(dens1*cpair*a_hfx)
    END IF
    a_tst = a_tst + ust*a_hf
    temp3b2 = a_tst/(ust*rah)
    temp3b1 = -((theta1-thetag)*temp3b2/(ust*rah))
    a_ust = a_ust + rah*temp3b1 + tst*a_hf
    a_theta1 = a_theta1 + temp3b2
    a_thetag = a_thetag - temp3b2
    a_rah = a_rah + ust*temp3b1
    a_et = a_qfx
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) a_tg = a_tg - 1.d6*0.00237D0*a_lv
    temp3b = -(a_qst/(dens1*ust))
    temp3b0 = -(et*temp3b/(dens1*ust))
    a_et = a_et + temp3b
    a_dens1 = a_dens1 + ust*temp3b0
    a_eg = a_eg + a_et
    a_er = a_er + a_et
    a_etr = a_etr + a_et
    CALL POPREAL8(betap)
    CALL A_QFLUX(dens1, a_dens1, qv1, a_qv1, ta1, a_ta1, soldn, raw, &
&           a_raw, qss, a_qss, vegfrc, a_vegfrc, isnow, isti, ifland, lai&
&           , a_lai, betap, a_betap, wg, w2, a_w2, wr, a_wr, rstmin, wwlt&
&           , wfc, eg, a_eg, er, a_er, etr, a_etr, cq4, a_cq4, rs, fass, &
&           a_fass)
    a_ra = a_ra + a_rah + a_raw
    temp2 = z1/znt
    temp2b = pr0*a_ra/(karman*ust)
    a_ust = a_ust + dens1*temp3b0 - (ALOG(temp2)-psih)*temp2b/ust - &
&      5.0D0*a_rah/ust**2 - 4.503D0*a_raw/ust**2
    temp2b0 = temp2b/(temp2*znt)
    a_z1 = a_z1 + temp2b0
    a_znt = a_znt - temp2*temp2b0
    a_psih = -temp2b
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      temp = (y+1.0D0)/(y0+1.0D0)
      tempb = 2.0D0*a_psih15/(temp*(y0+1.0D0))
      temp0 = (y+1.0D0)/(ynt+1.0D0)
      temp0b = 2.0D0*a_psih/(temp0*(ynt+1.0D0))
      a_y = temp0b + tempb - a_phih/y**2
      temp1 = (y0+1.0D0)/(ynt+1.0D0)
      temp1b = 2.0D0*a_psiob/(temp1*(ynt+1.0D0))
      a_y0 = temp1b - temp*tempb
      a_ynt = -(temp0*temp0b) - temp1*temp1b
      a_zntol = -(0.5D0*(1.0D0-gamah*zntol)**(-0.5D0)*gamah*a_ynt)
      a_zobol = -(0.5D0*(1.0D0-gamah*zobol)**(-0.5D0)*gamah*a_y0)
      a_zol = -(0.5D0*(1.0D0-gamah*zol)**(-0.5D0)*gamah*a_y)
    ELSE
      IF (branch .EQ. 1) THEN
        a_zol = betah*a_phih
      ELSE
        a_zol = a_phih
      END IF
      a_psih = a_psih + a_psih15
      a_psiob = a_psiob - a_psih15
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        a_zobol = -(betah*a_psiob)
        a_zntol = betah*a_psiob
      ELSE
        a_zntol = a_psiob
        a_zobol = -a_psiob
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        a_zol = a_zol - betah*a_psih
        a_zntol = a_zntol + betah*a_psih
      ELSE
        a_zntol = a_zntol + a_psih
        a_zol = a_zol - a_psih
      END IF
    END IF
    a_znt = a_znt + a_zntol/mol
    a_mol = a_mol - zobs*a_zobol/mol**2 - z1*a_zol/mol**2 - znt*a_zntol/&
&      mol**2
    a_z1 = a_z1 + a_zol/mol
    a_tg = a_tg + cpot*a_thetag
    a_cpot = a_cpot + tg*a_thetag
    IF (.NOT.(100.0D0/psurf .LE. 0.0_8 .AND. (rovcp .EQ. 0.0_8 .OR. rovcp &
&        .NE. INT(rovcp)))) a_psurf = a_psurf - rovcp*(100.0D0/psurf)**(&
&        rovcp-1.D0)*100.0D0*a_cpot/psurf**2
  END SUBROUTINE A_SURFPX
!------------------------------------------------------------------------------

!  Differentiation of qflux in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: lai qv1 wr dens1 ta1 eg w2
!                betap er etr vegfrc qss fass raw cq4
!   with respect to varying inputs: lai qv1 wr dens1 ta1 w2 betap
!                vegfrc qss raw
!-------------------------------------------------------------------------
!-------------------------------------------------------------------------
!-------------------------------------------------------------------------
!-------------------------------------------------------------------------
  SUBROUTINE A_QFLUX(dens1, a_dens1, qv1, a_qv1, ta1, a_ta1, rg, raw, &
&    a_raw, qss, a_qss, vegfrc, a_vegfrc, isnow, isti, ifland, lai, a_lai&
&    , betap, a_betap, wg, w2, a_w2, wr, a_wr, rstmin, wwlt, wfc, eg, &
&    a_eg, er, a_er, etr, a_etr, cq4, a_cq4, rs, fass, a_fass)
    IMPLICIT NONE
! DECLARATIONS - INTEGER
    INTEGER, INTENT(IN) :: isti
! DECLARATIONS - REAL
    REAL, INTENT(IN) :: isnow, ifland
    REAL, INTENT(IN) :: dens1, qv1, ta1, rg, raw, qss, vegfrc, lai, wg, &
&    w2, wr, rstmin
    REAL :: a_dens1, a_qv1, a_ta1, a_raw, a_qss, a_vegfrc, a_lai, a_w2, &
&    a_wr
    REAL, INTENT(INOUT) :: betap
    REAL, INTENT(INOUT) :: a_betap
    REAL, INTENT(IN) :: wwlt, wfc
    REAL :: eg, er, etr, cq4, rs, fass
    REAL :: a_eg, a_er, a_etr, a_cq4, a_rs, a_fass
!... Local Variables
!... Real
    REAL :: wrmax, delta, sigg, radl, radf, w2avail, w2mxav
    REAL :: a_wrmax, a_delta, a_sigg, a_radf, a_w2avail
    REAL :: ftot, f1, f2, f3, f4
    REAL :: a_ftot, a_f1, a_f2, a_f3, a_f4
    REAL :: fshelt, gs, ga, fx
    REAL :: a_gs, a_ga, a_fx
!... Parameters
! s/m
    REAL, PARAMETER :: rsmax=5000.0D0
! m/s
    REAL, PARAMETER :: ftmin=0.0000001D0
    REAL, PARAMETER :: f3min=0.25D0
    INTEGER :: branch
    REAL :: temp3
    REAL :: temp2
    REAL :: temp1
    REAL :: temp0
    REAL :: temp0b
    REAL :: a_x1
    REAL :: x1
    REAL :: temp4b
    REAL :: temp0b4
    REAL :: temp0b3
    REAL :: temp0b2
    REAL :: temp0b1
    REAL :: temp0b0
    REAL :: temp5b
    REAL :: temp4b2
    REAL :: temp4b1
    REAL :: temp4b0
    REAL :: temp7b
    REAL :: tempb
    REAL :: temp8b
    REAL :: temp8b2
    REAL :: temp8b1
    REAL :: temp8b0
    REAL :: temp9b
    REAL :: temp
    REAL :: temp9
    REAL :: temp8
    REAL :: temp7
    REAL :: temp6
    REAL :: temp5
    REAL :: temp7b1
    REAL :: temp4
    REAL :: temp7b0
!
!... for water surface, no canopy evaporation and transpiration
!... GROUND EVAPORATION (DEPOSITION)
    IF (qss .LT. qv1) THEN
      betap = 1.0D0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
!!---------------------------------------------------------------------
!... CANOPY
    IF (ifland .LT. 1.5 .AND. vegfrc .GT. 0.0) THEN
! in unit m
      wrmax = 0.2d-3*vegfrc*lai
      IF (wr .LE. 0.0) THEN
        delta = 0.0D0
        CALL PUSHCONTROL1B(0)
      ELSE
!         DELTA = (WR / WRMAX) ** 0.66667
! referred to SiB model
        delta = wr/wrmax
        CALL PUSHCONTROL1B(1)
      END IF
      IF (qss .GE. qv1) THEN
        sigg = delta
        CALL PUSHCONTROL1B(0)
      ELSE
        sigg = 1.0D0
        CALL PUSHCONTROL1B(1)
      END IF
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
!!---------------------------------------------------------------------
!-- TRANSPIRATION
!!---------------------------------------------------------------------
    IF (ifland .LT. 1.5 .AND. vegfrc .GT. 0.0) THEN
!!!-RADIATION
      IF (rstmin .GT. 130.0) THEN
! W/M2
        radl = 30.0D0
      ELSE
! W/M2
        radl = 100.0D0
      END IF
! NP89 - EQN34
      radf = 1.1D0*rg/(radl*lai)
      f1 = (rstmin/rsmax+radf)/(1.0D0+radf)
!!!-SOIL MOISTURE
      w2avail = w2 - wwlt
      w2mxav = wfc - wwlt
! according JP, 9/94
      f2 = 1.0D0/(1.0D0+EXP(-(5.0D0*(w2avail/w2mxav-(w2mxav/3.0D0+wwlt)))))
!-AIR TEMP
!... according to Avissar (1985) and AX 7/95
      IF (ta1 .LE. 302.15) THEN
        f4 = 1.0D0/(1.0D0+EXP(-(0.41D0*(ta1-282.05D0))))
        CALL PUSHCONTROL1B(0)
      ELSE
        f4 = 1.0D0/(1.0D0+EXP(0.5D0*(ta1-314.0D0)))
        CALL PUSHCONTROL1B(1)
      END IF
      ftot = lai*f1*f2*f4
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
!!---------------------------------------------------------------------
    IF (ifland .LT. 1.5 .AND. vegfrc .GT. 0.0) THEN
! go back to NP89
      fshelt = 1.0D0
      gs = ftot/(rstmin*fshelt)
      ga = 1.0D0/raw
!-- Compute humidity effect according to RH at leaf surf
      f3 = 0.5D0*(gs-ga+SQRT(ga*ga+ga*gs*(4.0D0*qv1/qss-2.0D0)+gs*gs))/gs
      IF (f3 .LT. f3min) THEN
        x1 = f3min
        CALL PUSHCONTROL1B(0)
      ELSE
        x1 = f3
        CALL PUSHCONTROL1B(1)
      END IF
      IF (x1 .GT. 1.0) THEN
        f3 = 1.0D0
        CALL PUSHCONTROL1B(0)
      ELSE
        f3 = x1
        CALL PUSHCONTROL1B(1)
      END IF
      rs = 1.0D0/(gs*f3)
!--- Compute Assimilation factor for soil moisture nudging - jp 12/94
!--  Note that the 30 coef is to result in order 1 factor for max
      IF (rg .LT. 0.00001) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      temp7b1 = (1.0D0-sigg)*(qss-qv1)*a_etr/(raw+rs)
      temp7 = dens1*vegfrc/(raw+rs)
      temp8b1 = -(temp7*temp7b1)
      temp9 = sigg/raw
      temp8 = (-sigg+1.0D0)/(raw+rs)
      temp8b = dens1*vegfrc*a_cq4
      temp8b0 = temp8b/(raw+rs)
      temp9b = -(temp8*temp8b0)
      a_dens1 = a_dens1 + vegfrc*temp7b1 + (temp8+temp9)*vegfrc*a_cq4
      a_vegfrc = a_vegfrc + dens1*temp7b1 + (temp8+temp9)*dens1*a_cq4
      a_sigg = temp8b/raw - (qss-qv1)*temp7*a_etr - temp8b0
      a_raw = a_raw + temp8b1 - temp9*temp8b/raw + temp9b
      a_rs = temp8b1 + temp9b
      temp8b2 = temp7*(1.0D0-sigg)*a_etr
      a_qss = a_qss + temp8b2
      a_qv1 = a_qv1 - temp8b2
      a_fx = a_fass
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        a_f1 = 0.0_8
        a_f4 = 0.0_8
      ELSE
        temp7b0 = 30.0D0*a_fx/(rstmin*fshelt)
        a_f1 = lai*f4*temp7b0
        a_f4 = lai*f1*temp7b0
        a_lai = a_lai + f1*f4*temp7b0
      END IF
      temp7b = -(a_rs/(gs**2*f3**2))
      a_gs = f3*temp7b
      a_f3 = gs*temp7b
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        a_x1 = 0.0_8
      ELSE
        a_x1 = a_f3
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        a_f3 = 0.0_8
      ELSE
        a_f3 = a_x1
      END IF
      temp6 = 4.0D0*qv1/qss - 2.0D0
      temp4 = ga**2 + ga*gs*temp6 + gs**2
      temp5 = SQRT(temp4)
      temp4b1 = 0.5D0*a_f3/gs
      IF (temp4 .EQ. 0.0_8) THEN
        temp4b2 = 0.0D0
      ELSE
        temp4b2 = temp4b1/(2.0D0*temp5)
      END IF
      temp5b = 4.0D0*ga*gs*temp4b2/qss
      a_gs = a_gs + (2.D0*gs+temp6*ga)*temp4b2 + (1.0D0-(gs-ga+temp5)/gs)*&
&        temp4b1
      a_ga = (temp6*gs+2.D0*ga)*temp4b2 - temp4b1
      a_qv1 = a_qv1 + temp5b
      a_qss = a_qss - qv1*temp5b/qss
      a_raw = a_raw - a_ga/raw**2
      a_ftot = a_gs/(rstmin*fshelt)
    ELSE
      a_f1 = 0.0_8
      a_f4 = 0.0_8
      a_ftot = 0.0_8
      a_sigg = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      temp4b = f2*f4*a_ftot
      temp4b0 = lai*f1*a_ftot
      a_lai = a_lai + f1*temp4b
      a_f1 = a_f1 + lai*temp4b
      a_f2 = f4*temp4b0
      a_f4 = a_f4 + f2*temp4b0
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        temp2 = EXP(-(0.41D0*(ta1-282.05D0))) + 1.0D0
        a_ta1 = a_ta1 + EXP(-(0.41D0*(ta1-282.05D0)))*0.41D0*a_f4/temp2**2
      ELSE
        temp3 = EXP(0.5D0*(ta1-314.0D0)) + 1.0D0
        a_ta1 = a_ta1 - EXP(0.5D0*(ta1-314.0D0))*0.5D0*a_f4/temp3**2
      END IF
      temp1 = -(5.0D0*(w2avail/w2mxav-wwlt-w2mxav/3.0D0))
      temp0 = EXP(temp1) + 1.0D0
      a_w2avail = 5.0D0*EXP(temp1)*a_f2/(temp0**2*w2mxav)
      a_w2 = a_w2 + a_w2avail
      temp0b4 = a_f1/(radf+1.0D0)
      a_radf = (1.0D0-(rstmin/rsmax+radf)/(radf+1.0D0))*temp0b4
      a_lai = a_lai - rg*1.1D0*a_radf/(radl*lai**2)
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      temp0b1 = sigg*a_er/raw
      temp0b2 = dens1*vegfrc*temp0b1
      temp0b3 = dens1*vegfrc*(qss-qv1)*a_er/raw
      a_dens1 = a_dens1 + (qss-qv1)*vegfrc*temp0b1
      a_vegfrc = a_vegfrc + (qss-qv1)*dens1*temp0b1
      a_qss = a_qss + temp0b2
      a_qv1 = a_qv1 - temp0b2
      a_sigg = a_sigg + temp0b3
      a_raw = a_raw - sigg*temp0b3/raw
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        a_delta = a_sigg
      ELSE
        a_delta = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        a_wrmax = 0.0_8
      ELSE
        a_wr = a_wr + a_delta/wrmax
        a_wrmax = -(wr*a_delta/wrmax**2)
      END IF
      a_vegfrc = a_vegfrc + 0.2d-3*lai*a_wrmax
      a_lai = a_lai + 0.2d-3*vegfrc*a_wrmax
    END IF
    tempb = dens1*betap*(qss-qv1)*a_eg/raw
    temp = (-vegfrc+1.0D0)/raw
    temp0b = temp*a_eg
    temp0b0 = dens1*betap*temp0b
    a_vegfrc = a_vegfrc - tempb
    a_raw = a_raw - temp*tempb
    a_dens1 = a_dens1 + (qss-qv1)*betap*temp0b
    a_betap = a_betap + (qss-qv1)*dens1*temp0b
    a_qss = a_qss + temp0b0
    a_qv1 = a_qv1 - temp0b0
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) a_betap = 0.0_8
  END SUBROUTINE A_QFLUX
!-------------------------------------------------------------------------
!-------------------------------------------------------------------------

!  Differentiation of smass in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: bet1 bet2 alph1 alph2 vegfrc
!   with respect to varying inputs: ra vegfrc fass
!------------------------------------------------------------------------------------------
!------------------------------------------------------------------------------------------
!------------------------------------------------------------------------------------------
!------------------------------------------------------------------------------------------
  SUBROUTINE A_SMASS(isti, fass, a_fass, rg, vegfrc, a_vegfrc, ra, a_ra&
&    , wwlt, wfc, alph1, a_alph1, alph2, a_alph2, bet1, a_bet1, bet2, &
&    a_bet2, t2nudf)
    IMPLICIT NONE
!------------------------------------------------------------------------------------------
!     SMASS COMPUTES SOIL MOISTURE NUDGING COEFFICIENTS
!------------------------------------------------------------------------------------------
!
!.........Arguments
! max. soil types
    INTEGER, PARAMETER :: nscat=16
    INTEGER, INTENT(IN) :: isti
    REAL, INTENT(IN) :: fass, rg, vegfrc, ra
    REAL :: a_fass, a_vegfrc, a_ra
    REAL, INTENT(IN) :: wwlt, wfc
    REAL :: alph1, alph2, bet1, bet2, t2nudf
    REAL :: a_alph1, a_alph2, a_bet1, a_bet2
!........Local variables
!... Real
    REAL :: fbet, falph, fra, ftext
    REAL :: a_fbet, a_fra, a_ftext
    REAL, DIMENSION(nscat) :: wfcx, wwltx
!... Parameters
! m/K, m for 6hr period
    REAL, PARAMETER :: a1max=-10.d-5, a2max=1.d-5
! m/K, m (Bouttier et al 1993)
    REAL, PARAMETER :: b1max=-10.d-3, b2max=1.d-3
! 1/6hr in 1/sec
    REAL, PARAMETER :: tassi=4.6296d-5
! 0.1 s/cm
    REAL, PARAMETER :: ramin=10.0D0
    REAL :: tempb2
    REAL :: tempb1
    REAL :: tempb0
    REAL :: tempb
!
!-- WFC is field capacity (M^3/M^3) (JN90)
      DATA WFCX   /  0.135D0, 0.150D0, 0.195D0, 0.255D0, 0.240D0, 0.255D0, 0.322D0,    &
                    0.325D0, 0.310D0, 0.370D0, 0.367D0, 0.367D0, 0.367D0, 0.367D0, 0.367D0, 0.367D0 /
!
!-- WWLT is wilting point (M^3/M^3) (JN90)
      DATA WWLTX  /  0.068D0, 0.075D0, 0.114D0, 0.179D0, 0.155D0, 0.175D0, 0.218D0,    &
                    0.250D0, 0.219D0, 0.283D0, 0.286D0, 0.286D0, 0.286D0, 0.286D0, 0.286D0, 0.286D0 /

!
    fbet = fass
    falph = rg/1370.0D0
!--TEXTURE FACTOR NORMALIZED BY LOAM (IST=5)
! scale by aerodynamic resistance
    fra = ramin/ra
    ftext = tassi*(wwlt+wfc)/(wwltx(5)+wfcx(5))*fra
!        write(6,*) ' ftot, fbet=',ftot, fbet,' ftext=',ftext/tassi
!
    tempb1 = a1max*falph*a_alph1
    tempb2 = a2max*falph*a_alph2
    tempb0 = b1max*a_bet1
    tempb = b2max*a_bet2
    a_fbet = ftext*vegfrc*tempb0 + ftext*vegfrc*tempb
    a_vegfrc = a_vegfrc + ftext*fbet*tempb0 - ftext*tempb1 - ftext*&
&      tempb2 + ftext*fbet*tempb
    a_ftext = fbet*vegfrc*tempb0 + (1.0D0-vegfrc)*tempb1 + (1.0D0-vegfrc&
&      )*tempb2 + fbet*vegfrc*tempb
    a_fra = tassi*(wwlt+wfc)*a_ftext/(wwltx(5)+wfcx(5))
    a_ra = -(ramin*a_fra/ra**2)
    a_fass = a_fbet
  END SUBROUTINE A_SMASS
!------------------------------------------------------------------------------------------
!------------------------------------------------------------------------------------------

!  Differentiation of soilprop in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: w2
!   with respect to varying inputs: w2
!------------------------------------------------------------------------------------------
!------------------------------------------------------------------------------------------
  SUBROUTINE A_SOILPROP(soilcbot, weight, itimestep, mavail, &
&    pxlsm_smois_init, fwsat, fwfc, fwwlt, fb, fcgsat, fjp, fas, fc2r, &
&    fc1sat, isti, w2, a_w2)
    IMPLICIT NONE
!.........Arguments
! max. soil types
    INTEGER, PARAMETER :: nscat=16
! min soil types
    INTEGER, PARAMETER :: nscatmin=16
    INTEGER, INTENT(IN) :: weight, itimestep, pxlsm_smois_init
    REAL, INTENT(IN) :: mavail
    REAL, DIMENSION(nscat), INTENT(IN) :: soilcbot
    REAL :: fwsat, fwfc, fwwlt, fb, fcgsat, fjp, fas, fc2r&
&    , fc1sat
    REAL, INTENT(INOUT) :: w2
    REAL, INTENT(INOUT) :: a_w2
    INTEGER :: isti
!........Local variables
    CHARACTER(len=4) :: avclass
    CHARACTER(len=4), DIMENSION(nscat) :: texid
!... Integer
    INTEGER :: s
!... Real
    REAL :: tfracbot, cfrac, sumsnd, sumcly, avs, avc, avslt
    REAL, DIMENSION(nscat) :: wsat, wfc, wwlt, b, cgsat, as, jp, c2r, &
&    c1sat
    REAL, DIMENSION(nscatmin) :: sand, clay
!.......... DATA statement for SOIL PARAMETERS for the 11 soil types
    DATA sand /92.5, 80.5, 61.1, 19.6, 4.0, 40.0, 57.1, 11.3, 26.8, 52.0&
&         , 6.5, 10.2, 1.0, 1.0, 1.0, 1.0/
    DATA clay /2.1, 4.1, 10.9, 19.1, 7.3, 18.8, 23.3, 32.2, 36.6, 43.0, &
&         46.2, 58.8, 1.0, 1.0, 1.0, 1.0/
    DATA texid /'Sand', 'Lsan', 'Sloa', 'Sill', 'Silt', 'Loam', 'Sclo', &
&         'Sicl', 'Cllo', 'Sacl', 'Sicy', 'Clay', 'Ormt', 'Wate', 'Bedr'&
&         , 'Othe'/
!
!-- WSAT is saturated soil moisture (M^3/M^3) (JN90)
    DATA wsat /0.395, 0.410, 0.435, 0.485, 0.451, 0.420, 0.477, 0.476, &
&         0.426, 0.482, 0.482, 0.482, 0.482, 0.482, 0.482, 0.482/
!
!-- WFC is field capacity (M^3/M^3) (JN90)
    DATA wfc /0.135, 0.150, 0.195, 0.255, 0.240, 0.255, 0.322, 0.325, &
&         0.310, 0.370, 0.367, 0.367, 0.367, 0.367, 0.367, 0.367/
!
!-- WWLT is wilting point (M^3/M^3) (JN90)
    DATA wwlt /0.068, 0.075, 0.114, 0.179, 0.155, 0.175, 0.218, 0.250, &
&         0.219, 0.283, 0.286, 0.286, 0.286, 0.286, 0.286, 0.286/
!
!-- B is slop of the retention curve (NP89)
    DATA b /4.05, 4.38, 4.90, 5.30, 5.39, 7.12, 7.75, 8.52, 10.40, 10.40&
&         , 11.40, 11.40, 11.40, 11.40, 11.40, 11.40/
!
!-- CGSAT is soil thermal coef. at saturation (10^-6 K M^2 J^-1) (NP89)
    DATA cgsat /3.222, 3.057, 3.560, 4.418, 4.111, 3.670, 3.593, 3.995, &
&         3.058, 3.729, 3.600, 3.600, 3.600, 3.600, 3.600, 3.600/
!
!-- JP is coefficient of WGEQ formulation (NP89)
    DATA jp /4, 4, 4, 6, 6, 6, 8, 10, 8, 10, 12, 12, 12, 12, 12, 12/
!
!-- AS is coefficient of WGEQ formulation (NP89)
    DATA as /0.387, 0.404, 0.219, 0.105, 0.148, 0.135, 0.127, 0.084, &
&         0.139, 0.075, 0.083, 0.083, 0.083, 0.083, 0.083, 0.083/
!
!-- C2R is the value of C2 for W2=0.5WSAT (NP89)
    DATA c2r /3.9, 3.7, 1.8, 0.8, 0.8, 0.8, 0.4, 0.6, 0.3, 0.3, 0.3, 0.3&
&         , 0.3, 0.3, 0.3, 0.3/
!
!-- C1SAT is the value of C1 at saturation (NP89)
    DATA c1sat /0.082, 0.098, 0.132, 0.153, 0.191, 0.213, 0.385, 0.227, &
&         0.421, 0.375, 0.342, 0.342, 0.342, 0.342, 0.342, 0.342/
!   
!-------------------------------Exicutable starts here--------------------
! Compute W2 using soil moisture availiability if pxlsm_smois_init (in namelist) is not zero
    IF (itimestep .EQ. 1 .AND. pxlsm_smois_init .GT. 0) a_w2 = 0.0_8
  END SUBROUTINE A_SOILPROP
!------------------------------------------------------------------------------------------
!------------------------------------------------------------------------------------------
END MODULE A_MODULE_SF_PXLSM
