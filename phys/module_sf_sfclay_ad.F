!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.6 (r4756) - 12 Feb 2013 10:43
!
!WRF:MODEL_LAYER:PHYSICS
!
MODULE A_MODULE_SF_SFCLAY

  USE module_sf_sfclay, ONLY: psimtb,psihtb
  IMPLICIT NONE
!-------------------------------------------------------------------          
  REAL, PARAMETER :: vconvc=1.
  REAL, PARAMETER :: czo=0.0185
  REAL, PARAMETER :: ozo=1.59e-5
!  REAL, DIMENSION(0:1000), SAVE :: psimtb, psihtb

CONTAINS
!  Differentiation of sfclay in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: p3d wspd ust u3d cpm pblh hfx
!                br t3d qsfc qv3d psih ustm znt psfc psim rmol
!                flqc qfx chs gz1oz0 v3d zol flhc dz8w mol
!   with respect to varying inputs: p3d wspd ust u3d cpm pblh hfx
!                br t3d qsfc qv3d psih ustm znt psfc psim rmol
!                flqc qfx chs gz1oz0 v3d zol flhc dz8w mol
!-------------------------------------------------------------------
  SUBROUTINE A_SFCLAY(u3d, a_u3d, v3d, a_v3d, t3d, a_t3d, qv3d, a_qv3d, &
&    p3d, a_p3d, dz8w, a_dz8w, cp, g, rovcp, r, xlv, psfc, a_psfc, chs, &
&    a_chs, chs2, cqs2, cpm, a_cpm, znt, a_znt, ust, a_ust, pblh, a_pblh&
&    , mavail, zol, a_zol, mol, a_mol, regime, psim, a_psim, psih, a_psih&
&    , fm, fh, xland, hfx, a_hfx, qfx, a_qfx, lh, tsk, flhc, a_flhc, flqc&
&    , a_flqc, qgh, qsfc, a_qsfc, rmol, a_rmol, u10, v10, th2, t2, q2, &
&    gz1oz0, a_gz1oz0, wspd, a_wspd, br, a_br, isfflx, dx, svp1, svp2, &
&    svp3, svpt0, ep1, ep2, karman, eomeg, stbolt, p1000mb, ids, ide, jds&
&    , jde, kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, &
&    kts, kte, ustm, a_ustm, ck, cka, cd, cda, isftcflx, iz0tlnd, &
&    scm_force_flux)
    IMPLICIT NONE
!-------------------------------------------------------------------
!-- U3D         3D u-velocity interpolated to theta points (m/s)
!-- V3D         3D v-velocity interpolated to theta points (m/s)
!-- T3D         temperature (K)
!-- QV3D        3D water vapor mixing ratio (Kg/Kg)
!-- P3D         3D pressure (Pa)
!-- dz8w        dz between full levels (m)
!-- CP          heat capacity at constant pressure for dry air (J/kg/K)
!-- G           acceleration due to gravity (m/s^2)
!-- ROVCP       R/CP
!-- R           gas constant for dry air (J/kg/K)
!-- XLV         latent heat of vaporization for water (J/kg)
!-- PSFC        surface pressure (Pa)
!-- ZNT         roughness length (m)
!-- UST         u* in similarity theory (m/s)
!-- USTM        u* in similarity theory (m/s) without vconv correction
!               used to couple with TKE scheme
!-- PBLH        PBL height from previous time (m)
!-- MAVAIL      surface moisture availability (between 0 and 1)
!-- ZOL         z/L height over Monin-Obukhov length
!-- MOL         T* (similarity theory) (K)
!-- REGIME      flag indicating PBL regime (stable, unstable, etc.)
!-- PSIM        similarity stability function for momentum
!-- PSIH        similarity stability function for heat
!-- FM          integrated stability function for momentum
!-- FH          integrated stability function for heat
!-- XLAND       land mask (1 for land, 2 for water)
!-- HFX         upward heat flux at the surface (W/m^2)
!-- QFX         upward moisture flux at the surface (kg/m^2/s)
!-- LH          net upward latent heat flux at surface (W/m^2)
!-- TSK         surface temperature (K)
!-- FLHC        exchange coefficient for heat (W/m^2/K)
!-- FLQC        exchange coefficient for moisture (kg/m^2/s)
!-- CHS         heat/moisture exchange coefficient for LSM (m/s)
!-- QGH         lowest-level saturated mixing ratio
!-- QSFC        ground saturated mixing ratio
!-- U10         diagnostic 10m u wind
!-- V10         diagnostic 10m v wind
!-- TH2         diagnostic 2m theta (K)
!-- T2          diagnostic 2m temperature (K)
!-- Q2          diagnostic 2m mixing ratio (kg/kg)
!-- GZ1OZ0      log(z/z0) where z0 is roughness length
!-- WSPD        wind speed at lowest model level (m/s)
!-- BR          bulk Richardson number in surface layer
!-- ISFFLX      isfflx=1 for surface heat and moisture fluxes
!-- DX          horizontal grid size (m)
!-- SVP1        constant for saturation vapor pressure (kPa)
!-- SVP2        constant for saturation vapor pressure (dimensionless)
!-- SVP3        constant for saturation vapor pressure (K)
!-- SVPT0       constant for saturation vapor pressure (K)
!-- EP1         constant for virtual temperature (R_v/R_d - 1) (dimensionless)
!-- EP2         constant for specific humidity calculation 
!               (R_d/R_v) (dimensionless)
!-- KARMAN      Von Karman constant
!-- EOMEG       angular velocity of earth's rotation (rad/s)
!-- STBOLT      Stefan-Boltzmann constant (W/m^2/K^4)
!-- ck          enthalpy exchange coeff at 10 meters
!-- cd          momentum exchange coeff at 10 meters
!-- cka         enthalpy exchange coeff at the lowest model level
!-- cda         momentum exchange coeff at the lowest model level
!-- isftcflx    =0, (Charnock and Carlson-Boland); =1, AHW Ck, Cd, =2 Garratt
!-- iz0tlnd     =0 Carlson-Boland, =1 Czil_new
!-- ids         start index for i in domain
!-- ide         end index for i in domain
!-- jds         start index for j in domain
!-- jde         end index for j in domain
!-- kds         start index for k in domain
!-- kde         end index for k in domain
!-- ims         start index for i in memory
!-- ime         end index for i in memory
!-- jms         start index for j in memory
!-- jme         end index for j in memory
!-- kms         start index for k in memory
!-- kme         end index for k in memory
!-- its         start index for i in tile
!-- ite         end index for i in tile
!-- jts         start index for j in tile
!-- jte         end index for j in tile
!-- kts         start index for k in tile
!-- kte         end index for k in tile
!-------------------------------------------------------------------
    INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, its, ite, jts, jte, kts, kte
!                                                               
    INTEGER, INTENT(IN) :: isfflx
    REAL, INTENT(IN) :: svp1, svp2, svp3, svpt0
    REAL, INTENT(IN) :: ep1, ep2, karman, eomeg, stbolt
    REAL, INTENT(IN) :: p1000mb
!
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: dz8w
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_dz8w
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: qv3d, p3d&
&    , t3d
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_qv3d, a_p3d, a_t3d
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: mavail, pblh, xland&
&    , tsk
    REAL, DIMENSION(ims:ime, jms:jme) :: a_pblh
    REAL, DIMENSION(ims:ime, jms:jme) :: u10, v10, th2, t2, q2, qsfc
    REAL, DIMENSION(ims:ime, jms:jme) :: a_qsfc
!
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: regime, hfx, qfx&
&    , lh, mol, rmol
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_hfx
!m the following 5 are change to memory size
!
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: gz1oz0, wspd, br&
&    , psim, psih, fm, fh
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_gz1oz0
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: u3d, v3d
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_u3d, a_v3d
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: psfc
    REAL, DIMENSION(ims:ime, jms:jme) :: a_psfc
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: znt, zol, ust, &
&    cpm, chs2, cqs2, chs
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_znt
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: flhc, flqc
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_flhc
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: qgh
    REAL, INTENT(IN) :: cp, g, rovcp, r, xlv, dx
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL :: ck, cka, cd, cda, &
&    ustm
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL :: a_ustm
    INTEGER, OPTIONAL, INTENT(IN) :: isftcflx, iz0tlnd
    INTEGER, OPTIONAL, INTENT(IN) :: scm_force_flux
! LOCAL VARS
    REAL, DIMENSION(its:ite) :: u1d, v1d, qv1d, p1d, t1d
    REAL, DIMENSION(its:ite) :: a_u1d, a_v1d, a_qv1d, a_p1d, a_t1d
    REAL, DIMENSION(its:ite) :: dz8w1d
    REAL, DIMENSION(its:ite) :: a_dz8w1d
    INTEGER :: i, j
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_ust
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_cpm
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_psih
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_psim
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_flqc
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_rmol
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_qfx
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_chs
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_wspd
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_zol
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_br
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_mol
    a_qv1d = 0.0_8
    a_v1d = 0.0_8
    a_dz8w1d = 0.0_8
    a_p1d = 0.0_8
    a_u1d = 0.0_8
    a_t1d = 0.0_8
    DO j=jte,jts,-1
      DO i=its,ite
        dz8w1d(i) = dz8w(i, 1, j)
        u1d(i) = u3d(i, 1, j)
        v1d(i) = v3d(i, 1, j)
        qv1d(i) = qv3d(i, 1, j)
        p1d(i) = p3d(i, 1, j)
        t1d(i) = t3d(i, 1, j)
      END DO
      CALL A_SFCLAY1D(j, u1d, a_u1d, v1d, a_v1d, t1d, a_t1d, qv1d, &
&                a_qv1d, p1d, a_p1d, dz8w1d, a_dz8w1d, cp, g, rovcp, r, &
&                xlv, psfc(ims, j), a_psfc(ims, j), chs(ims, j), a_chs(ims, j), &
&                chs2(ims, j), cqs2(ims, j), cpm(ims, j), a_cpm(ims, j), pblh(ims, &
&                j), a_pblh(ims, j), rmol(ims, j), a_rmol(ims, j), znt(ims, j), &
&                a_znt(ims, j), ust(ims, j), a_ust(ims, j), mavail(ims, j), zol(ims&
&                , j), a_zol(ims, j), mol(ims, j), a_mol(ims, j), regime(ims, j)&
&                , psim(ims, j), a_psim(ims, j), psih(ims, j), a_psih(ims, j), fm&
&                (ims, j), fh(ims, j), xland(ims, j), hfx(ims, j), a_hfx(ims, j), &
&                qfx(ims, j), a_qfx(ims, j), tsk(ims, j), u10(ims, j), v10(ims, j)&
&                , th2(ims, j), t2(ims, j), q2(ims, j), flhc(ims, j), a_flhc(ims, j&
&                ), flqc(ims, j), a_flqc(ims, j), qgh(ims, j), qsfc(ims, j), &
&                a_qsfc(ims, j), lh(ims, j), gz1oz0(ims, j), a_gz1oz0(ims, j), &
&                wspd(ims, j), a_wspd(ims, j), br(ims, j), a_br(ims, j), isfflx, &
&                dx, svp1, svp2, svp3, svpt0, ep1, ep2, karman, eomeg, &
&                stbolt, p1000mb, ids, ide, jds, jde, kds, kde, ims, ime&
&                , jms, jme, kms, kme, its, ite, jts, jte, kts, kte, &
&                isftcflx, iz0tlnd, scm_force_flux, ustm(ims, j), a_ustm(ims&
&                , j), ck(ims, j), cka(ims, j), cd(ims, j), cda(ims, j))
      DO i=ite,its,-1
        a_t3d(i, 1, j) = a_t3d(i, 1, j) + a_t1d(i)
        a_t1d(i) = 0.0_8
        a_p3d(i, 1, j) = a_p3d(i, 1, j) + a_p1d(i)
        a_p1d(i) = 0.0_8
        a_qv3d(i, 1, j) = a_qv3d(i, 1, j) + a_qv1d(i)
        a_qv1d(i) = 0.0_8
        a_v3d(i, 1, j) = a_v3d(i, 1, j) + a_v1d(i)
        a_v1d(i) = 0.0_8
        a_u3d(i, 1, j) = a_u3d(i, 1, j) + a_u1d(i)
        a_u1d(i) = 0.0_8
        a_dz8w(i, 1, j) = a_dz8w(i, 1, j) + a_dz8w1d(i)
        a_dz8w1d(i) = 0.0_8
      END DO
    END DO
  END SUBROUTINE A_SFCLAY
!-------------------------------------------------------------------

!  Differentiation of sfclay1d in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: qv1d wspd ust cpm psfcpa pblh
!                hfx dz8w1d ux p1d br qsfc psih ustm znt psim flqc
!                rmol qfx chs vx gz1oz0 zol flhc t1d mol
!   with respect to varying inputs: qv1d wspd ust cpm psfcpa pblh
!                hfx dz8w1d ux p1d br qsfc psih ustm znt psim flqc
!                rmol qfx chs vx gz1oz0 zol flhc t1d mol
!-------------------------------------------------------------------
  SUBROUTINE A_SFCLAY1D(j, ux, a_ux, vx, a_vx, t1d, a_t1d, qv1d, a_qv1d&
&    , p1d, a_p1d, dz8w1d, a_dz8w1d, cp, g, rovcp, r, xlv, psfcpa, &
&    a_psfcpa, chs, a_chs, chs2, cqs2, cpm, a_cpm, pblh, a_pblh, rmol, &
&    a_rmol, znt, a_znt, ust, a_ust, mavail, zol, a_zol, mol, a_mol, &
&    regime, psim, a_psim, psih, a_psih, fm, fh, xland, hfx, a_hfx, qfx, &
&    a_qfx, tsk, u10, v10, th2, t2, q2, flhc, a_flhc, flqc, a_flqc, qgh, &
&    qsfc, a_qsfc, lh, gz1oz0, a_gz1oz0, wspd, a_wspd, br, a_br, isfflx, &
&    dx, svp1, svp2, svp3, svpt0, ep1, ep2, karman, eomeg, stbolt, &
&    p1000mb, ids, ide, jds, jde, kds, kde, ims, ime, jms, jme, kms, kme&
&    , its, ite, jts, jte, kts, kte, isftcflx, iz0tlnd, scm_force_flux, &
&    ustm, a_ustm, ck, cka, cd, cda)
    IMPLICIT NONE
!jdf
!     DO I=its,ite
!       IF(UST(I).GE.0.1) THEN
!         RMOL(I)=RMOL(I)*(-FLHC(I))/(UST(I)*UST(I)*UST(I))
!       ELSE
!         RMOL(I)=RMOL(I)*(-FLHC(I))/(0.1*0.1*0.1)
!       ENDIF
!     ENDDO
!jdf
!                                                                                
!-------------------------------------------------------------------
    REAL, PARAMETER :: xka=2.4e-5
    REAL, PARAMETER :: prt=1.
    INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, its, ite, jts, jte, kts, kte, j
!                                                               
    INTEGER, INTENT(IN) :: isfflx
    REAL, INTENT(IN) :: svp1, svp2, svp3, svpt0
    REAL, INTENT(IN) :: ep1, ep2, karman, eomeg, stbolt
    REAL, INTENT(IN) :: p1000mb
!
    REAL, DIMENSION(ims:ime), INTENT(IN) :: mavail, pblh, xland, tsk
    REAL, DIMENSION(ims:ime) :: a_pblh
!
    REAL, DIMENSION(ims:ime), INTENT(IN) :: psfcpa
    REAL, DIMENSION(ims:ime) :: a_psfcpa
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: regime, hfx, qfx, mol, &
&    rmol
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_hfx
!m the following 5 are changed to memory size---
!
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: gz1oz0, wspd, br, psim, &
&    psih, fm, fh
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_gz1oz0
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: znt, zol, ust, cpm, chs2&
&    , cqs2, chs
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_znt
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: flhc, flqc
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_flhc
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: qgh
    REAL, DIMENSION(ims:ime) :: u10, v10, th2, t2, q2, qsfc, lh
    REAL, DIMENSION(ims:ime) :: a_qsfc
    REAL, INTENT(IN) :: cp, g, rovcp, r, xlv, dx
! MODULE-LOCAL VARIABLES, DEFINED IN SUBROUTINE SFCLAY
    REAL, DIMENSION(its:ite), INTENT(IN) :: dz8w1d
    REAL, DIMENSION(its:ite) :: a_dz8w1d
    REAL, DIMENSION(its:ite), INTENT(IN) :: ux, vx, qv1d, p1d, t1d
    REAL, DIMENSION(its:ite) :: a_ux, a_vx, a_qv1d, a_p1d, a_t1d
    REAL, DIMENSION(ims:ime), OPTIONAL :: ck, cka, cd, cda, ustm
    REAL, DIMENSION(ims:ime), OPTIONAL :: a_ustm
    INTEGER, OPTIONAL, INTENT(IN) :: isftcflx, iz0tlnd
    INTEGER, OPTIONAL, INTENT(IN) :: scm_force_flux
! LOCAL VARS
    REAL, DIMENSION(its:ite) :: za, thvx, zqkl, zqklp1, thx, qx, psih2, &
&    psim2, psih10, psim10, denomq, denomq2, denomt2, wspdi, gz2oz0, &
&    gz10oz0
    REAL, DIMENSION(its:ite) :: a_za, a_thvx, a_zqkl, a_thx, a_qx, &
&    a_denomq, a_wspdi
!
    REAL, DIMENSION(its:ite) :: rhox, govrth, tgdsa
    REAL, DIMENSION(its:ite) :: a_rhox, a_govrth
!
    REAL, DIMENSION(its:ite) :: scr3, scr4
    REAL, DIMENSION(its:ite) :: a_scr3, a_scr4
    REAL, DIMENSION(its:ite) :: thgb, psfc
    REAL, DIMENSION(its:ite) :: a_thgb, a_psfc
!
    INTEGER :: kl
    INTEGER :: n, i, k, kk, l, nzol, nk, nzol2, nzol10
    REAL :: pl, thcon, tvcon, e1
    REAL :: a_pl, a_thcon, a_tvcon
    REAL :: zl, tskv, dthvdz, dthvm, vconv, rzol, rzol2, rzol10, zol2, &
&    zol10
    REAL :: a_zl, a_tskv, a_dthvdz, a_dthvm, a_vconv, a_rzol
    REAL :: dtg, psix, dtthx, psix10, psit, psit2, psiq, psiq2, psiq10
    REAL :: a_dtg, a_psix, a_psit, a_psiq
    REAL :: fluxc, vsgd, z0q, visc, restar, czil, restar2
    REAL :: a_fluxc, a_visc, a_restar, a_czil, a_restar2
    REAL :: zw, zn1, zn2
    REAL :: a_zw, a_zn1, a_zn2
!-------------------------------------------------------------------
    INTEGER :: branch
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_ust
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_cpm
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_psih
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_psim
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_rmol
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_flqc
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_qfx
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_chs
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_wspd
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_zol
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_br
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_mol
    REAL :: temp3
    REAL :: temp2b4
    REAL :: temp17b4
    REAL :: temp20b0
    REAL :: temp2b3
    REAL :: temp2
    REAL :: temp17b3
    REAL :: temp1
    REAL :: temp2b2
    REAL :: temp17b2
    REAL :: temp0
    REAL :: temp2b1
    REAL :: temp17b1
    REAL :: temp2b0
    REAL :: temp17b0
    REAL :: a_x1
    REAL :: temp1b
    REAL :: temp6b1
    REAL :: a_amax10
    REAL :: temp6b0
    REAL :: temp15b
    REAL :: temp2b
    REAL :: temp1b0
    REAL :: x1
    REAL :: temp19
    REAL :: temp18
    REAL :: temp17
    REAL :: temp16
    REAL :: temp15
    REAL :: temp14
    REAL :: temp13
    REAL :: temp12
    REAL :: temp17b
    REAL :: temp11
    REAL :: temp4b
    REAL :: temp10
    REAL :: amax10
    REAL :: temp18b
    REAL :: temp10b0
    REAL :: temp20b
    REAL :: temp6b
    REAL :: temp4b1
    REAL :: temp4b0
    REAL :: temp8b4
    REAL :: temp8b3
    REAL :: temp10b
    REAL :: temp8b
    REAL :: temp8b2
    REAL :: temp8b1
    REAL :: temp8b0
    REAL :: temp
    REAL :: temp12b
    REAL :: max2
    REAL :: temp9
    REAL :: temp8
    REAL :: temp7
    REAL :: temp6
    REAL :: temp5
    REAL :: temp4
    DO i=its,ite
! PSFC cb
      psfc(i) = psfcpa(i)/1000.
    END DO
!                                                      
!----CONVERT GROUND TEMPERATURE TO POTENTIAL TEMPERATURE:  
!                                                            
    DO i=its,ite
      tgdsa(i) = tsk(i)
! PSFC cb
!        THGB(I)=TSK(I)*(100./PSFC(I))**ROVCP                
      thgb(i) = tsk(i)*(p1000mb/psfcpa(i))**rovcp
    END DO
!                                                            
!-----DECOUPLE FLUX-FORM VARIABLES TO GIVE U,V,T,THETA,THETA-VIR.,
!     T-VIR., QV, AND QC AT CROSS POINTS AND AT KTAU-1.  
!                                                                 
!     *** NOTE ***                                           
!         THE BOUNDARY WINDS MAY NOT BE ADEQUATELY AFFECTED BY FRICTION,         
!         SO USE ONLY INTERIOR VALUES OF UX AND VX TO CALCULATE 
!         TENDENCIES.                             
!                                                           
!     DO 24 I=its,ite
!        UX(I)=U1D(I)
!        VX(I)=V1D(I)
!  24 CONTINUE                                             
!.....SCR3(I,K) STORE TEMPERATURE,                           
!     SCR4(I,K) STORE VIRTUAL TEMPERATURE.                                       
    DO i=its,ite
! PL cb
      pl = p1d(i)/1000.
      scr3(i) = t1d(i)
!         THCON=(100./PL)**ROVCP                                                 
      thcon = (p1000mb*0.001/pl)**rovcp
      thx(i) = scr3(i)*thcon
      scr4(i) = scr3(i)
      thvx(i) = thx(i)
      qx(i) = 0.
    END DO
!                                                                                
    DO i=its,ite
      flhc(i) = 0.
      flqc(i) = 0.
      cpm(i) = cp
    END DO
!                                                                                
!     IF(IDRY.EQ.1)GOTO 80                                                   
    DO i=its,ite
      qx(i) = qv1d(i)
      tvcon = 1. + ep1*qx(i)
      thvx(i) = thx(i)*tvcon
      scr4(i) = scr3(i)*tvcon
    END DO
!                                                                                
    DO i=its,ite
      CALL PUSHREAL8(e1)
      e1 = svp1*EXP(svp2*(tgdsa(i)-svpt0)/(tgdsa(i)-svp3))
!  for land points QSFC can come from previous time step
      IF (xland(i) .GT. 1.5 .OR. qsfc(i) .LE. 0.0) THEN
        qsfc(i) = ep2*e1/(psfc(i)-e1)
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
! QGH CHANGED TO USE LOWEST-LEVEL AIR TEMP CONSISTENT WITH MYJSFC CHANGE
! Q2SAT = QGH IN LSM
      cpm(i) = cp*(1.+0.8*qx(i))
    END DO
!-----COMPUTE THE HEIGHT OF FULL- AND HALF-SIGMA LEVELS ABOVE GROUND             
!     LEVEL, AND THE LAYER THICKNESSES.                                          
    DO i=its,ite
      zqklp1(i) = 0.
      rhox(i) = psfc(i)*1000./(r*scr4(i))
    END DO
!                                                                                
    DO i=its,ite
      zqkl(i) = dz8w1d(i) + zqklp1(i)
    END DO
!                                                                                
    DO i=its,ite
      za(i) = 0.5*(zqkl(i)+zqklp1(i))
    END DO
!                                                                                
    DO i=its,ite
      govrth(i) = g/thx(i)
    END DO
!-----CALCULATE BULK RICHARDSON NO. OF SURFACE LAYER, ACCORDING TO               
!     AKB(1976), EQ(12).                                                         
    DO i=its,ite
      gz1oz0(i) = ALOG(za(i)/znt(i))
      gz10oz0(i) = ALOG(10./znt(i))
      wspd(i) = SQRT(ux(i)*ux(i) + vx(i)*vx(i))
      tskv = thgb(i)*(1.+ep1*qsfc(i))
      dthvdz = thvx(i) - tskv
!  Convective velocity scale Vc and subgrid-scale velocity Vsg
!  following Beljaars (1995, QJRMS) and Mahrt and Sun (1995, MWR)
!                                ... HONG Aug. 2001
!
!       VCONV = 0.25*sqrt(g/tskv*pblh(i)*dthvm)
!      Use Beljaars over land, old MM5 (Wyngaard) formula over water
      IF (xland(i) .LT. 1.5) THEN
        x1 = hfx(i)/rhox(i)/cp + ep1*tskv*qfx(i)/rhox(i)
        IF (x1 .LT. 0.D0) THEN
          CALL PUSHREAL8(fluxc)
          fluxc = 0.D0
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHREAL8(fluxc)
          fluxc = x1
          CALL PUSHCONTROL1B(1)
        END IF
        CALL PUSHREAL8(vconv)
        vconv = vconvc*(g/tgdsa(i)*pblh(i)*fluxc)**.33
        CALL PUSHCONTROL1B(1)
      ELSE
        IF (-dthvdz .GE. 0.D0) THEN
          CALL PUSHREAL8(dthvm)
          dthvm = -dthvdz
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHREAL8(dthvm)
          dthvm = 0.
          CALL PUSHCONTROL1B(1)
        END IF
        CALL PUSHREAL8(vconv)
        vconv = 2.*SQRT(dthvm)
        CALL PUSHCONTROL1B(0)
      END IF
      IF (dx/5000. - 1. .LT. 0.) THEN
        max2 = 0.
      ELSE
        max2 = dx/5000. - 1.
      END IF
      CALL PUSHREAL8(vsgd)
! Mahrt and Sun low-res correction
      vsgd = 0.32*max2**.33
      CALL PUSHREAL8(wspd(i))
      wspd(i) = SQRT(wspd(i)*wspd(i) + vconv*vconv + vsgd*vsgd)
      IF (wspd(i) .LT. 0.1) THEN
        wspd(i) = 0.1
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
        wspd(i) = wspd(i)
      END IF
      br(i) = govrth(i)*za(i)*dthvdz/(wspd(i)*wspd(i))
!  IF PREVIOUSLY UNSTABLE, DO NOT LET INTO REGIMES 1 AND 2
      IF (mol(i) .LT. 0.) THEN
        IF (br(i) .GT. 0.0) THEN
          br(i) = 0.0
          CALL PUSHCONTROL2B(2)
        ELSE
          CALL PUSHCONTROL2B(1)
          br(i) = br(i)
        END IF
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
    END DO
!jdf
!                                                                                
!-----DIAGNOSE BASIC PARAMETERS FOR THE APPROPRIATED STABILITY CLASS:            
!                                                                                
!                                                                                
!     THE STABILITY CLASSES ARE DETERMINED BY BR (BULK RICHARDSON NO.)           
!     AND HOL (HEIGHT OF PBL/MONIN-OBUKHOV LENGTH).                              
!                                                                                
!     CRITERIA FOR THE CLASSES ARE AS FOLLOWS:                                   
!                                                                                
!        1. BR .GE. 0.2;                                                         
!               REPRESENTS NIGHTTIME STABLE CONDITIONS (REGIME=1),               
!                                                                                
!        2. BR .LT. 0.2 .AND. BR .GT. 0.0;                                       
!               REPRESENTS DAMPED MECHANICAL TURBULENT CONDITIONS                
!               (REGIME=2),                                                      
!                                                                                
!        3. BR .EQ. 0.0                                                          
!               REPRESENTS FORCED CONVECTION CONDITIONS (REGIME=3),              
!                                                                                
!        4. BR .LT. 0.0                                                          
!               REPRESENTS FREE CONVECTION CONDITIONS (REGIME=4).                
!                                                                                
!CCCCC                                                                           
    DO i=its,ite
!CCCCC                                                                           
!CC     REMOVE REGIME 3 DEPENDENCE ON PBL HEIGHT                                 
!CC          IF(BR(I).LT.0..AND.HOL(I,J).GT.1.5)GOTO 310                         
      IF (br(i) .LT. 0.) THEN
!                                                                                
!-----CLASS 4; FREE CONVECTION:                                                  
!                                                                                
        IF (ust(i) .LT. 0.01) THEN
          zol(i) = br(i)*gz1oz0(i)
          CALL PUSHCONTROL1B(1)
        ELSE
          zol(i) = karman*govrth(i)*za(i)*mol(i)/(ust(i)*ust(i))
          CALL PUSHCONTROL1B(0)
        END IF
        zol10 = 10./za(i)*zol(i)
        IF (zol(i) .GT. 0.) THEN
          zol(i) = 0.
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
          zol(i) = zol(i)
        END IF
        IF (zol(i) .LT. -9.9999) THEN
          zol(i) = -9.9999
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
          zol(i) = zol(i)
        END IF
        IF (zol10 .GT. 0.) THEN
          zol10 = 0.
        ELSE
          zol10 = zol10
        END IF
        IF (zol10 .LT. -9.9999) THEN
          zol10 = -9.9999
        ELSE
          zol10 = zol10
        END IF
        CALL PUSHINTEGER4(nzol)
        nzol = INT(-(zol(i)*100.))
        rzol = -(zol(i)*100.) - nzol
        nzol10 = INT(-(zol10*100.))
        rzol10 = -(zol10*100.) - nzol10
        psim(i) = psimtb(nzol) + rzol*(psimtb(nzol+1)-psimtb(nzol))
        psih(i) = psihtb(nzol) + rzol*(psihtb(nzol+1)-psihtb(nzol))
        psih10(i) = psihtb(nzol10) + rzol10*(psihtb(nzol10+1)-psihtb(&
&          nzol10))
        IF (psih(i) .GT. 0.9*gz1oz0(i)) THEN
          psih(i) = 0.9*gz1oz0(i)
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
          psih(i) = psih(i)
        END IF
        IF (psim(i) .GT. 0.9*gz1oz0(i)) THEN
          psim(i) = 0.9*gz1oz0(i)
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
          psim(i) = psim(i)
        END IF
        CALL PUSHCONTROL2B(3)
      ELSE IF (br(i) .LT. 0.2) THEN
!                                                                                
!-----CLASS 1; STABLE (NIGHTTIME) CONDITIONS:                                    
!                                                                                
!                                                                                
!-----CLASS 2; DAMPED MECHANICAL TURBULENCE:                                     
!                                                                                
        IF (br(i) .EQ. 0.0) THEN
!                                                                                
!-----CLASS 3; FORCED CONVECTION:                                                
!                                                                                
          psim(i) = 0.0
          psih(i) = psim(i)
          IF (ust(i) .LT. 0.01) THEN
            zol(i) = br(i)*gz1oz0(i)
            CALL PUSHCONTROL1B(0)
          ELSE
            zol(i) = karman*govrth(i)*za(i)*mol(i)/(ust(i)*ust(i))
            CALL PUSHCONTROL1B(1)
          END IF
          CALL PUSHCONTROL2B(2)
        ELSE
          psim(i) = -(5.0*br(i)*gz1oz0(i)/(1.1-5.0*br(i)))
          IF (psim(i) .LT. -10.) THEN
            psim(i) = -10.
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
            psim(i) = psim(i)
          END IF
!.....AKB(1976), EQ(16).                                                         
          psih(i) = psim(i)
! Linear form: PSIM = -0.5*ZA/L; e.g, see eqn 16 of
! Blackadar, Modeling the nocturnal boundary layer, Preprints,
! Third Symposium on Atmospheric Turbulence Diffusion and Air Quality,
! Raleigh, NC, 1976
          zol(i) = br(i)*gz1oz0(i)/(1.00001-5.0*br(i))
          IF (zol(i) .GT. 0.5) THEN
! linear form ok
! Holtslag and de Bruin, J. App. Meteor 27, 689-704, 1988;
! see also, Launiainen, Boundary-Layer Meteor 76,165-179, 1995
! Eqn (8) of Launiainen, 1995
            zol(i) = (1.89*gz1oz0(i)+44.2)*br(i)*br(i) + (1.18*gz1oz0(i)&
&              -1.37)*br(i)
            IF (zol(i) .GT. 9.999) THEN
              zol(i) = 9.999
              CALL PUSHCONTROL2B(2)
            ELSE
              CALL PUSHCONTROL2B(1)
              zol(i) = zol(i)
            END IF
          ELSE
            CALL PUSHCONTROL2B(0)
          END IF
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        psim(i) = -(10.*gz1oz0(i))
        IF (psim(i) .LT. -10.) THEN
          psim(i) = -10.
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
          psim(i) = psim(i)
        END IF
        psih(i) = psim(i)
!       1.0 over Monin-Obukhov length
        IF (ust(i) .LT. 0.01) THEN
!ZA/L
          rmol(i) = br(i)*gz1oz0(i)
          CALL PUSHCONTROL1B(1)
        ELSE
!ZA/L
          rmol(i) = karman*govrth(i)*za(i)*mol(i)/(ust(i)*ust(i))
          CALL PUSHCONTROL1B(0)
        END IF
        IF (rmol(i) .GT. 9.999) THEN
          rmol(i) = 9.999
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
          rmol(i) = rmol(i)
        END IF
        CALL PUSHCONTROL2B(0)
      END IF
    END DO
!                                                                                
!-----COMPUTE THE FRICTIONAL VELOCITY:                                           
!     ZA(1982) EQS(2.60),(2.61).                                                 
!                                                                                
    DO i=its,ite
      dtg = thx(i) - thgb(i)
      CALL PUSHREAL8(psix)
      psix = gz1oz0(i) - psim(i)
      IF (gz1oz0(i) - psih(i) .LT. 2.) THEN
        CALL PUSHREAL8(psit)
        psit = 2.
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHREAL8(psit)
        psit = gz1oz0(i) - psih(i)
        CALL PUSHCONTROL1B(1)
      END IF
      IF (xland(i) - 1.5 .GE. 0) THEN
        CALL PUSHREAL8(zl)
        zl = znt(i)
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHREAL8(zl)
        zl = 0.01
        CALL PUSHCONTROL1B(1)
      END IF
      psiq = ALOG(karman*ust(i)*za(i)/xka + za(i)/zl) - psih(i)
! AHW: mods to compute ck, cd
      IF (PRESENT(isftcflx)) THEN
        IF (isftcflx .EQ. 1 .AND. xland(i) - 1.5 .GE. 0.) THEN
! v3.1
!             Z0Q = 1.e-4 + 1.e-3*(MAX(0.,UST(I)-1.))**2
! hfip1
!             Z0Q = 0.62*2.0E-5/UST(I) + 1.E-3*(MAX(0.,UST(I)-1.5))**2
! v3.2
          z0q = 1.e-4
          psiq = ALOG(za(i)/z0q) - psih(i)
          psit = psiq
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (isftcflx .EQ. 2 .AND. xland(i) - 1.5 .GE. 0.) THEN
! AHW: Garratt formula: Calculate roughness Reynolds number
!        Kinematic viscosity of air (linear approc to
!                 temp dependence at sea levle)
          visc = (1.32+0.009*(scr3(i)-273.15))*1.e-5
!!            VISC=1.5E-5
          restar = ust(i)*znt(i)/visc
          restar2 = 2.48*SQRT(SQRT(restar)) - 2.
          psit = gz1oz0(i) - psih(i) + restar2
          psiq = gz1oz0(i) - psih(i) + 2.28*SQRT(SQRT(restar)) - 2.
          CALL PUSHCONTROL2B(0)
        ELSE
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(2)
      END IF
      IF (PRESENT(iz0tlnd)) THEN
        IF (iz0tlnd .EQ. 1 .AND. xland(i) - 1.5 .LE. 0.) THEN
          CALL PUSHREAL8(zl)
          zl = znt(i)
!             CZIL RELATED CHANGES FOR LAND
          visc = (1.32+0.009*(scr3(i)-273.15))*1.e-5
          restar = ust(i)*zl/visc
!             Modify CZIL according to Chen & Zhang, 2009
          czil = 10.0**(-(0.40*(zl/0.07)))
          psit = gz1oz0(i) - psih(i) + czil*karman*SQRT(restar)
          psiq = gz1oz0(i) - psih(i) + czil*karman*SQRT(restar)
          CALL PUSHCONTROL2B(0)
        ELSE
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(2)
      END IF
      CALL PUSHREAL8(ust(i))
! TO PREVENT OSCILLATIONS AVERAGE WITH OLD VALUE 
      ust(i) = 0.5*ust(i) + 0.5*karman*wspd(i)/psix
! TKE coupling: compute ust without vconv for use in tke scheme
      wspdi(i) = SQRT(ux(i)*ux(i) + vx(i)*vx(i))
      IF (PRESENT(ustm)) THEN
        ustm(i) = 0.5*ustm(i) + 0.5*karman*wspdi(i)/psix
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
!        T2(I) = TH2(I)*(PSFC(I)/100.)**ROVCP                     
!       LATER Q2 WILL BE OVERWRITTEN FOR LAND POINTS IN SURFCE     
!       QA2(I,J) = Q2(I)                                         
!       UA10(I,J) = U10(I)                                      
!       VA10(I,J) = V10(I)                                     
!       write(*,1002)UST(I),KARMAN*WSPD(I),PSIX,KARMAN*WSPD(I)/PSIX
!                                                                                
      IF (xland(i) - 1.5 .LT. 0.) THEN
        IF (ust(i) .LT. 0.1) THEN
          ust(i) = 0.1
          CALL PUSHCONTROL2B(2)
        ELSE
          CALL PUSHCONTROL2B(1)
          ust(i) = ust(i)
        END IF
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
      CALL PUSHREAL8(mol(i))
      mol(i) = karman*dtg/psit/prt
      denomq(i) = psiq
    END DO
!                                                                                
!-----COMPUTE THE SURFACE SENSIBLE AND LATENT HEAT FLUXES:                       
    IF (PRESENT(scm_force_flux)) THEN
      IF (scm_force_flux .EQ. 1) THEN
        CALL PUSHCONTROL1B(0)
        GOTO 350
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    CALL PUSHCONTROL1B(1)
 350 IF (isfflx .EQ. 0) THEN
      a_wspdi = 0.0_8
      a_thx = 0.0_8
      a_qx = 0.0_8
      a_rhox = 0.0_8
      a_thgb = 0.0_8
      a_denomq = 0.0_8
    ELSE
!-----OVER WATER, ALTER ROUGHNESS LENGTH (ZNT) ACCORDING TO WIND (UST).
      DO i=its,ite
        IF (xland(i) - 1.5 .GE. 0) THEN
! AHW: change roughness length, and hence the drag coefficients Ck and Cd
          IF (PRESENT(isftcflx)) THEN
            IF (isftcflx .NE. 0) THEN
              IF ((ust(i)/1.06)**0.3 .GT. 1.0) THEN
                CALL PUSHREAL8(zw)
                zw = 1.0
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHREAL8(zw)
                zw = (ust(i)/1.06)**0.3
                CALL PUSHCONTROL1B(1)
              END IF
              zn1 = 0.011*ust(i)*ust(i)/g + ozo
              IF (ust(i) .LT. 0.01) THEN
                CALL PUSHREAL8(amax10)
                amax10 = 0.01
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHREAL8(amax10)
                amax10 = ust(i)
                CALL PUSHCONTROL1B(1)
              END IF
              CALL PUSHREAL8(zn2)
              zn2 = 10.*EXP(-(9.5*ust(i)**(-.3333))) + 0.11*1.5e-5/&
&                amax10
              CALL PUSHREAL8(znt(i))
              znt(i) = (1.0-zw)*zn1 + zw*zn2
              IF (znt(i) .GT. 2.85e-3) THEN
                znt(i) = 2.85e-3
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
                znt(i) = znt(i)
              END IF
              IF (znt(i) .LT. 1.27e-7) THEN
                CALL PUSHCONTROL3B(4)
              ELSE
                CALL PUSHCONTROL3B(3)
              END IF
            ELSE
              CALL PUSHCONTROL3B(1)
            END IF
          ELSE
            CALL PUSHCONTROL3B(2)
          END IF
        ELSE
          CALL PUSHCONTROL3B(0)
        END IF
        flqc(i) = rhox(i)*mavail(i)*ust(i)*karman/denomq(i)
        IF (thx(i) - thgb(i) .GE. 0.) THEN
          dtthx = thx(i) - thgb(i)
        ELSE
          dtthx = -(thx(i)-thgb(i))
        END IF
        IF (dtthx .GT. 1.e-5) THEN
          flhc(i) = cpm(i)*rhox(i)*ust(i)*mol(i)/(thx(i)-thgb(i))
          CALL PUSHCONTROL1B(0)
        ELSE
          flhc(i) = 0.
          CALL PUSHCONTROL1B(1)
        END IF
      END DO
!                                                                                
!-----COMPUTE SURFACE MOIST FLUX:                                               
!
!     IF(IDRY.EQ.1)GOTO 390
      IF (PRESENT(scm_force_flux)) THEN
        IF (scm_force_flux .EQ. 1) THEN
          CALL PUSHCONTROL1B(0)
          GOTO 100
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
!                                                                               
      DO i=its,ite
        CALL PUSHREAL8(qfx(i))
        qfx(i) = flqc(i)*(qsfc(i)-qx(i))
        IF (qfx(i) .LT. 0.) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
      END DO
!-----COMPUTE SURFACE HEAT FLUX:                                                 
!                                                                                
      DO i=its,ite
        IF (xland(i) - 1.5 .GT. 0.) THEN
          IF (PRESENT(isftcflx)) THEN
            IF (isftcflx .NE. 0) THEN
              CALL PUSHCONTROL3B(0)
            ELSE
              CALL PUSHCONTROL3B(1)
            END IF
          ELSE
            CALL PUSHCONTROL3B(2)
          END IF
        ELSE IF (xland(i) - 1.5 .LT. 0.) THEN
          CALL PUSHREAL8(hfx(i))
          hfx(i) = flhc(i)*(thgb(i)-thx(i))
          IF (hfx(i) .LT. -250.) THEN
            CALL PUSHCONTROL3B(5)
          ELSE
            CALL PUSHCONTROL3B(4)
          END IF
        ELSE
          CALL PUSHCONTROL3B(3)
        END IF
      END DO
      CALL PUSHCONTROL1B(1)
 100  a_denomq = 0.0_8
      DO i=ite,its,-1
        temp20b0 = karman*a_chs(i)/denomq(i)
        a_ust(i) = a_ust(i) + temp20b0
        a_denomq(i) = a_denomq(i) - ust(i)*temp20b0/denomq(i)
        a_chs(i) = 0.0_8
      END DO
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        a_wspdi = 0.0_8
        a_thx = 0.0_8
        a_qx = 0.0_8
        a_rhox = 0.0_8
        a_thgb = 0.0_8
      ELSE
        a_wspdi = 0.0_8
        a_thx = 0.0_8
        a_rhox = 0.0_8
        a_thgb = 0.0_8
        DO i=ite,its,-1
          CALL POPCONTROL3B(branch)
          IF (branch .LT. 3) THEN
            IF (branch .EQ. 0) THEN
              temp20b = ustm(i)**2*a_hfx(i)
              a_ustm(i) = a_ustm(i) + rhox(i)*wspdi(i)*2*ustm(i)*a_hfx(i&
&                )
              a_rhox(i) = a_rhox(i) + wspdi(i)*temp20b
              a_wspdi(i) = a_wspdi(i) + rhox(i)*temp20b
            END IF
            a_flhc(i) = a_flhc(i) + (thgb(i)-thx(i))*a_hfx(i)
            a_thgb(i) = a_thgb(i) + flhc(i)*a_hfx(i)
            a_thx(i) = a_thx(i) - flhc(i)*a_hfx(i)
            a_hfx(i) = 0.0_8
          ELSE IF (branch .NE. 3) THEN
            IF (branch .NE. 4) a_hfx(i) = 0.0_8
            CALL POPREAL8(hfx(i))
            a_flhc(i) = a_flhc(i) + (thgb(i)-thx(i))*a_hfx(i)
            a_thgb(i) = a_thgb(i) + flhc(i)*a_hfx(i)
            a_thx(i) = a_thx(i) - flhc(i)*a_hfx(i)
            a_hfx(i) = 0.0_8
          END IF
        END DO
        a_qx = 0.0_8
        DO i=ite,its,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) a_qfx(i) = 0.0_8
          CALL POPREAL8(qfx(i))
          a_flqc(i) = a_flqc(i) + (qsfc(i)-qx(i))*a_qfx(i)
          a_qsfc(i) = a_qsfc(i) + flqc(i)*a_qfx(i)
          a_qx(i) = a_qx(i) - flqc(i)*a_qfx(i)
          a_qfx(i) = 0.0_8
        END DO
        CALL POPCONTROL1B(branch)
      END IF
      DO i=ite,its,-1
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          temp18 = thx(i) - thgb(i)
          temp17b4 = ust(i)*mol(i)*a_flhc(i)/temp18
          temp19 = cpm(i)*rhox(i)
          temp17 = temp19/temp18
          temp18b = -(temp17*temp17b4)
          a_cpm(i) = a_cpm(i) + rhox(i)*temp17b4
          a_rhox(i) = a_rhox(i) + cpm(i)*temp17b4
          a_thx(i) = a_thx(i) + temp18b
          a_thgb(i) = a_thgb(i) - temp18b
          a_ust(i) = a_ust(i) + temp17*mol(i)*a_flhc(i)
          a_mol(i) = a_mol(i) + temp17*ust(i)*a_flhc(i)
          a_flhc(i) = 0.0_8
        ELSE
          a_flhc(i) = 0.0_8
        END IF
        temp17b3 = mavail(i)*karman*a_flqc(i)/denomq(i)
        a_rhox(i) = a_rhox(i) + ust(i)*temp17b3
        a_ust(i) = a_ust(i) + rhox(i)*temp17b3
        a_denomq(i) = a_denomq(i) - rhox(i)*ust(i)*temp17b3/denomq(i)
        a_flqc(i) = 0.0_8
        CALL POPCONTROL3B(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) GOTO 110
        ELSE IF (branch .NE. 2) THEN
          IF (branch .NE. 3) a_znt(i) = 0.0_8
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) a_znt(i) = 0.0_8
          zn1 = 0.011*ust(i)*ust(i)/g + ozo
          CALL POPREAL8(znt(i))
          a_zw = (zn2-zn1)*a_znt(i)
          a_zn1 = (1.0-zw)*a_znt(i)
          a_zn2 = zw*a_znt(i)
          a_znt(i) = 0.0_8
          CALL POPREAL8(zn2)
          a_ust(i) = a_ust(i) + 9.5*EXP(-(9.5*ust(i)**(-.3333)))*10.*&
&            .3333*ust(i)**(-1.3333)*a_zn2
          a_amax10 = -(1.5e-5*0.11*a_zn2/amax10**2)
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL8(amax10)
          ELSE
            CALL POPREAL8(amax10)
            a_ust(i) = a_ust(i) + a_amax10
          END IF
          a_ust(i) = a_ust(i) + 0.011*2*ust(i)*a_zn1/g
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL8(zw)
          ELSE
            CALL POPREAL8(zw)
            a_ust(i) = a_ust(i) + 0.3*(ust(i)/1.06)**(-0.7)*a_zw/1.06
          END IF
        END IF
        a_ust(i) = a_ust(i) + czo*2*ust(i)*a_znt(i)/g
        a_znt(i) = 0.0_8
 110    CONTINUE
      END DO
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      DO i=ite,its,-1
        a_hfx(i) = 0.0_8
        a_qfx(i) = 0.0_8
      END DO
      CALL POPCONTROL1B(branch)
    END IF
    a_za = 0.0_8
    a_scr3 = 0.0_8
    DO i=ite,its,-1
      a_psiq = a_denomq(i)
      a_denomq(i) = 0.0_8
      dtg = thx(i) - thgb(i)
      CALL POPREAL8(mol(i))
      temp17b2 = karman*a_mol(i)/(prt*psit)
      a_dtg = temp17b2
      a_psit = -(dtg*temp17b2/psit)
      a_mol(i) = 0.0_8
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .NE. 1) a_ust(i) = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        psix = gz1oz0(i) - psim(i)
        temp17b1 = karman*0.5*a_ustm(i)/psix
        a_wspdi(i) = a_wspdi(i) + temp17b1
        a_psix = -(wspdi(i)*temp17b1/psix)
        a_ustm(i) = 0.5*a_ustm(i)
      ELSE
        a_psix = 0.0_8
      END IF
      IF (ux(i)**2 + vx(i)**2 .EQ. 0.0_8) THEN
        temp17b = 0.0
      ELSE
        temp17b = a_wspdi(i)/(2.0*SQRT(ux(i)**2+vx(i)**2))
      END IF
      a_ux(i) = a_ux(i) + 2*ux(i)*temp17b
      a_vx(i) = a_vx(i) + 2*vx(i)*temp17b
      a_wspdi(i) = 0.0_8
      CALL POPREAL8(ust(i))
      temp17b0 = karman*0.5*a_ust(i)/psix
      a_wspd(i) = a_wspd(i) + temp17b0
      a_psix = a_psix - wspd(i)*temp17b0/psix
      a_ust(i) = 0.5*a_ust(i)
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        visc = (1.32+0.009*(scr3(i)-273.15))*1.e-5
        zl = znt(i)
        restar = ust(i)*zl/visc
        czil = 10.0**(-(0.40*(zl/0.07)))
        temp16 = SQRT(restar)
        a_gz1oz0(i) = a_gz1oz0(i) + a_psit + a_psiq
        a_psih(i) = a_psih(i) - a_psit - a_psiq
        IF (restar .EQ. 0.0_8) THEN
          a_restar = 0.0
        ELSE
          a_restar = czil*karman*a_psiq/(2.0*temp16)
        END IF
        temp15 = SQRT(restar)
        a_czil = karman*temp15*a_psit + karman*temp16*a_psiq
        IF (.NOT.restar .EQ. 0.0_8) a_restar = a_restar + czil*karman*&
&            a_psit/(2.0*temp15)
        temp15b = ust(i)*a_restar/visc
        a_zl = temp15b - 0.40*10.0**(-(0.40*(zl/0.07)))*LOG(10.0)*&
&          a_czil/0.07
        a_ust(i) = a_ust(i) + zl*a_restar/visc
        a_visc = -(zl*temp15b/visc)
        a_scr3(i) = a_scr3(i) + 1.e-5*0.009*a_visc
        CALL POPREAL8(zl)
        a_znt(i) = a_znt(i) + a_zl
        a_psiq = 0.0_8
        a_psit = 0.0_8
      END IF
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        visc = (1.32+0.009*(scr3(i)-273.15))*1.e-5
        restar = ust(i)*znt(i)/visc
        temp14 = SQRT(restar)
        a_gz1oz0(i) = a_gz1oz0(i) + a_psit + a_psiq
        a_psih(i) = a_psih(i) - a_psit - a_psiq
        IF (temp14 .EQ. 0.0_8 .OR. restar .EQ. 0.0_8) THEN
          a_restar = 0.0
        ELSE
          a_restar = 2.28*a_psiq/(2.0**2*SQRT(temp14)*temp14)
        END IF
        a_restar2 = a_psit
        temp13 = SQRT(restar)
        IF (.NOT.(temp13 .EQ. 0.0_8 .OR. restar .EQ. 0.0_8)) a_restar = &
&            a_restar + 2.48*a_restar2/(2.0**2*SQRT(temp13)*temp13)
        temp12b = znt(i)*a_restar/visc
        temp12 = ust(i)/visc
        a_ust(i) = a_ust(i) + temp12b
        a_visc = -(temp12*temp12b)
        a_znt(i) = a_znt(i) + temp12*a_restar
        a_scr3(i) = a_scr3(i) + 1.e-5*0.009*a_visc
        a_psiq = 0.0_8
        a_psit = 0.0_8
      ELSE IF (branch .NE. 1) THEN
        GOTO 120
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        a_psiq = a_psiq + a_psit
        z0q = 1.e-4
        a_za(i) = a_za(i) + a_psiq/za(i)
        a_psih(i) = a_psih(i) - a_psiq
        a_psiq = 0.0_8
        a_psit = 0.0_8
      END IF
 120  temp11 = za(i)/zl
      temp10 = ust(i)/xka
      temp10b0 = a_psiq/(karman*(temp10*za(i))+temp11)
      a_ust(i) = a_ust(i) + za(i)*karman*temp10b0/xka
      a_za(i) = a_za(i) + (1.0/zl+karman*temp10)*temp10b0
      a_zl = -(temp11*temp10b0/zl)
      a_psih(i) = a_psih(i) - a_psiq
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(zl)
        a_znt(i) = a_znt(i) + a_zl
      ELSE
        CALL POPREAL8(zl)
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(psit)
      ELSE
        CALL POPREAL8(psit)
        a_gz1oz0(i) = a_gz1oz0(i) + a_psit
        a_psih(i) = a_psih(i) - a_psit
      END IF
      CALL POPREAL8(psix)
      a_gz1oz0(i) = a_gz1oz0(i) + a_psix
      a_psim(i) = a_psim(i) - a_psix
      a_thx(i) = a_thx(i) + a_dtg
      a_thgb(i) = a_thgb(i) - a_dtg
    END DO
    a_govrth = 0.0_8
    DO i=ite,its,-1
      CALL POPCONTROL2B(branch)
      IF (branch .LT. 2) THEN
        IF (branch .EQ. 0) THEN
          temp10b = a_rmol(i)/za(i)
          a_za(i) = a_za(i) - rmol(i)*temp10b/za(i)
          a_rmol(i) = temp10b
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) a_rmol(i) = 0.0_8
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            temp9 = ust(i)**2
            temp8 = mol(i)/temp9
            temp8b3 = karman*a_rmol(i)
            temp8b4 = govrth(i)*za(i)*temp8b3/temp9
            a_govrth(i) = a_govrth(i) + temp8*za(i)*temp8b3
            a_za(i) = a_za(i) + temp8*govrth(i)*temp8b3
            a_mol(i) = a_mol(i) + temp8b4
            a_ust(i) = a_ust(i) - temp8*2*ust(i)*temp8b4
            a_rmol(i) = 0.0_8
          ELSE
            a_br(i) = a_br(i) + gz1oz0(i)*a_rmol(i)
            a_gz1oz0(i) = a_gz1oz0(i) + br(i)*a_rmol(i)
            a_rmol(i) = 0.0_8
          END IF
          a_psim(i) = a_psim(i) + a_psih(i)
          a_psih(i) = 0.0_8
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) a_psim(i) = 0.0_8
          a_gz1oz0(i) = a_gz1oz0(i) - 10.*a_psim(i)
          a_psim(i) = 0.0_8
        ELSE
          temp8b2 = a_rmol(i)/za(i)
          a_zol(i) = a_zol(i) + temp8b2
          a_za(i) = a_za(i) - zol(i)*temp8b2/za(i)
          a_rmol(i) = 0.0_8
          CALL POPCONTROL2B(branch)
          IF (branch .NE. 0) THEN
            IF (branch .NE. 1) a_zol(i) = 0.0_8
            a_gz1oz0(i) = a_gz1oz0(i) + (br(i)*1.18+br(i)**2*1.89)*a_zol&
&              (i)
            a_br(i) = a_br(i) + (1.18*gz1oz0(i)+(1.89*gz1oz0(i)+44.2)*2*&
&              br(i)-1.37)*a_zol(i)
            a_zol(i) = 0.0_8
          END IF
          temp8b1 = a_zol(i)/(1.00001-5.0*br(i))
          a_br(i) = a_br(i) + (br(i)*gz1oz0(i)*5.0/(1.00001-5.0*br(i))+&
&            gz1oz0(i))*temp8b1
          a_gz1oz0(i) = a_gz1oz0(i) + br(i)*temp8b1
          a_zol(i) = 0.0_8
          a_psim(i) = a_psim(i) + a_psih(i)
          a_psih(i) = 0.0_8
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) a_psim(i) = 0.0_8
          temp8b0 = -(5.0*a_psim(i)/(1.1-5.0*br(i)))
          a_br(i) = a_br(i) + (br(i)*gz1oz0(i)*5.0/(1.1-5.0*br(i))+&
&            gz1oz0(i))*temp8b0
          a_gz1oz0(i) = a_gz1oz0(i) + br(i)*temp8b0
          a_psim(i) = 0.0_8
        END IF
      ELSE IF (branch .EQ. 2) THEN
        temp8b = a_rmol(i)/za(i)
        a_zol(i) = a_zol(i) + temp8b
        a_za(i) = a_za(i) - zol(i)*temp8b/za(i)
        a_rmol(i) = 0.0_8
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          a_br(i) = a_br(i) + gz1oz0(i)*a_zol(i)
          a_gz1oz0(i) = a_gz1oz0(i) + br(i)*a_zol(i)
          a_zol(i) = 0.0_8
        ELSE
          temp7 = ust(i)**2
          temp6 = mol(i)/temp7
          temp6b0 = karman*a_zol(i)
          temp6b1 = govrth(i)*za(i)*temp6b0/temp7
          a_govrth(i) = a_govrth(i) + temp6*za(i)*temp6b0
          a_za(i) = a_za(i) + temp6*govrth(i)*temp6b0
          a_mol(i) = a_mol(i) + temp6b1
          a_ust(i) = a_ust(i) - temp6*2*ust(i)*temp6b1
          a_zol(i) = 0.0_8
        END IF
        a_psim(i) = 0.0_8
        a_psih(i) = 0.0_8
      ELSE
        temp6b = a_rmol(i)/za(i)
        a_zol(i) = a_zol(i) + temp6b
        a_za(i) = a_za(i) - zol(i)*temp6b/za(i)
        a_rmol(i) = 0.0_8
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          a_gz1oz0(i) = a_gz1oz0(i) + 0.9*a_psim(i)
          a_psim(i) = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          a_gz1oz0(i) = a_gz1oz0(i) + 0.9*a_psih(i)
          a_psih(i) = 0.0_8
        END IF
        a_rzol = (psimtb(nzol+1)-psimtb(nzol))*a_psim(i) + (psihtb(nzol+&
&          1)-psihtb(nzol))*a_psih(i)
        a_psih(i) = 0.0_8
        a_psim(i) = 0.0_8
        a_zol(i) = a_zol(i) - 100.*a_rzol
        CALL POPINTEGER4(nzol)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) a_zol(i) = 0.0_8
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) a_zol(i) = 0.0_8
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          temp5 = ust(i)**2
          temp4 = mol(i)/temp5
          temp4b0 = karman*a_zol(i)
          temp4b1 = govrth(i)*za(i)*temp4b0/temp5
          a_govrth(i) = a_govrth(i) + temp4*za(i)*temp4b0
          a_za(i) = a_za(i) + temp4*govrth(i)*temp4b0
          a_mol(i) = a_mol(i) + temp4b1
          a_ust(i) = a_ust(i) - temp4*2*ust(i)*temp4b1
          a_zol(i) = 0.0_8
        ELSE
          a_br(i) = a_br(i) + gz1oz0(i)*a_zol(i)
          a_gz1oz0(i) = a_gz1oz0(i) + br(i)*a_zol(i)
          a_zol(i) = 0.0_8
        END IF
      END IF
    END DO
    a_thvx = 0.0_8
    DO i=ite,its,-1
      tskv = thgb(i)*(1.+ep1*qsfc(i))
      dthvdz = thvx(i) - tskv
      temp4b = -(karman*za(i)*a_rmol(i))
      a_govrth(i) = a_govrth(i) + dthvdz*temp4b
      a_dthvdz = govrth(i)*temp4b
      a_za(i) = a_za(i) - karman*govrth(i)*dthvdz*a_rmol(i)
      a_rmol(i) = 0.0_8
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .NE. 1) a_br(i) = 0.0_8
      END IF
      temp3 = wspd(i)**2
      temp2 = za(i)/temp3
      temp2b4 = govrth(i)*dthvdz*a_br(i)/temp3
      a_govrth(i) = a_govrth(i) + temp2*dthvdz*a_br(i)
      a_dthvdz = a_dthvdz + temp2*govrth(i)*a_br(i)
      a_za(i) = a_za(i) + temp2b4
      a_wspd(i) = a_wspd(i) - temp2*2*wspd(i)*temp2b4
      a_br(i) = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) a_wspd(i) = 0.0_8
      CALL POPREAL8(wspd(i))
      IF (vsgd**2 + wspd(i)**2 + vconv**2 .EQ. 0.0_8) THEN
        temp2b3 = 0.0
      ELSE
        temp2b3 = a_wspd(i)/(2.0*SQRT(vsgd**2+wspd(i)**2+vconv**2))
      END IF
      a_vconv = 2*vconv*temp2b3
      a_wspd(i) = 2*wspd(i)*temp2b3
      CALL POPREAL8(vsgd)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(vconv)
        IF (dthvm .EQ. 0.0_8) THEN
          a_dthvm = 0.0
        ELSE
          a_dthvm = 2.*a_vconv/(2.0*SQRT(dthvm))
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(dthvm)
          a_dthvdz = a_dthvdz - a_dthvm
        ELSE
          CALL POPREAL8(dthvm)
        END IF
        a_tskv = 0.0_8
      ELSE
        CALL POPREAL8(vconv)
!        IF(x1.lt.0)THEN
!           temp2b2 = 0.0_8
!        ELSE
           IF(pblh(i) .eq. 0. .or. fluxc .eq. 0.) THEN
              temp2b2 = 0.0_8
           ELSE
              temp2b2 = g*.33*(g*(pblh(i)*fluxc/tgdsa(i)))**(-0.67)*vconvc*&
&                a_vconv/tgdsa(i)
           ENDIF
!        ENDIF
        a_pblh(i) = a_pblh(i) + fluxc*temp2b2
        a_fluxc = pblh(i)*temp2b2
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(fluxc)
          a_x1 = 0.0_8
        ELSE
          CALL POPREAL8(fluxc)
          a_x1 = a_fluxc
        END IF
        temp2b0 = a_x1/(cp*rhox(i))
        temp2b1 = ep1*a_x1/rhox(i)
        a_hfx(i) = a_hfx(i) + temp2b0
        a_rhox(i) = a_rhox(i) - tskv*qfx(i)*temp2b1/rhox(i) - hfx(i)*&
&          temp2b0/rhox(i)
        a_tskv = qfx(i)*temp2b1
        a_qfx(i) = a_qfx(i) + tskv*temp2b1
      END IF
      a_thvx(i) = a_thvx(i) + a_dthvdz
      a_tskv = a_tskv - a_dthvdz
      a_thgb(i) = a_thgb(i) + (ep1*qsfc(i)+1.)*a_tskv
      a_qsfc(i) = a_qsfc(i) + thgb(i)*ep1*a_tskv
      IF (ux(i)**2 + vx(i)**2 .EQ. 0.0_8) THEN
        temp2b = 0.0
      ELSE
        temp2b = a_wspd(i)/(2.0*SQRT(ux(i)**2+vx(i)**2))
      END IF
      a_ux(i) = a_ux(i) + 2*ux(i)*temp2b
      a_vx(i) = a_vx(i) + 2*vx(i)*temp2b
      a_wspd(i) = 0.0_8
      temp1 = za(i)/znt(i)
      temp1b0 = a_gz1oz0(i)/(temp1*znt(i))
      a_za(i) = a_za(i) + temp1b0
      a_znt(i) = a_znt(i) - temp1*temp1b0
      a_gz1oz0(i) = 0.0_8
    END DO
    DO i=ite,its,-1
      a_thx(i) = a_thx(i) - g*a_govrth(i)/thx(i)**2
      a_govrth(i) = 0.0_8
    END DO
    a_zqkl = 0.0_8
    DO i=ite,its,-1
      a_zqkl(i) = a_zqkl(i) + 0.5*a_za(i)
      a_za(i) = 0.0_8
    END DO
    DO i=ite,its,-1
      a_dz8w1d(i) = a_dz8w1d(i) + a_zqkl(i)
      a_zqkl(i) = 0.0_8
    END DO
    a_psfc = 0.0_8
    a_scr4 = 0.0_8
    DO i=ite,its,-1
      temp1b = 1000.*a_rhox(i)/(r*scr4(i))
      a_psfc(i) = a_psfc(i) + temp1b
      a_scr4(i) = a_scr4(i) - psfc(i)*temp1b/scr4(i)
      a_rhox(i) = 0.0_8
    END DO
    DO i=ite,its,-1
      a_qx(i) = a_qx(i) + cp*0.8*a_cpm(i)
      a_cpm(i) = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        a_psfc(i) = a_psfc(i) - ep2*e1*a_qsfc(i)/(psfc(i)-e1)**2
        a_qsfc(i) = 0.0_8
      END IF
      CALL POPREAL8(e1)
    END DO
    DO i=ite,its,-1
      tvcon = 1. + ep1*qx(i)
      a_scr3(i) = a_scr3(i) + tvcon*a_scr4(i)
      a_tvcon = thx(i)*a_thvx(i) + scr3(i)*a_scr4(i)
      a_scr4(i) = 0.0_8
      a_thx(i) = a_thx(i) + tvcon*a_thvx(i)
      a_thvx(i) = 0.0_8
      a_qx(i) = a_qx(i) + ep1*a_tvcon
      a_qv1d(i) = a_qv1d(i) + a_qx(i)
      a_qx(i) = 0.0_8
    END DO
    DO i=ite,its,-1
      a_cpm(i) = 0.0_8
      a_flqc(i) = 0.0_8
      a_flhc(i) = 0.0_8
    END DO
    DO i=ite,its,-1
      pl = p1d(i)/1000.
      thcon = (p1000mb*0.001/pl)**rovcp
      a_thx(i) = a_thx(i) + a_thvx(i)
      a_thvx(i) = 0.0_8
      a_scr3(i) = a_scr3(i) + thcon*a_thx(i) + a_scr4(i)
      a_scr4(i) = 0.0_8
      a_thcon = scr3(i)*a_thx(i)
      a_thx(i) = 0.0_8
      temp0 = 0.001*p1000mb/pl
      IF (temp0 .LE. 0.0_8 .AND. (rovcp .EQ. 0.0_8 .OR. rovcp .NE. INT(&
&          rovcp))) THEN
        a_pl = 0.0
      ELSE
        a_pl = -(rovcp*temp0**(rovcp-1)*temp0*a_thcon/pl)
      END IF
      a_t1d(i) = a_t1d(i) + a_scr3(i)
      a_scr3(i) = 0.0_8
      a_p1d(i) = a_p1d(i) + a_pl/1000.
    END DO
    DO i=ite,its,-1
      temp = p1000mb/psfcpa(i)
      IF (.NOT.(temp .LE. 0.0_8 .AND. (rovcp .EQ. 0.0_8 .OR. rovcp .NE. &
&          INT(rovcp)))) a_psfcpa(i) = a_psfcpa(i) - rovcp*temp**(rovcp-1&
&          )*tsk(i)*temp*a_thgb(i)/psfcpa(i)
      a_thgb(i) = 0.0_8
    END DO
    DO i=ite,its,-1
      a_psfcpa(i) = a_psfcpa(i) + a_psfc(i)/1000.
      a_psfc(i) = 0.0_8
    END DO
!         write(*,1001)FLHC(I),CPM(I),RHOX(I),UST(I),MOL(I),THX(I),THGB(I),I
 1001 FORMAT(&
&        f8.5,2x,f12.7,2x,f12.10,2x,f12.10,2x,f13.10,2x,f12.8,f12.8,2x,i3&
&          )
  END SUBROUTINE A_SFCLAY1D
!-------------------------------------------------------------------
END MODULE A_MODULE_SF_SFCLAY
