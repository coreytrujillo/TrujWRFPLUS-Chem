!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.6 (r4756) - 12 Feb 2013 10:43
!
!WRF:MEDIATION_LAYER:PHYSICS
!
MODULE A_MODULE_SURFACE_DRIVER
  IMPLICIT NONE
!=======================================================================

CONTAINS
!  Differentiation of surface_driver in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: wspd ust pblh hfx rmol qfx
!   with respect to varying inputs: v_phy wspd ust pblh th_phy
!                hfx qv_curr t_phy rmol p_phy qfx u_phy p8w rho
!                dz8w
!   RW status of diff variables: v_phy:out wspd:in-out ust:in-out
!                pblh:incr th_phy:out hfx:in-out qv_curr:out t_phy:out
!                rmol:in-out p_phy:out qfx:in-out u_phy:out p8w:out
!                rho:out dz8w:out

SUBROUTINE A_SURFACE_DRIVER(hydro_dt, &
       sfcheadrt, infxsrt, soldrain, acgrdflx, achfx, aclhf, acsnom, &
       acsnow, akhs, akms, &
       albedo, &
       br, &!a_br, 
       canwat, a_canwat, &
       chklowq, dt, dx, dz8w, a_dz8w, dzs, glw, grdflx, gsw, swdown, &
       gz1oz0, hfx, a_hfx, ht, ifsnow, isfflx, fractional_seaice, &
       seaice_albedo_opt, seaice_albedo_default    , seaice_thickness_opt, &
       seaice_thickness_default, seaice_snowdepth_opt, seaice_snowdepth_max, &
       seaice_snowdepth_min, &
       tice2tsk_if2cold, ifndalbsi, ifndicedepth, ifndsnowsi, isltyp, itimestep, &
       julian_in, ivgtyp, lowlyr, mavail, rmol, a_rmol, num_soil_layers, &
       p8w, a_p8w, pblh, a_pblh, pi_phy, pshltr, fm, fhh, psih, &
       psim, p_phy, a_p_phy, q10, q2, qfx, a_qfx, qsfc, &!a_qsfc, &
       qshltr, qz0, raincv, rho, a_rho, sfcevp, sfcexc, sfcrunoff, &
       smois, a_smois, smstav, smstot, snoalb, snow, snowc, snowh, &
       stepbl, smcrel, th10, th2, thz0, th_phy, a_th_phy, &
       tmn, tshltr, tsk, &!a_tsk, 
       tslb, a_tslb, &
       tyr, tyra, &
       tdly, tlag, lagday, nyear, nday, tmn_update, yr, t_phy, a_t_phy, u10, &
       udrunoff, ust, a_ust, uz0, u_frame, u_phy, a_u_phy, v10, &
       vegfra, vz0, v_frame, v_phy, a_v_phy, warm_rain, wspd, a_wspd, &
       xice, xland, z, znt, a_znt, zs, albsi, icedepth, snowsi, xicem, isice, &
       iswater, ct, tke_pbl, albbck, embck, lh, sh2o, shdmax, shdmin, z0, &
       flqc, &!a_flqc, 
       flhc, &!a_flhc, 
       psfc, &!a_psfc, 
       sst, sstsk, dtw, &
       sst_update, sst_skin, scm_force_skintemp, scm_force_flux, &
       t2, &
       emiss, sf_sfclay_physics, sf_surface_physics, &
       ra_lw_physics, mosaic_lu, mosaic_soil, landusef, soilctop, soilcbot, &
       ra, rs, nlcat, nscat, vegf_px, &!a_vegf_px, 
       snowncv, anal_interval, &
       lai, &!a_lai, 
       pxlsm_smois_init, pxlsm_soil_nudge, idveg, &
       iopt_crs, iopt_btr, iopt_run, iopt_sfc, iopt_frz, iopt_inf, iopt_rad, &
       iopt_alb, iopt_snf, iopt_tbot, iopt_stc, &
       isnowxy, tvxy, tgxy, canicexy, canliqxy, &
       eahxy, tahxy, cmxy, chxy, fwetxy, sneqvoxy, alboldxy, qsnowxy, wslakexy, &
       zwtxy, waxy, wtxy, tsnoxy, zsnsoxy, snicexy, snliqxy, lfmassxy, &
       rtmassxy, stmassxy, woodxy, stblcpxy, fastcpxy, xsaixy, taussxy, &
       t2mvxy, t2mbxy, q2mvxy, q2mbxy, tradxy, neexy, gppxy, nppxy, &
       fvegxy, runsfxy, runsbxy, ecanxy, edirxy, etranxy, fsaxy, firaxy, &
       aparxy, psnxy, savxy, sagxy, rssunxy, rsshaxy, bgapxy, wgapxy, tgvxy, &
       tgbxy, chvxy, chbxy, shgxy, shcxy, shbxy, evgxy, evbxy, ghvxy, ghbxy, &
       irgxy, ircxy, irbxy, trxy, evcxy, chleafxy, chucxy, chv2xy, chb2xy, chstarxy, &
       ua_phys, flx4, fvb, fbur, fgsn, ch, tsq, qsq, cov, &
!       om_tmp, om_s, om_u, om_v, om_depth, om_ml, om_lon, om_lat, &
!       okms, okme, rdx, rdy, msfu, msfv, msft, &
!       xtime, om_tini, om_sini, id, omdt, &
       slope_rad, topo_shading, shadowmask, swnorm, slope, slp_azi, declin, &
       solcon, coszen, hrang, &
       cmr_sfcdif, chr_sfcdif, cmc_sfcdif, chc_sfcdif, &
       ids, ide, jds, jde, kds, kde, ims, ime, jms, jme, kms, kme, &
       i_start, i_end, j_start, j_end, kts, kte, num_tiles, &
       qv_curr, a_qv_curr, qc_curr, qr_curr, qi_curr, qs_curr, qg_curr, &
       f_qv, f_qc, f_qr, f_qi, f_qs, f_qg, &
       capg, hol, mol, a_mol, rainncv, rainshv, rainbl, &
       regime, thc, qsg, qvg, qcg, soilt1, &
       tsnav, smfr3d, keepfr3dflag, dew, potevp, snopcx, soiltb, sr, &
       t2_ndg_old, q2_ndg_old, t2_ndg_new, q2_ndg_new, sn_ndg_old, sn_ndg_new, &
       t2obs, q2obs, uratx, vratx, tratx, sf_ocean_physics, oml_hml0, oml_gamma, &
       tml, t0ml, hml, h0ml, huml, hvml, f, tmoml, ustm, a_ustm, ck, cka, cd, cda, &
       isftcflx, iz0tlnd, isurban, mminlu, snotime, rdlai2d, usemonalb, &
       noahres, bldt, curr_secs, adapt_step_flag, bldtacttime, tsk_save, cldfra)

    USE module_state_description, only : SFCLAYSCHEME, PXSFCSCHEME, SLABSCHEME, PXLSMSCHEME
    USE module_model_constants

    USE a_module_sf_sfclay
    USE module_sf_sfclay

    USE a_module_sf_pxsfclay
    USE module_sf_pxsfclay

    USE a_module_sf_slab
    USE module_sf_slab
    USE module_sf_sfcdiags

    USE a_module_sf_pxlsm
    USE module_sf_pxlsm

    IMPLICIT NONE
!======================================================================
! Grid structure in physics part of WRF
!----------------------------------------------------------------------
! The horizontal velocities used in the physics are unstaggered
! relative to temperature/moisture variables. All predicted
! variables are carried at half levels except w, which is at full
! levels. Some arrays with names (*8w) are at w (full) levels.
!
!----------------------------------------------------------------------
! In WRF, kms (smallest number) is the bottom level and kme (largest
! number) is the top level.  In your scheme, if 1 is at the top level,
! then you have to reverse the order in the k direction.
!
!         kme      -   half level (no data at this level)
!         kme    ----- full level
!         kme-1    -   half level
!         kme-1  ----- full level
!         .
!         kms+2    -   half level
!         kms+2  ----- full level
!         kms+1    -   half level
!         kms+1  ----- full level
!         kms      -   half level
!         kms    ----- full level
!
!======================================================================
! Definitions
!-----------
! Theta      potential temperature (K)
! Qv         water vapor mixing ratio (kg/kg)
! Qc         cloud water mixing ratio (kg/kg)
! Qr         rain water mixing ratio (kg/kg)
! Qi         cloud ice mixing ratio (kg/kg)
! Qs         snow mixing ratio (kg/kg)
!-----------------------------------------------------------------
!-- itimestep     number of time steps
!-- GLW           downward long wave flux at ground surface (W/m^2)
!-- GSW           net short wave flux at ground surface (W/m^2)
!-- SWDOWN        downward short wave flux at ground surface (W/m^2)
!-- EMISS         surface emissivity (between 0 and 1)
!-- TSK           surface temperature (K)
!-- TMN           soil temperature at lower boundary (K)
!-- TYR           annual mean surface temperature of previous year (K)
!-- TYRA          accumulated surface temperature in the current year (K)
!-- TLAG          mean surface temperature of previous 140 days (K)
!-- TDLY          accumulated daily mean surface temperature of the current day (K)
!-- XLAND         land mask (1 for land, 2 for water)
!-- ZNT           time-varying roughness length (m)
!-- Z0            background roughness length (m)
!-- MAVAIL        surface moisture availability (between 0 and 1)
!-- UST           u* in similarity theory (m/s)
!-- MOL           T* (similarity theory) (K)
!-- HOL           PBL height over Monin-Obukhov length
!-- PBLH          PBL height (m)
!-- CAPG          heat capacity for soil (J/K/m^3)
!-- THC           thermal inertia (Cal/cm/K/s^0.5)
!-- SNOWC         flag indicating snow coverage (1 for snow cover)
!-- HFX           net upward heat flux at the surface (W/m^2)
!-- QFX           net upward moisture flux at the surface (kg/m^2/s)
!-- TAUX          RHO*U**2 for ocean coupling
!-- TAUY          RHO*U**2 for ocean coupling
!-- LH            net upward latent heat flux at surface (W/m^2)
!-- REGIME        flag indicating PBL regime (stable, unstable, etc.)
!-- tke_pbl       turbulence kinetic energy from PBL schemes (m^2/s^2)
!-- akhs          sfc exchange coefficient of heat/moisture from MYJ
!-- akms          sfc exchange coefficient of momentum from MYJ
!-- thz0          potential temperature at roughness length (K)
!-- uz0           u wind component at roughness length (m/s)
!-- vz0           v wind component at roughness length (m/s)
!-- qsfc          specific humidity at lower boundary (kg/kg)
!-- uratx         ratio of u over u10 (Added for obs-nudging)
!-- vratx         ratio of v over v10 (Added for obs-nudging)
!-- tratx         ratio of t over th2 (Added for obs-nudging)
!-- u10           diagnostic 10-m u component from surface layer
!-- v10           diagnostic 10-m v component from surface layer
!-- th2           diagnostic 2-m theta from surface layer and lsm
!-- t2            diagnostic 2-m temperature from surface layer and lsm
!-- q2            diagnostic 2-m mixing ratio from surface layer and lsm
!-- tshltr        diagnostic 2-m theta from MYJ
!-- th10          diagnostic 10-m theta from MYJ
!-- qshltr        diagnostic 2-m specific humidity from MYJ
!-- q10           diagnostic 10-m specific humidity from MYJ
!-- lowlyr        index of lowest model layer above ground
!-- rr            dry air density (kg/m^3)
!-- u_phy         u-velocity interpolated to theta points (m/s)
!-- v_phy         v-velocity interpolated to theta points (m/s)
!-- th_phy        potential temperature (K)
!-- moist         moisture array (4D - last index is species) (kg/kg)
!-- p_phy         pressure (Pa)
!-- pi_phy        exner function (dimensionless)
!-- pshltr        diagnostic shelter (2m) pressure from MYJ (Pa)
!-- p8w           pressure at full levels (Pa)
!-- t_phy         temperature (K)
!-- dz8w          dz between full levels (m)
!-- z             height above sea level (m)
!-- DX            horizontal space interval (m)
!-- DT            time step (second)
!-- PSFC          pressure at the surface (Pa)
!-- SST           sea-surface temperature (K)
!-- SSTSK         skin sea-surface temperature (K)
!-- DTW           warm layer temp diff (K)
!-- TSLB
!-- ZS
!-- DZS
!-- num_soil_layers number of soil layer
!-- IFSNOW      ifsnow=1 for snow-cover effects
!-- sf_ocean_physics       whether to call ocean model from slab (1 = oml, 2=3d PWP)
!-- oml_hml0      initial mixed layer depth (if real-data not available, default 50 m)
!-- oml_gamma     lapse rate below mixed layer in ocean (default 0.14 K m-1)
!-- ck            enthalpy exchange coeff at 10 meters
!-- cd            momentum exchange coeff at 10 meters
!-- cka           enthalpy exchange coeff at the lowest model level
!-- cda           momentum exchange coeff at the lowest model level
!!!!!!!!!!!!!!
!
!
!-- LANDUSEF     Landuse fraction                      ! P-X LSM
!-- SOILCTOP     Top soil fraction                     ! P-X LSM
!-- SOILCBOT     Bottom soil fraction                  ! P-X LSM
!-- RA           Aerodynamic resistence                        ! P-X LSM
!-- RS           Stomatal resistence                   ! P-X LSM
!-- NLCAT        Number of landuse categories          ! P-X LSM
!-- NSCAT        Number of soil categories             ! P-X LSM
!-- ch - drag coefficient for heat/moisture            ! MYNN LSM
!
!-- ids           start index for i in domain
!-- ide           end index for i in domain
!-- jds           start index for j in domain
!-- jde           end index for j in domain
!-- kds           start index for k in domain
!-- kde           end index for k in domain
!-- ims           start index for i in memory
!-- ime           end index for i in memory
!-- jms           start index for j in memory
!-- jme           end index for j in memory
!-- kms           start index for k in memory
!-- kme           end index for k in memory
!-- its           start index for i in tile
!-- ite           end index for i in tile
!-- jts           start index for j in tile
!-- jte           end index for j in tile
!-- kts           start index for k in tile
!-- kte           end index for k in tile
!
!******************************************************************
!------------------------------------------------------------------
    INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, kts, kte, num_tiles
    INTEGER, INTENT(IN) :: fractional_seaice
    INTEGER, INTENT(IN) :: seaice_albedo_opt
    REAL, INTENT(IN) :: seaice_albedo_default
    INTEGER, INTENT(IN) :: seaice_thickness_opt
    REAL, INTENT(IN) :: seaice_thickness_default
    INTEGER, INTENT(IN) :: seaice_snowdepth_opt
    REAL, INTENT(IN) :: seaice_snowdepth_max
    REAL, INTENT(IN) :: seaice_snowdepth_min
    INTEGER, INTENT(IN) :: ifndalbsi
    INTEGER, INTENT(IN) :: ifndicedepth
    INTEGER, INTENT(IN) :: ifndsnowsi
    INTEGER, INTENT(IN) :: nlcat, mosaic_lu, mosaic_soil
    INTEGER, INTENT(IN) :: nscat
!    INTEGER, INTENT(IN) :: history_interval
    INTEGER, INTENT(IN) :: sf_sfclay_physics, sf_surface_physics, &
&    ra_lw_physics, sst_update
    INTEGER, INTENT(IN), OPTIONAL :: sst_skin, tmn_update, &
&    scm_force_skintemp, scm_force_flux
    INTEGER, DIMENSION(num_tiles), INTENT(IN) :: i_start, i_end, j_start&
&    , j_end
    INTEGER, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: isltyp
    INTEGER, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: ivgtyp
    INTEGER, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: lowlyr
    INTEGER, INTENT(IN) :: ifsnow
    INTEGER, INTENT(IN) :: isfflx
    INTEGER, INTENT(IN) :: itimestep
    INTEGER, INTENT(IN) :: num_soil_layers
    REAL, INTENT(IN), OPTIONAL :: julian_in
    INTEGER, INTENT(IN) :: lagday
    INTEGER, INTENT(IN) :: stepbl
    INTEGER, INTENT(IN) :: isice
    INTEGER, INTENT(IN) :: iswater
    INTEGER, INTENT(IN), OPTIONAL :: isurban
    CHARACTER(len=*), INTENT(IN), OPTIONAL :: mminlu
    LOGICAL, INTENT(IN) :: warm_rain
    LOGICAL, INTENT(IN) :: tice2tsk_if2cold
    INTEGER, INTENT(INOUT), OPTIONAL :: nyear
    REAL, INTENT(INOUT), OPTIONAL :: nday
    INTEGER, INTENT(IN), OPTIONAL :: yr
    REAL, INTENT(IN) :: u_frame
    REAL, INTENT(IN) :: v_frame
!added by Wei Yu for WRF_HYDRO 
    REAL :: hydro_dt
    REAL, DIMENSION(ims:ime, jms:jme) :: sfcheadrt, infxsrt, soldrain
    REAL, DIMENSION(ims:ime, num_soil_layers, jms:jme), INTENT(INOUT) ::&
&    smois
    REAL, DIMENSION(ims:ime, num_soil_layers, jms:jme), INTENT(INOUT) ::&
&    a_smois
    REAL, DIMENSION(ims:ime, num_soil_layers, jms:jme), INTENT(INOUT) :: tslb
    REAL, DIMENSION(ims:ime, num_soil_layers, jms:jme), INTENT(INOUT) :: a_tslb

    REAL, DIMENSION(ims:ime, num_soil_layers, jms:jme) :: smcrel
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: glw
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: gsw, swdown
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: ht
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: raincv
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: sst
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT), OPTIONAL :: sstsk
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT), OPTIONAL :: dtw
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: tmn
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT), OPTIONAL :: tyr
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT), OPTIONAL :: tyra
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT), OPTIONAL :: tdly
    REAL, DIMENSION(ims:ime, lagday, jms:jme), INTENT(INOUT), OPTIONAL &
&    :: tlag
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: vegfra
!------fds (06/2010)--------------------------
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: xice
!---------------------------------------------
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: albsi
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: icedepth
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: snowsi
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: xland
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: xicem
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: mavail
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: snoalb
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: acsnow
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: &
&    snotime
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: akhs
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: akms
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: albedo
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: canwat
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_canwat
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: grdflx
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: hfx
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_hfx
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: rmol
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_rmol
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: pblh
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_pblh
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: q2
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: qfx
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_qfx
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: qsfc
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: qz0
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: sfcrunoff
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: smstav
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: smstot
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: snow
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: snowc
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: snowh
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: th2
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: thz0
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: tsk
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: udrunoff
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: ust
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_ust
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: uz0
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: vz0
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: wspd
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_wspd
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: znt
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_znt
!----------------------------------------------------------
    REAL, DIMENSION(ims:ime, jms:jme) :: br
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(OUT) :: chklowq
    REAL, DIMENSION(ims:ime, jms:jme) :: gz1oz0
    REAL, DIMENSION(ims:ime, jms:jme) :: pshltr
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(OUT) :: fhh
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(OUT) :: fm
    REAL, DIMENSION(ims:ime, jms:jme) :: psih
    REAL, DIMENSION(ims:ime, jms:jme) :: psim
    REAL, DIMENSION(ims:ime, jms:jme) :: q10
    REAL, DIMENSION(ims:ime, jms:jme) :: qshltr
    REAL, DIMENSION(ims:ime, jms:jme) :: th10
    REAL, DIMENSION(ims:ime, jms:jme) :: tshltr
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(OUT) :: u10
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(OUT) :: v10
    REAL, DIMENSION(ims:ime, jms:jme) :: psfc
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: acsnom
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: sfcevp
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT), OPTIONAL :: achfx
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT), OPTIONAL :: aclhf
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT), OPTIONAL :: &
&    acgrdflx
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: sfcexc
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: flhc
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: flqc
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: ct
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: dz8w
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_dz8w
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: p8w
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_p8w
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: pi_phy
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: p_phy
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_p_phy
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: rho
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_rho
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: th_phy
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_th_phy
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: t_phy
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_t_phy
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: u_phy
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_u_phy
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: v_phy
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_v_phy
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: z
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: tke_pbl
    REAL, DIMENSION(num_soil_layers), INTENT(IN) :: dzs
    REAL, DIMENSION(num_soil_layers), INTENT(IN) :: zs
    REAL, INTENT(IN) :: dt
    REAL, INTENT(IN) :: dx
    REAL, INTENT(IN), OPTIONAL :: bldt
    REAL, INTENT(IN), OPTIONAL :: curr_secs
    LOGICAL, INTENT(IN), OPTIONAL :: adapt_step_flag
    REAL, INTENT(INOUT), OPTIONAL :: bldtacttime
!  arguments for NCAR surface physics
! INOUT needed for NMM
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: albbck
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: embck
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: lh
    REAL, DIMENSION(ims:ime, num_soil_layers, jms:jme), INTENT(INOUT) ::&
&    sh2o
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: shdmax
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: shdmin
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: z0
    INTEGER, OPTIONAL, INTENT(IN) :: idveg, iopt_crs, iopt_btr, iopt_run&
&    , iopt_sfc, iopt_frz, iopt_inf, iopt_rad, iopt_alb, iopt_snf, &
&    iopt_tbot, iopt_stc
    INTEGER, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: &
&    isnowxy
    REAL, DIMENSION(ims:ime, -2:num_soil_layers, jms:jme), OPTIONAL, &
&    INTENT(INOUT) :: zsnsoxy
    REAL, DIMENSION(ims:ime, -2:0, jms:jme), OPTIONAL, INTENT(INOUT) :: &
&    tsnoxy, snicexy, snliqxy
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: tvxy, &
&    tgxy, canicexy, canliqxy, eahxy, tahxy, cmxy, chxy, fwetxy, sneqvoxy&
&    , alboldxy, qsnowxy, wslakexy, zwtxy, waxy, wtxy, lfmassxy, rtmassxy&
&    , stmassxy, woodxy, stblcpxy, fastcpxy, xsaixy, taussxy, t2mvxy, &
&    t2mbxy, q2mvxy, q2mbxy, tradxy, neexy, gppxy, nppxy, fvegxy, runsfxy&
&    , runsbxy, ecanxy, edirxy, etranxy, fsaxy, firaxy, aparxy, psnxy, &
&    savxy, sagxy
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: &
&    rssunxy, rsshaxy, bgapxy, wgapxy, tgvxy, tgbxy, chvxy, chbxy, shgxy&
&    , shcxy, shbxy, evgxy, evbxy, ghvxy, ghbxy, irgxy, ircxy, irbxy, &
&    trxy, evcxy, chleafxy, chucxy, chv2xy, chb2xy, chstarxy
! Noah UA changes
    LOGICAL, INTENT(IN) :: ua_phys
    REAL, DIMENSION(ims:ime, jms:jme) :: flx4, fvb, fbur, &
&    fgsn
!  arguments for Ocean Mixed Layer Model
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: tml, &
&    t0ml, hml, h0ml, huml, hvml
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(IN) :: f, tmoml
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL :: ck, cka, cd, cda, &
&    ustm
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL :: a_ustm
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: &
&    tsk_save
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: ch
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(IN) :: &
&    tsq, qsq, cov
    INTEGER, OPTIONAL, INTENT(IN) :: slope_rad, topo_shading
    INTEGER, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(IN) :: &
&    shadowmask
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: swnorm
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(IN) :: slope, &
&    slp_azi
    INTEGER, OPTIONAL, INTENT(IN) :: isftcflx, iz0tlnd
    INTEGER, OPTIONAL, INTENT(IN) :: sf_ocean_physics
    REAL, OPTIONAL, INTENT(IN) :: oml_hml0
    REAL, OPTIONAL, INTENT(IN) :: oml_gamma
!
!  Observation nudging
!
!Added for obs-nudging
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: uratx
!Added for obs-nudging
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: vratx
!Added for obs-nudging
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: tratx
!
!  PX LSM Surface Grid Analysis nudging
!
    INTEGER, OPTIONAL, INTENT(IN) :: pxlsm_smois_init, pxlsm_soil_nudge&
&    , anal_interval
    REAL, DIMENSION(ims:ime, nlcat, jms:jme), OPTIONAL, INTENT(INOUT) ::&
&    landusef
    REAL, DIMENSION(ims:ime, nscat, jms:jme), OPTIONAL, INTENT(INOUT) ::&
&    soilctop, soilcbot
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: &
&    vegf_px
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: ra
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: rs
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: lai
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(OUT) :: t2obs
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: q2obs
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: &
&    t2_ndg_old, q2_ndg_old, t2_ndg_new, q2_ndg_new, sn_ndg_old, &
&    sn_ndg_new
!
!
! Flags relating to the optional tendency arrays declared above
! Models that carry the optional tendencies will provdide the
! optional arguments at compile time; these flags all the model
! to determine at run-time whether a particular tracer is in
! use or not.
!
    LOGICAL, INTENT(IN), OPTIONAL :: f_qv, f_qc, f_qr, f_qi, f_qs, f_qg
! optional moisture tracers
! 2 time levels; if only one then use CURR
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(INOUT) &
&    :: qv_curr, qc_curr, qr_curr, qi_curr, qs_curr, qg_curr
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL :: a_qv_curr
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(IN) :: snowncv
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: capg
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: emiss
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: hol
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: mol
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: a_mol
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: regime
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(IN) :: rainncv
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(IN) :: rainshv
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: rainbl
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: t2
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(IN) :: thc
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: qsg
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: qvg
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: qcg
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: dew
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: soilt1
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: tsnav
! NMM LSM
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: potevp
! NMM LSM
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: snopcx
! NMM LSM
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: soiltb
! NMM and RUC LSM
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: sr
    REAL, DIMENSION(ims:ime, num_soil_layers, jms:jme), OPTIONAL, &
&    INTENT(INOUT) :: smfr3d
    REAL, DIMENSION(ims:ime, num_soil_layers, jms:jme), OPTIONAL, &
&    INTENT(INOUT) :: keepfr3dflag
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT), OPTIONAL :: noahres
!  LOCAL  VAR
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: v_phytmp
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_v_phytmp
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: u_phytmp
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_u_phytmp
    REAL, DIMENSION(ims:ime, jms:jme) :: zol
    REAL, DIMENSION(ims:ime, jms:jme) :: a_zol
    REAL, DIMENSION(ims:ime, jms:jme) :: qgh, chs, cpm, chs2, cqs2
    REAL, DIMENSION(ims:ime, jms:jme) :: a_chs, a_cpm
!Changed from I/O to local
    REAL, DIMENSION(ims:ime, jms:jme) :: a_br
    REAL, DIMENSION(ims:ime, jms:jme) :: a_gz1oz0
    REAL, DIMENSION(ims:ime, jms:jme) :: a_psih
    REAL, DIMENSION(ims:ime, jms:jme) :: a_psim
    REAL, DIMENSION(ims:ime, jms:jme) :: a_qsfc !May need to move back to I/O for PBL schemes other than ACM (e.g. QNSE, MYJ, MYNN, TEMF)
    REAL, DIMENSION(ims:ime, jms:jme) :: a_tsk !Not differentiably connected to ACM PBL, but may be to other PBL schemes
    REAL, DIMENSION(ims:ime, jms:jme) :: a_flhc !Needs to be I/O for if temfpbl added to AD/TL
    REAL, DIMENSION(ims:ime, jms:jme) :: a_flqc !Needs to be I/O for if temfpbl added to AD/TL
    REAL, DIMENSION(ims:ime, jms:jme) :: a_psfc !Needs to be I/O for if CAMZM Cumulus added to AD/TL
    REAL, DIMENSION(ims:ime, jms:jme) :: a_vegf_px !PX-Only
    REAL, DIMENSION(ims:ime, jms:jme) :: a_lai     !PX-Only
    REAL, DIMENSION(ims:ime, jms:jme) :: a_capg


! SSIB local variables
    REAL :: zdiff
    REAL, DIMENSION(ims:ime, jms:jme) :: xice_save
!
    REAL :: dtmin, dtbl
!
    INTEGER :: i, j, k, nk, jj, ij
    INTEGER :: gfdl_ntsflg
    LOGICAL :: radiation, myj, frpcpn, isisfc
    LOGICAL, INTENT(IN), OPTIONAL :: rdlai2d
    LOGICAL, INTENT(IN), OPTIONAL :: usemonalb
    REAL :: total_depth, mid_point_depth
    REAL :: tconst, tprior, tnew, yrday, deltat
    REAL :: swsave
    REAL, DIMENSION(ims:ime, jms:jme) :: gswsave
!-------------------------------------------------
! urban related variables are added to declaration
!-------------------------------------------------
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: &
&    cmr_sfcdif
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: &
&    chr_sfcdif
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: &
&    cmc_sfcdif
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: &
&    chc_sfcdif
    REAL, OPTIONAL, INTENT(IN) :: declin, solcon
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(IN) :: coszen
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(IN) :: hrang
!--------fds (06/2010)---------------------------------------------
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(IN) :: &
&    cldfra
    REAL :: day, cloudfrac
!------------------------------------------------------------------
!
    REAL, DIMENSION(ims:ime, jms:jme) :: hfx_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: qfx_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: lh_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: qsfc_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: tsk_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: znt_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: chs_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: chs2_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: cqs2_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: cpm_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: flhc_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: flqc_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: qgh_sea
!
    REAL, DIMENSION(ims:ime, jms:jme) :: psih_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: pblh_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: rmol_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: ust_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: qz0_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: tsk_local
!
    REAL :: xice_threshold
! cyl 3d ocean variable 
!    INTEGER :: okms, okme
!    REAL, DIMENSION(ims:ime, okms:okme, jms:jme), OPTIONAL, INTENT(INOUT&
!&    ) :: om_tmp, om_s, om_u, om_v, om_depth
!    REAL, DIMENSION(ims:ime, okms:okme, jms:jme), OPTIONAL, INTENT(IN) &
!&    :: om_tini, om_sini
!    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: om_ml&
!&    , om_lat, om_lon
!    REAL, OPTIONAL, INTENT(IN) :: rdx, rdy, xtime, omdt
!    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(IN) :: msfu, &
!&    msfv, msft
!    INTEGER, OPTIONAL, INTENT(IN) :: id
!
!------------------------------------------------------------------
    CHARACTER(len=256) :: message
    REAL :: next_bl_time
    LOGICAL :: run_param, doing_adapt_dt, decided
    LOGICAL :: do_adapt
    INTEGER :: ad_from
    INTEGER :: ad_to
    INTEGER :: ad_from0
    INTEGER :: ad_to0
    INTEGER :: branch
    REAL :: abs1
    REAL :: abs0
!
!
!------------------------------------------------------------------
!
    IF (sf_sfclay_physics .NE. 0) THEN
      IF (fractional_seaice .EQ. 0) THEN
        xice_threshold = 0.5
      ELSE IF (fractional_seaice .EQ. 1) THEN
        xice_threshold = 0.02
      END IF
!$OMP PARALLEL DO &
!$OMP PRIVATE (ij, i, j, k)
      DO ij=1,num_tiles
        DO j=j_start(ij),j_end(ij)
          DO k=kms,kme
            DO i=i_start(ij),i_end(ij)
              v_phytmp(i, k, j) = 0.
              u_phytmp(i, k, j) = 0.
            END DO
          END DO
          DO i=i_start(ij),i_end(ij)
            cpm(i, j) = 0.
          END DO
        END DO
      END DO
!$OMP END PARALLEL DO

! RAINBL in mm (Accumulation between PBL calls)
      IF (PRESENT(rainncv) .AND. PRESENT(rainbl)) THEN
!$OMP PARALLEL DO   &
!$OMP PRIVATE ( ij, i, j, k )
        DO ij=1,num_tiles
          DO j=j_start(ij),j_end(ij)
            DO i=i_start(ij),i_end(ij)
              rainbl(i, j) = rainbl(i, j) + raincv(i, j) + rainncv(i, j)
              IF (PRESENT(rainshv)) rainbl(i, j) = rainbl(i, j) + &
&                  rainshv(i, j)
              IF (rainbl(i, j) .LT. 0.0) THEN
                rainbl(i, j) = 0.0
              ELSE
                rainbl(i, j) = rainbl(i, j)
              END IF
            END DO
          END DO
        END DO
!$OMP END PARALLEL DO
      ELSE IF (PRESENT(rainbl)) THEN
!$OMP PARALLEL DO   &
!$OMP PRIVATE ( ij, i, j, k )
        DO ij=1,num_tiles
          DO j=j_start(ij),j_end(ij)
            DO i=i_start(ij),i_end(ij)
              rainbl(i, j) = rainbl(i, j) + raincv(i, j)
              IF (PRESENT(rainshv)) rainbl(i, j) = rainbl(i, j) + &
&                  rainshv(i, j)
              IF (rainbl(i, j) .LT. 0.0) THEN
                rainbl(i, j) = 0.0
              ELSE
                rainbl(i, j) = rainbl(i, j)
              END IF
            END DO
          END DO
        END DO
!$OMP END PARALLEL DO
      END IF
! Update SST
      IF (sst_update .EQ. 1) THEN
!$OMP PARALLEL DO   &
!$OMP PRIVATE ( ij, i, j, k )
        DO ij=1,num_tiles
          DO j=j_start(ij),j_end(ij)
            DO i=i_start(ij),i_end(ij)
              IF (xland(i, j) .GT. 1.5 .AND. xice(i, j) .GE. &
&                  xice_threshold .AND. xicem(i, j) .LT. xice_threshold) &
&              THEN
! water point turns to sea-ice point
                xicem(i, j) = xice(i, j)
                xland(i, j) = 1.
                vegfra(i, j) = 0.
                tmn(i, j) = 271.4
! Over new ice, initial guesses of ALBEDO and EMISS are
! based on default water and ice values for albedo and
! emissivity.  The land-surface schemes can update these
! values
                SELECT CASE  (seaice_albedo_opt) 
                CASE (0, 1) 
                  albedo(i, j) = seaice_albedo_default*xice(i, j) + 0.08&
&                    *(1.0-xice(i, j))
                CASE (2) 
                  albedo(i, j) = albsi(i, j)*xice(i, j) + 0.08*(1.0-xice&
&                    (i, j))
                END SELECT
                emiss(i, j) = 0.98*xice(i, j) + 0.98*(1.0-xice(i, j))
                DO nk=1,num_soil_layers
                  tslb(i, nk, j) = tsk(i, j)
                  smois(i, nk, j) = 1.0
                END DO
              END IF
              IF (xland(i, j) .GT. 1.5) THEN
                IF (sst(i, j) .LT. 350. .AND. sst(i, j) .GT. 250.) THEN
                  tsk(i, j) = sst(i, j)
                  tslb(i, 1, j) = sst(i, j)
                END IF
              END IF
              IF (xland(i, j) .LT. 1.5 .AND. xicem(i, j) .GE. &
&                  xice_threshold .AND. xice(i, j) .LT. xice_threshold) &
&              THEN
! sea-ice point turns to water point
                xland(i, j) = 2.
                vegfra(i, j) = 0.
                snow(i, j) = 0.
                snowc(i, j) = 0.
                tmn(i, j) = sst(i, j)
                albedo(i, j) = 0.08
                emiss(i, j) = 0.98
                DO nk=1,num_soil_layers
                  tslb(i, nk, j) = sst(i, j)
                  smois(i, nk, j) = 1.0
                END DO
              END IF
              xicem(i, j) = xice(i, j)
            END DO
          END DO
        END DO
!$OMP END PARALLEL DO
      END IF
!
! Modified for adaptive time step
!
      doing_adapt_dt = .false.
      IF (PRESENT(adapt_step_flag)) THEN
        IF (adapt_step_flag) doing_adapt_dt = .true.
      END IF
!  Do we run through this scheme or not?
!    Test 1:  If this is the initial model time, then yes.
!                ITIMESTEP=1
!    Test 2:  If the user asked for the surface to be run every time step, then yes.
!                BLDT=0 or STEPBL=1
!    Test 3:  If not adaptive dt, and this is on the requested surface frequency, then yes.
!                MOD(ITIMESTEP,STEPBL)=0
!    Test 4:  If using adaptive dt and the current time is past the last requested activate surface time, then yes.
!                CURR_SECS >= BLDTACTTIME
!  If we do run through the scheme, we set the flag run_param to TRUE and we set the decided flag
!  to TRUE.  The decided flag says that one of these tests was able to say "yes", run the scheme.
!  We only proceed to other tests if the previous tests all have left decided as FALSE.
      run_param = .false.
      decided = .false.
      IF (.NOT.decided .AND. itimestep .EQ. 1) THEN
        run_param = .true.
        decided = .true.
      END IF
      IF (PRESENT(bldt)) THEN
        IF (.NOT.decided .AND. (bldt .EQ. 0. .OR. stepbl .EQ. 1)) THEN
          run_param = .true.
          decided = .true.
        END IF
      ELSE IF (.NOT.decided .AND. stepbl .EQ. 1) THEN
        run_param = .true.
        decided = .true.
      END IF
      IF (.NOT.decided .AND. (.NOT.doing_adapt_dt) .AND. MOD(itimestep, &
&          stepbl) .EQ. 0) THEN
        run_param = .true.
        decided = .true.
      END IF
      IF (.NOT.decided .AND. doing_adapt_dt .AND. curr_secs .GE. &
&          bldtacttime) run_param = .true.
      IF (run_param) THEN
        radiation = .false.
        IF (ra_lw_physics .GT. 0) radiation = .true.
!----
! CALCULATE CONSTANT
! Surface schemes need PBL time step for updates and accumulations
! Assume these schemes provide no tendencies
        IF (PRESENT(adapt_step_flag)) THEN
          IF (adapt_step_flag) THEN
            do_adapt = .true.
          ELSE
            do_adapt = .false.
          END IF
        ELSE
          do_adapt = .false.
        END IF
        IF (PRESENT(bldt)) THEN
          IF (bldt .EQ. 0.) THEN
            dtbl = dt
          ELSE IF (do_adapt) THEN
            dtbl = bldt*60.
          ELSE
            dtbl = dt*stepbl
          END IF
        ELSE
          dtbl = dt*stepbl
        END IF
! SAVE OLD VALUES
!$OMP PARALLEL DO   &
!$OMP PRIVATE ( ij, i, j, k )
        DO ij=1,num_tiles
          ad_from0 = j_start(ij)
          DO j=ad_from0,j_end(ij)
            ad_from = i_start(ij)
            DO i=ad_from,i_end(ij)
! PSFC : in Pa
              psfc(i, j) = p8w(i, kts, j)
! REVERSE ORDER IN THE VERTICAL DIRECTION
              DO k=kts,kte
                v_phytmp(i, k, j) = v_phy(i, k, j) + v_frame
                u_phytmp(i, k, j) = u_phy(i, k, j) + u_frame
              END DO
            END DO
            CALL PUSHINTEGER4(i - 1)
            CALL PUSHINTEGER4(ad_from)
          END DO
          CALL PUSHINTEGER4(j - 1)
          CALL PUSHINTEGER4(ad_from0)
        END DO
!$OMP END PARALLEL DO

        CALL PUSHREAL8ARRAY(ustm, (ime-ims+1)*(jme-jms+1))
        CALL PUSHREAL8ARRAY(br, (ime-ims+1)*(jme-jms+1))
        CALL PUSHREAL8ARRAY(wspd, (ime-ims+1)*(jme-jms+1))
        CALL PUSHREAL8ARRAY(gz1oz0, (ime-ims+1)*(jme-jms+1))
        CALL PUSHREAL8ARRAY(qsfc, (ime-ims+1)*(jme-jms+1))
        CALL PUSHREAL8ARRAY(flqc, (ime-ims+1)*(jme-jms+1))
        CALL PUSHREAL8ARRAY(flhc, (ime-ims+1)*(jme-jms+1))
        CALL PUSHREAL8ARRAY(qfx, (ime-ims+1)*(jme-jms+1))
        CALL PUSHREAL8ARRAY(hfx, (ime-ims+1)*(jme-jms+1))
        CALL PUSHREAL8ARRAY(psih, (ime-ims+1)*(jme-jms+1))
        CALL PUSHREAL8ARRAY(psim, (ime-ims+1)*(jme-jms+1))
        CALL PUSHREAL8ARRAY(mol, (ime-ims+1)*(jme-jms+1))
        CALL PUSHREAL8ARRAY(ust, (ime-ims+1)*(jme-jms+1))
        CALL PUSHREAL8ARRAY(znt, (ime-ims+1)*(jme-jms+1))
        CALL PUSHREAL8ARRAY(cpm, (ime-ims+1)*(jme-jms+1))
!$OMP PARALLEL DO   &
!$OMP PRIVATE ( ij, i, j, k )
        DO ij=1,num_tiles
          SELECT CASE  (sf_sfclay_physics) 
          CASE (sfclayscheme) 
            IF (PRESENT(qv_curr) .AND. PRESENT(mol) .AND. PRESENT(regime&
&                ) .AND. .true.) THEN
              CALL SFCLAY(u_phytmp, v_phytmp, t_phy, qv_curr, p_phy, &
&                    dz8w, cp, g, rcp, r_d, xlv, psfc, chs, chs2, cqs2, &
&                    cpm, znt, ust, pblh, mavail, zol, mol, regime, psim&
&                    , psih, fm, fhh, xland, hfx, qfx, lh, tsk, flhc, &
&                    flqc, qgh, qsfc, rmol, u10, v10, th2, t2, q2, gz1oz0&
&                    , wspd, br, isfflx, dx, svp1, svp2, svp3, svpt0, &
&                    ep_1, ep_2, karman, eomeg, stbolt, p1000mb, ids, ide&
&                    , jds, jde, kds, kde, ims, ime, jms, jme, kms, kme, &
&                    i_start(ij), i_end(ij), j_start(ij), j_end(ij), kts&
&                    , kte, ustm, ck, cka, cd, cda, isftcflx, iz0tlnd, &
&                    scm_force_flux)
            END IF
          CASE (pxsfcscheme) 
            IF (PRESENT(qv_curr) .AND. PRESENT(mol) .AND. PRESENT(regime&
&                ) .AND. .true.) THEN
              CALL PXSFCLAY(u_phytmp, v_phytmp, t_phy, th_phy, qv_curr, &
&                      p_phy, dz8w, cp, g, rcp, r_d, xlv, psfc, chs, chs2&
&                      , cqs2, cpm, znt, ust, pblh, mavail, zol, mol, &
&                      regime, psim, psih, xland, hfx, qfx, lh, tsk, flhc&
&                      , flqc, qgh, qsfc, rmol, u10, v10, gz1oz0, wspd, &
&                      br, isfflx, dx, svp1, svp2, svp3, svpt0, ep_1, &
&                      ep_2, karman, ids, ide, jds, jde, kds, kde, ims, &
&                      ime, jms, jme, kms, kme, i_start(ij), i_end(ij), &
&                      j_start(ij), j_end(ij), kts, kte)
            END IF
          CASE DEFAULT
            WRITE(message, *) &
&            'The sfclay option does not exist: sf_sfclay_physics = ', &
&            sf_sfclay_physics
          END SELECT
        END DO
!$OMP END PARALLEL DO
        IF (isfflx .NE. 0) THEN
!Internal
          a_lai = 0.0_8
          a_capg = 0.0_8
          a_vegf_px = 0.0_8
          a_tsk = 0.0_8
          a_psfc = 0.0_8
          a_flhc = 0.0_8
          a_flqc = 0.0_8
!I/O should not be overwritten to zero -JJG
!!          a_th_phy = 0.0_8
!!          a_qv_curr = 0.0_8
!!          a_t_phy = 0.0_8
!          a_znt = 0.0_8
!!          a_p_phy = 0.0_8
!          a_smois = 0.0_8
!          a_tslb = 0.0_8
!          a_canwat = 0.0_8
!!          a_rho = 0.0_8
!!          a_dz8w = 0.0_8


!$OMP PARALLEL DO   &
!$OMP PRIVATE ( ij, i, j, k ) firstprivate(frpcpn)
          DO ij=num_tiles,1,-1
            SELECT CASE  (sf_surface_physics) 
            CASE (slabscheme) 
              IF (PRESENT(qv_curr) .AND. PRESENT(capg) .AND. .true.) &
&              THEN
                CALL A_SLAB(t_phy, a_t_phy, qv_curr, a_qv_curr, p_phy, &
&                      a_p_phy, flhc, a_flhc, flqc, a_flqc, psfc, a_psfc&
&                      , xland, tmn, hfx, a_hfx, qfx, a_qfx, lh, tsk, &
&                      a_tsk, qsfc, chklowq, gsw, glw, capg, a_capg, thc&
&                      , snowc, emiss, mavail, dtbl, rcp, xlv, dtmin, &
&                      ifsnow, svp1, svp2, svp3, svpt0, ep_2, karman, &
&                      eomeg, stbolt, tslb, a_tslb, zs, dzs, &
&                      num_soil_layers, radiation, p1000mb, ids, ide, jds&
&                      , jde, kds, kde, ims, ime, jms, jme, kms, kme, &
&                      i_start(ij), i_end(ij), j_start(ij), j_end(ij), &
&                      kts, kte)
              END IF
            CASE (pxlsmscheme) 
              IF (PRESENT(qv_curr) .AND. PRESENT(qc_curr) .AND. PRESENT(&
&                  emiss) .AND. PRESENT(t2) .AND. PRESENT(rainbl) .AND. &
&                  .true.) THEN
                CALL A_PXLSM(u_phy, v_phy, dz8w, a_dz8w, qv_curr, &
&                       a_qv_curr, t_phy, a_t_phy, th_phy, a_th_phy, rho&
&                       , a_rho, psfc, a_psfc, gsw, glw, rainbl, emiss, &
&                       itimestep, curr_secs, num_soil_layers, dt, &
&                       anal_interval, xland, xice, albbck, albedo, &
&                       snoalb, smois, a_smois, tslb, a_tslb, mavail, t2&
&                       , q2, zs, dzs, psih, landusef, soilctop, soilcbot&
&                       , vegfra, vegf_px, a_vegf_px, isltyp, ra, rs, lai&
&                       , a_lai, nlcat, nscat, hfx, a_hfx, qfx, a_qfx, lh&
&                       , tsk, a_tsk, sst, znt, a_znt, canwat, a_canwat, &
&                       grdflx, shdmin, shdmax, snowc, pblh, a_pblh, rmol&
&                       , a_rmol, ust, a_ust, capg, a_capg, dtbl, &
&                       t2_ndg_old, t2_ndg_new, q2_ndg_old, q2_ndg_new, &
&                       sn_ndg_old, sn_ndg_new, snow, snowh, snowncv, &
&                       t2obs, q2obs, pxlsm_smois_init, pxlsm_soil_nudge&
&                       , ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&                       jme, kms, kme, i_start(ij), i_end(ij), j_start(ij&
&                       ), j_end(ij), kts, kte)

              END IF
            CASE DEFAULT
            END SELECT

          END DO
!$OMP END PARALLEL DO
        END IF
!Internal
        a_br = 0.0_8
        a_qsfc = 0.0_8
        a_psih = 0.0_8
        a_psim = 0.0_8
        a_gz1oz0 = 0.0_8
        a_cpm = 0.0_8
        a_u_phytmp = 0.0_8
        a_v_phytmp = 0.0_8
        a_chs = 0.0_8
        a_zol = 0.0_8

!I/O
!        a_ustm = 0.0_8 !Needs to propogate from following time step for sfclay -JJG
!        a_mol = 0.0_8 !Needs to propogate from following time step for sfclay -JJG

        CALL POPREAL8ARRAY(cpm, (ime-ims+1)*(jme-jms+1))
        CALL POPREAL8ARRAY(znt, (ime-ims+1)*(jme-jms+1))
        CALL POPREAL8ARRAY(ust, (ime-ims+1)*(jme-jms+1))
        CALL POPREAL8ARRAY(mol, (ime-ims+1)*(jme-jms+1))
        CALL POPREAL8ARRAY(psim, (ime-ims+1)*(jme-jms+1))
        CALL POPREAL8ARRAY(psih, (ime-ims+1)*(jme-jms+1))
        CALL POPREAL8ARRAY(hfx, (ime-ims+1)*(jme-jms+1))
        CALL POPREAL8ARRAY(qfx, (ime-ims+1)*(jme-jms+1))
        CALL POPREAL8ARRAY(flhc, (ime-ims+1)*(jme-jms+1))
        CALL POPREAL8ARRAY(flqc, (ime-ims+1)*(jme-jms+1))
        CALL POPREAL8ARRAY(qsfc, (ime-ims+1)*(jme-jms+1))
        CALL POPREAL8ARRAY(gz1oz0, (ime-ims+1)*(jme-jms+1))
        CALL POPREAL8ARRAY(wspd, (ime-ims+1)*(jme-jms+1))
        CALL POPREAL8ARRAY(br, (ime-ims+1)*(jme-jms+1))
        CALL POPREAL8ARRAY(ustm, (ime-ims+1)*(jme-jms+1))
!$OMP PARALLEL DO   &
!$OMP PRIVATE ( ij, i, j, k )
        DO ij=num_tiles,1,-1
          SELECT CASE  (sf_sfclay_physics) 
          CASE (sfclayscheme) 
            IF (PRESENT(qv_curr) .AND. PRESENT(mol) .AND. PRESENT(regime&
&                ) .AND. .true.) THEN
              CALL A_SFCLAY(u_phytmp, a_u_phytmp, v_phytmp, a_v_phytmp, &
&                      t_phy, a_t_phy, qv_curr, a_qv_curr, p_phy, a_p_phy&
&                      , dz8w, a_dz8w, cp, g, rcp, r_d, xlv, psfc, a_psfc&
&                      , chs, a_chs, chs2, cqs2, cpm, a_cpm, znt, a_znt, &
&                      ust, a_ust, pblh, a_pblh, mavail, zol, a_zol, mol&
&                      , a_mol, regime, psim, a_psim, psih, a_psih, fm, &
&                      fhh, xland, hfx, a_hfx, qfx, a_qfx, lh, tsk, flhc&
&                      , a_flhc, flqc, a_flqc, qgh, qsfc, a_qsfc, rmol, &
&                      a_rmol, u10, v10, th2, t2, q2, gz1oz0, a_gz1oz0, &
&                      wspd, a_wspd, br, a_br, isfflx, dx, svp1, svp2, &
&                      svp3, svpt0, ep_1, ep_2, karman, eomeg, stbolt, &
&                      p1000mb, ids, ide, jds, jde, kds, kde, ims, ime, &
&                      jms, jme, kms, kme, i_start(ij), i_end(ij), &
&                      j_start(ij), j_end(ij), kts, kte, ustm, a_ustm, ck&
&                      , cka, cd, cda, isftcflx, iz0tlnd, scm_force_flux)
            END IF
          CASE (pxsfcscheme) 
            IF (PRESENT(qv_curr) .AND. PRESENT(mol) .AND. PRESENT(regime&
&                ) .AND. .true.) THEN
              CALL A_PXSFCLAY(u_phytmp, a_u_phytmp, v_phytmp, a_v_phytmp, &
&                      t_phy, a_t_phy, th_phy, a_th_phy, qv_curr, &
&                      a_qv_curr, p_phy, dz8w, a_dz8w, cp, g, rcp, r_d, &
&                      xlv, psfc, a_psfc, chs, a_chs, chs2, cqs2, cpm, &
&                      a_cpm, znt, a_znt, ust, a_ust, pblh, a_pblh, &
&                      mavail, zol, a_zol, mol, a_mol, regime, psim, &
&                      a_psim, psih, a_psih, xland, hfx, a_hfx, qfx, &
&                      a_qfx, lh, tsk, flhc, a_flhc, flqc, a_flqc, qgh, &
&                      qsfc, a_qsfc, rmol, a_rmol, u10, v10, gz1oz0, &
&                      a_gz1oz0, wspd, a_wspd, br, a_br, isfflx, dx, svp1&
&                      , svp2, svp3, svpt0, ep_1, ep_2, karman, ids, ide&
&                      , jds, jde, kds, kde, ims, ime, jms, jme, kms, kme&
&                      , i_start(ij), i_end(ij), j_start(ij), j_end(ij), &
&                      kts, kte)
            END IF
          CASE DEFAULT
!            CALL PUSHCONTROL3B(4)
            WRITE(message, *) &
&            'The sfclay option does not exist: sf_sfclay_physics = ', &
&            sf_sfclay_physics
          END SELECT

        END DO
!$OMP END PARALLEL DO

!$OMP PARALLEL DO   &
!$OMP PRIVATE ( ij, i, j, k )
        DO ij=num_tiles,1,-1
          CALL POPINTEGER4(ad_from0)
          CALL POPINTEGER4(ad_to0)
          DO j=ad_to0,ad_from0,-1
            CALL POPINTEGER4(ad_from)
            CALL POPINTEGER4(ad_to)
            DO i=ad_to,ad_from,-1
              DO k=kte,kts,-1
                a_u_phy(i, k, j) = a_u_phy(i, k, j) + a_u_phytmp(i, k, j&
&                  )
                a_u_phytmp(i, k, j) = 0.0_8
                a_v_phy(i, k, j) = a_v_phy(i, k, j) + a_v_phytmp(i, k, j&
&                  )
                a_v_phytmp(i, k, j) = 0.0_8
              END DO
              a_p8w(i, kts, j) = a_p8w(i, kts, j) + a_psfc(i, j)
              a_psfc(i, j) = 0.0_8
            END DO
          END DO
        END DO
!$OMP END PARALLEL DO
      END IF
    END IF
  END SUBROUTINE A_SURFACE_DRIVER

END MODULE A_MODULE_SURFACE_DRIVER
