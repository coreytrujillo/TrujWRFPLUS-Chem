!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.6 (r4756) - 12 Feb 2013 10:43
!
MODULE G_MODULE_SF_PXLSM
  USE module_sf_pxlsm_data
  USE module_sf_pxlsm, only: PXSNOW

  USE module_model_constants
  IMPLICIT NONE
!------------------------------------------------------------------------------------------
!------------------------------------------------------------------------------------------
  INTEGER, PARAMETER :: nsold=20
  REAL, PARAMETER :: rd=287.04D0, cpd=1004.67D0, cph2o=4.218d+3, cpice=&
&    2.106d+3, lsubf=3.335d+5, sigma=5.67d-8, rovcp=rd/cpd
! CRANK-NIC PARAMETER
  REAL, PARAMETER :: crankp=0.5D0
! critical Richardson number
  REAL, PARAMETER :: ric=0.25D0
! water density in KG/M3                  
  REAL, PARAMETER :: denw=1000.0D0
! 1/1DAY(SEC)
  REAL, PARAMETER :: tauinv=1.0D0/86400.0D0
! Bottom soil temp response factor
  REAL, PARAMETER :: t2tfac=1.0D0/10.0D0
  REAL, PARAMETER :: pi=3.1415926535897932384626433
  REAL, PARAMETER :: pr0=0.95D0
  REAL, PARAMETER :: czo=0.032D0
  REAL, PARAMETER :: ozo=1.d-4

CONTAINS
!  Differentiation of pxlsm in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: lai capg tslb hfx vegf_px tsk
!                znt qfx smois canwat
!   with respect to varying inputs: lai capg tslb ust pblh hfx
!                vegf_px tsk t3d qv3d znt psfc rmol qfx smois th3d
!                canwat rho dz8w
!
!-------------------------------------------------------------------------
!-------------------------------------------------------------------------
  SUBROUTINE G_PXLSM(u3d, v3d, dz8w, g_dz8w, qv3d, g_qv3d, t3d, g_t3d, &
&    th3d, g_th3d, rho, g_rho, psfc, g_psfc, gsw, glw, rainbl, emiss, &
&    itimestep, curr_secs, nsoil, dt, anal_interval, xland, xice, albbck&
&    , albedo, &!g_albedo, 
     snoalb, smois, g_smois, tslb, g_tslb, mavail, &
&    ta2, qa2, zs, dzs, psih, landusef, soilctop, soilcbot, vegfra, &
&    vegf_px, g_vegf_px, isltyp, ra, rs, lai, g_lai, nlcat, nscat, hfx, &
&    g_hfx, qfx, g_qfx, lh, tsk, g_tsk, sst, znt, g_znt, canwat, g_canwat&
&    , grdflx, shdmin, shdmax, snowc, pblh, g_pblh, rmol, g_rmol, ust, &
&    g_ust, capg, g_capg, dtbl, t2_ndg_old, t2_ndg_new, q2_ndg_old, &
&    q2_ndg_new, sn_ndg_old, sn_ndg_new, snow, snowh, snowncv, &
&    t2obs, q2obs, pxlsm_smois_init, pxlsm_soil_nudge, ids, ide&
&    , jds, jde, kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, &
&    jte, kts, kte)
    IMPLICIT NONE
!------------------------------------------------------
!.......Arguments
! DECLARATIONS - INTEGER
    INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, its, ite, jts, jte, kts, kte
    INTEGER, INTENT(IN) :: nsoil, itimestep, nlcat, nscat, anal_interval&
&    , pxlsm_smois_init, pxlsm_soil_nudge
    REAL, INTENT(IN), OPTIONAL :: curr_secs
    REAL, INTENT(IN) :: dt, dtbl
    INTEGER, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: isltyp
! DECLARATIONS - REAL
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: u3d, v3d, &
&    rho, t3d, th3d, dz8w, qv3d
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: g_rho, &
&    g_t3d, g_th3d, g_dz8w, g_qv3d
    REAL, DIMENSION(nsoil), INTENT(IN) :: zs, dzs
    REAL, DIMENSION(ims:ime, nsoil, jms:jme), INTENT(INOUT) :: smois, &
&    tslb
    REAL, DIMENSION(ims:ime, nsoil, jms:jme), INTENT(INOUT) :: g_smois, &
&    g_tslb
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: ra, rs, lai, znt
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: g_lai, g_znt
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(OUT) :: grdflx, tsk, ta2, &
&    qa2
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(OUT) :: g_tsk
    REAL, DIMENSION(ims:ime, nlcat, jms:jme), INTENT(IN) :: landusef
    REAL, DIMENSION(ims:ime, nscat, jms:jme), INTENT(IN) :: soilctop, &
&    soilcbot
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: psfc, gsw, glw, &
&    rainbl, emiss, snoalb, albbck, shdmin, shdmax, pblh, rmol, snowncv, &
&    ust, mavail, sst
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: g_psfc, g_pblh, &
&    g_rmol, g_ust
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: t2_ndg_old, &
&    t2_ndg_new, q2_ndg_old, q2_ndg_new, sn_ndg_old, sn_ndg_new
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(OUT) :: t2obs, q2obs
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: capg, canwat, &
&    qfx, hfx, lh, psih, vegfra, vegf_px, snow, snowh, snowc, albedo, &
&    xland, xice
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: g_capg, g_canwat&
&    , g_qfx, g_hfx, g_vegf_px!, g_albedo
    LOGICAL :: radiation
!-------------------------------------------------------------------------
!     ---------- Local Variables --------------------------------
!----  PARAMETERS
! max. soil types
    INTEGER, PARAMETER :: nstps=11
! Max PX timestep = 40 sec
    REAL, PARAMETER :: dtpblx=40.0D0
!----  INTEGERS
    INTEGER, DIMENSION(nstps) :: jp
    INTEGER :: j, i, ns, nudge, isti, weight
    INTEGER :: ntsps, it
!----  REALS
    REAL, DIMENSION(ims:ime, jms:jme) :: xlai, xlaimn, rstmin, xveg, &
&    xvegmn, xsnup, xalb
    REAL, DIMENSION(ims:ime, jms:jme) :: radnet, eg, er, etr, qst
    REAL :: sfcprs, ta1, dens1, qv1, zlvl, soldn, lwdn, emissi, precip, &
&    theta1, vapprs, qsbt, wg, w2, wr, tg, t2, ustar, molx, z0, rair, &
&    cpair, ifland, isnow, es, qss, betap, rh2_old, rh2_new, t2_old, &
&    t2_new, core, corb, time_between_analysis, g1000, aln10, rh2obs, hu&
&    , snobs, fwsat, fwfc, fwwlt, fb, fcgsat, fjp, fas, fseas, t2i, &
&    hc_snow, snow_fra, snowalb, qst12, zfunc, zf1, za2, qv2, dt_fdda, &
&    fc2r, fc1sat, dtpbl
    REAL :: g_sfcprs, g_ta1, g_dens1, g_qv1, g_zlvl, g_theta1, g_qsbt, &
&    g_wr, g_ustar, g_molx, g_z0, g_cpair, g_es, g_qss, g_betap, &
&    g_rh2_old, g_rh2_new, g_rh2obs, g_fseas, g_t2i, g_qst12, g_zfunc, &
&    g_zf1, g_za2, g_qv2
    CHARACTER(len=6) :: land_use_type
    REAL :: arg1
    REAL :: g_arg1
    REAL :: g_max2
    REAL :: max2
!-------------------------------------------------------------------------
!-------------------------------Executable starts here--------------------
!
    aln10 = ALOG(10.0D0)
! G/1000
    g1000 = g*1.0d-3
    weight = 0
! Determine Landuse Dataset by the number of categories
    IF (nlcat .EQ. 50) THEN
      land_use_type = 'NLCD50'
    ELSE IF (nlcat .EQ. 40) THEN
      land_use_type = 'NLCD40'
    ELSE IF (nlcat .EQ. 20) THEN
      land_use_type = 'MODIS'
    ELSE IF (nlcat .EQ. 24) THEN
      land_use_type = 'USGS'
    !+!ELSE
      !+!CALL WRF_ERROR_FATAL('Error: Unknown Land Use Category')
    END IF
    !+!IF (itimestep .EQ. 1) THEN
      !+!CALL WRF_MESSAGE('PX LSM will use the '//TRIM(land_use_type)//&
!+!&                 ' landuse tables')
      !+!PRINT*, &
!+!&      'The analysis interval for surface soil and temp nudging = ', &
!+!&      anal_interval, 'sec.'
    !+!END IF
!-----------------------------------------------------------------------------------
! Kill WRF if user specifies soil nudging but provides no analysis interval, then provide helpful message.
    IF (anal_interval .LE. 0.0 .AND. pxlsm_soil_nudge .EQ. 1) THEN
      !+!CALL WRF_MESSAGE('PX LSM Error: The User specified analysis interv&
!+!&al is zero or negative.')
      !+!CALL WRF_MESSAGE('If the PX LSM is used with soil nudging (pxlsm_s&
!+!&oil_nudge=1) a wrfsfdda_d0* file is required.')
      !+!CALL WRF_MESSAGE('Make sure these files are present and')
      !+!CALL WRF_MESSAGE('Check the namelist to ensure sgfdda_interval_m i&
!+!&s set to proper sfc analysis interval')
      STOP
    ELSE
!-----------------------------------------------------------------------------------
!--- Compute time relatve to old and new analysis time for timestep interpolation
      IF (pxlsm_soil_nudge .EQ. 1) THEN
! Convert DT of Analysis to real 
        dt_fdda = anal_interval*1.0D0
        time_between_analysis = MOD(curr_secs, dt_fdda)
        IF (time_between_analysis .EQ. 0.0) THEN
          corb = 1.0D0
          core = 0.0D0
        ELSE
          core = time_between_analysis/dt_fdda
          corb = 1.0D0 - core
        END IF
      END IF
!-----------------------------------------------------------------------------------
! Compute vegetation and land-use characteristics by land-use fraction weighting
! These parameters include LAI, VEGF, ZNT, ALBEDO, RS, etc.
      CALL G_VEGELAND(landusef, vegfra, shdmin, shdmax, soilctop, &
&                soilcbot, nlcat, nscat, znt, g_znt, xlai, xlaimn, rstmin&
&                , xveg, xvegmn, xsnup, xland, xalb, ids, ide, jds, jde, &
&                kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, &
&                jte, kts, kte, land_use_type)
      g_rh2obs = 0.0_8
!-----------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------
! Main loop over individual grid cells
!-- J LOOP
      DO j=jts,jte
!-- I LOOP
        DO i=its,ite
          ifland = xland(i, j)
! Compute soil properties via weighting of fractional components
          IF (ifland .LT. 1.5) THEN
!---------------------------------------------------------
            CALL G_SOILPROP(soilcbot(i, :, j), weight, itimestep, mavail&
&                      (i, j), pxlsm_smois_init, fwsat, fwfc, fwwlt, fb, &
&                      fcgsat, fjp, fas, fc2r, fc1sat, isti, smois(i, 2, &
&                      j), g_smois(i, 2, j))
!----------------------------------------------------------
            isltyp(i, j) = isti
          ELSE
! STATSGO type for water
            isltyp(i, j) = 14
          END IF
!--  Variables Sub. SURFPX needs
! surface pressure in cb
          g_sfcprs = g_psfc(i, j)/1000.0D0
          sfcprs = psfc(i, j)/1000.0D0
! air temperature at first layer
          g_ta1 = g_t3d(i, 1, j)
          ta1 = t3d(i, 1, j)
! air density at first layer
          g_dens1 = g_rho(i, 1, j)
          dens1 = rho(i, 1, j)
! water vapor mixing ratio at first layer
          g_qv1 = g_qv3d(i, 1, j)
          qv1 = qv3d(i, 1, j)
          g_qv2 = g_qv3d(i, 2, j)
          qv2 = qv3d(i, 2, j)
! thickness of lowest half level
          g_zlvl = 0.5D0*g_dz8w(i, 1, j)
          zlvl = 0.5D0*dz8w(i, 1, j)
          g_zf1 = g_dz8w(i, 1, j)
          zf1 = dz8w(i, 1, j)
          g_za2 = g_zf1 + 0.5D0*g_dz8w(i, 2, j)
          za2 = zf1 + 0.5D0*dz8w(i, 2, j)
! longwave radiation
          lwdn = glw(i, j)
! emissivity
          emissi = emiss(i, j)
          IF (1.0d-3*rainbl(i, j)/dtbl .LT. 0.0) THEN
            precip = 0.0D0
          ELSE
            precip = 1.0d-3*rainbl(i, j)/dtbl
          END IF
! convert RAINBL from mm to m for PXLSM
! convert CANWAT from mm to m for PXLSM
          g_wr = 1.0d-3*g_canwat(i, j)
          wr = 1.0d-3*canwat(i, j)
! potential temp at first layer
          g_theta1 = g_th3d(i, 1, j)
          theta1 = th3d(i, 1, j)
! Set snow cover to existing model value
          snobs = snow(i, j)
!   this is overwritten below if snow analysis is availiable
!   otherwise snow cover remains constant through simulation
          IF (pxlsm_soil_nudge .EQ. 1) THEN
!-- 2 m Temp and RH for Nudging
            t2_old = t2_ndg_old(i, j)
            t2_new = t2_ndg_new(i, j)
            arg1 = svp2*(t2_old-svpt0)/(t2_old-svp3)
            vapprs = svp1*EXP(arg1)
            g_qsbt = -(ep_2*vapprs*g_sfcprs/(sfcprs-vapprs)**2)
            qsbt = ep_2*vapprs/(sfcprs-vapprs)
            g_rh2_old = -(q2_ndg_old(i, j)*g_qsbt/qsbt**2)
            rh2_old = q2_ndg_old(i, j)/qsbt
            arg1 = svp2*(t2_new-svpt0)/(t2_new-svp3)
            vapprs = svp1*EXP(arg1)
            g_qsbt = -(ep_2*vapprs*g_sfcprs/(sfcprs-vapprs)**2)
            qsbt = ep_2*vapprs/(sfcprs-vapprs)
            g_rh2_new = -(q2_ndg_new(i, j)*g_qsbt/qsbt**2)
            rh2_new = q2_ndg_new(i, j)/qsbt
            g_rh2obs = corb*g_rh2_old + core*g_rh2_new
            rh2obs = corb*rh2_old + core*rh2_new
            t2obs(i, j) = corb*t2_old + core*t2_new
            q2obs(i, j) = corb*q2_ndg_old(i, j) + core*q2_ndg_new(i, j)
            snobs = corb*sn_ndg_old(i, j) + core*sn_ndg_new(i, j)
          END IF
          IF (ust(i, j) .LT. 0.005) THEN
            ustar = 0.005
            g_ustar = 0.0_8
          ELSE
            g_ustar = g_ust(i, j)
            ustar = ust(i, j)
          END IF
          IF (ifland .GT. 1.5) THEN
! if over water                            
            g_znt(i, j) = czo*(g_ust(i, j)*ust(i, j)+ust(i, j)*g_ust(i, &
&              j))/g
            znt(i, j) = czo*ust(i, j)*ust(i, j)/g + ozo
          END IF
          g_z0 = g_znt(i, j)
          z0 = znt(i, j)
! J/(K KG)
          g_cpair = cpd*0.84D0*g_qv1
          cpair = cpd*(1.0D0+0.84D0*qv1)
!-------------------------------------------------------------
! Compute fractional snow area and snow albedo
          CALL PXSNOW(itimestep, snobs, snowncv(i, j), snow(i, j), snowh&
&                (i, j), xsnup(i, j), xalb(i, j), snoalb(i, j), vegf_px(i&
&                , j), shdmin(i, j), hc_snow, snow_fra, snowc(i, j), &
&                albedo(i, j))
!-------------------------------------------------------------
!-------------------------------------------------------------
! Sea Ice from analysis and water cells that are very cold, but more than 50% water
! are converted to ice/snow for more reasonable treatment.
          IF (xice(i, j) .GE. 0.5 .OR. (sst(i, j) .LE. 270.0 .AND. xland&
&              (i, j) .GT. 1.50)) THEN
            xland(i, j) = 1.0
            ifland = 1.0D0
!  Ice
            g_znt(i, j) = 0.0_8
            znt(i, j) = 0.001D0
! FWSAT
            g_smois(i, 1, j) = 0.0_8
            smois(i, 1, j) = 1.0D0
! FWSAT
            g_smois(i, 2, j) = 0.0_8
            smois(i, 2, j) = 1.0D0
            xice(i, j) = 1.0D0
!            g_albedo(i, j) = 0.0_8
            albedo(i, j) = 0.7D0
            snowc(i, j) = 1.0D0
            snow_fra = 1.0D0
            g_vegf_px(i, j) = 0.0_8
            vegf_px(i, j) = 0.0D0
            g_lai(i, j) = 0.0_8
            lai(i, j) = 0.0D0
          END IF
!-------------------------------------------------------------
!-------------------------------------------------------------
!-- Note that when IFGROW = 0 is selected in Vegeland then max and min           
!-- LAI and Veg are the same                                                     
          g_t2i = g_tslb(i, 2, j)
          t2i = tslb(i, 2, j)
          IF (1.0D0 - 0.015625D0*(290.0D0-t2i)**2 .LT. 0.0D0) THEN
            fseas = 0.0D0
            g_fseas = 0.0_8
          ELSE
            g_fseas = 0.015625D0*2.D0*(290.0D0-t2i)*g_t2i
            fseas = 1.0D0 - 0.015625D0*(290.0D0-t2i)**2
          END IF
          IF (t2i .GE. 290.0) THEN
            fseas = 1.0D0
            g_fseas = 0.0_8
          END IF
          g_lai(i, j) = (xlai(i, j)-xlaimn(i, j))*g_fseas
          lai(i, j) = xlaimn(i, j) + fseas*(xlai(i, j)-xlaimn(i, j))
          g_vegf_px(i, j) = (xveg(i, j)-xvegmn(i, j))*g_fseas
          vegf_px(i, j) = xvegmn(i, j) + fseas*(xveg(i, j)-xvegmn(i, j))
! Ensure veg algorithms not used for water 
          IF (ifland .GT. 1.5) THEN
            g_vegf_px(i, j) = 0.0_8
            vegf_px(i, j) = 0.0D0
          END IF
!-------------------------------------------------------------
! downward shortwave radiaton
          soldn = gsw(i, j)/(1.0D0-albedo(i, j))
          isnow = snowc(i, j)
          nudge = pxlsm_soil_nudge
          IF (j .LE. 2 .OR. j .GE. jde - 1) nudge = 0
          IF (i .LE. 2 .OR. i .GE. ide - 1) nudge = 0
          IF (rmol(i, j) .GT. 0.0) THEN
            IF (1.D0/rmol(i, j) .GT. 1000.0) THEN
              molx = 1000.0D0
              g_molx = 0.0_8
            ELSE
              g_molx = (-g_rmol(i, j))/rmol(i, j)**2
              molx = 1.D0/rmol(i, j)
            END IF
          ELSE IF (rmol(i, j) .LT. 0.0) THEN
            IF (1.D0/rmol(i, j) .LT. -1000.0D0) THEN
              molx = -1000.0D0
              g_molx = 0.0_8
            ELSE
              g_molx = (-g_rmol(i, j))/rmol(i, j)**2
              molx = 1.D0/rmol(i, j)
            END IF
          ELSE
            molx = 1000.D0
            g_molx = 0.0_8
          END IF
          IF (100.D0 .LT. pblh(i, j)) THEN
            g_max2 = g_pblh(i, j)
            max2 = pblh(i, j)
          ELSE
            max2 = 100.D0
            g_max2 = 0.0_8
          END IF
          g_zfunc = g_zf1*(1.0D0-zf1/max2)**2 - zf1*2.D0*(1.0D0-zf1/max2)*(&
&            g_zf1*max2-zf1*g_max2)/max2**2
          zfunc = zf1*(1.0D0-zf1/max2)**2
          g_qst12 = (karman*(g_zfunc*(qv2-qv1)+zfunc*(g_qv2-g_qv1))*(za2&
&            -zlvl)-karman*zfunc*(qv2-qv1)*(g_za2-g_zlvl))/(za2-zlvl)**2
          qst12 = karman*zfunc*(qv2-qv1)/(za2-zlvl)
!--- LSM sub-time loop too prevent dt > 40 sec       
          ntsps = INT(dt/(dtpblx+0.000001D0) + 1.0D0)
          dtpbl = dt/ntsps
          DO it=1,ntsps
!... SATURATION VAPOR PRESSURE (MB) 
            IF (tslb(i, 1, j) .LE. svpt0) THEN
! For ground that is below freezing
! cb
              g_es = svp1*6.15d3*g_tslb(i, 1, j)*EXP(22.514D0-6.15d3/tslb(&
&                i, 1, j))/tslb(i, 1, j)**2
              es = svp1*EXP(22.514D0-6.15d3/tslb(i, 1, j))
            ELSE
              g_arg1 = (svp2*g_tslb(i, 1, j)*(tslb(i, 1, j)-svp3)-svp2*(&
&                tslb(i, 1, j)-svpt0)*g_tslb(i, 1, j))/(tslb(i, 1, j)-&
&                svp3)**2
              arg1 = svp2*(tslb(i, 1, j)-svpt0)/(tslb(i, 1, j)-svp3)
              g_es = svp1*g_arg1*EXP(arg1)
              es = svp1*EXP(arg1)
            END IF
            g_qss = (0.622D0*g_es*(sfcprs-es)-es*0.622D0*(g_sfcprs-g_es))/(&
&              sfcprs-es)**2
            qss = es*0.622D0/(sfcprs-es)
!... beta method, Lee & Pielke (JAM,May1992)
            betap = 1.0D0
            IF (ifland .LT. 1.5 .AND. isnow .LT. 0.5 .AND. smois(i, 1, j&
&                ) .LE. fwfc) THEN
              g_arg1 = pi*g_smois(i, 1, j)/fwfc
              arg1 = smois(i, 1, j)/fwfc*pi
              g_betap = 0.25D0*2.D0*(1.D00-COS(arg1))*g_arg1*SIN(arg1)
              betap = 0.25D0*(1.0D0-COS(arg1))**2
            ELSE
              g_betap = 0.0_8
            END IF

            CALL G_SURFPX(dtpbl, ifland, snowc(i, j), nudge, xice(i, j)&
&                    , soldn, gsw(i, j), lwdn, emissi, zlvl, g_zlvl, molx&
&                    , g_molx, z0, g_z0, ustar, g_ustar, sfcprs, g_sfcprs&
&                    , dens1, g_dens1, qv1, g_qv1, qss, g_qss, ta1, g_ta1&
&                    , theta1, g_theta1, precip, cpair, g_cpair, psih(i, &
&                    j), rh2obs, g_rh2obs, t2obs(i, j), vegf_px(i, j), &
&                    g_vegf_px(i, j), isti, lai(i, j), g_lai(i, j), betap&
&                    , g_betap, rstmin(i, j), hc_snow, snow_fra, fwwlt, &
&                    fwfc, fcgsat, fwsat, fb, fc1sat, fc2r, fas, fjp, dzs&
&                    (1), dzs(2), qst12, g_qst12, radnet(i, j), grdflx(i&
&                    , j), hfx(i, j), g_hfx(i, j), qfx(i, j), g_qfx(i, j)&
&                    , lh(i, j), eg(i, j), er(i, j), etr(i, j), qst(i, j)&
&                    , capg(i, j), g_capg(i, j), rs(i, j), ra(i, j), tslb&
&                    (i, 1, j), g_tslb(i, 1, j), tslb(i, 2, j), g_tslb(i&
&                    , 2, j), smois(i, 1, j), g_smois(i, 1, j), smois(i, &
&                    2, j), g_smois(i, 2, j), wr, g_wr, ta2(i, j), qa2(i&
&                    , j), land_use_type)
          END DO
          g_tsk(i, j) = g_tslb(i, 1, j)
          tsk(i, j) = tslb(i, 1, j)
          g_canwat(i, j) = 1000.D0*g_wr
          canwat(i, j) = wr*1000.D0
        END DO
      END DO
    END IF
  END SUBROUTINE G_PXLSM
!
!-------------------------------------------------------------------------
!-------------------------------------------------------------------------

!  Differentiation of vegeland in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: znt
!   with respect to varying inputs: znt
!-------------------------------------------------------------------------
!-------------------------------------------------------------------------
!-------------------------------------------------------------------------
!-------------------------------------------------------------------------
  SUBROUTINE G_VEGELAND(landusef, vegfra, shdmin, shdmax, soilctop, &
&    soilcbot, nlcat, nscat, znt, g_znt, xlai, xlaimn, rstmin, xveg, &
&    xvegmn, xsnup, xland, xalb, ids, ide, jds, jde, kds, kde, ims, ime, &
&    jms, jme, kms, kme, its, ite, jts, jte, kts, kte, land_use_type)
    IMPLICIT NONE
! END LOOP THROUGH GRID CELLS
! END LOOP THROUGH GRID CELLS
!--------------------------------------------------------------------
!... 
    INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, its, ite, jts, jte, kts, kte
    INTEGER, INTENT(IN) :: nscat, nlcat
    REAL, DIMENSION(ims:ime, nlcat, jms:jme), INTENT(IN) :: landusef
    REAL, DIMENSION(ims:ime, nscat, jms:jme), INTENT(IN) :: soilctop, &
&    soilcbot
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: vegfra, shdmin, &
&    shdmax
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: znt
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: g_znt
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(OUT) :: xlai, xlaimn, &
&    rstmin, xalb, xveg, xvegmn, xsnup, xland
    CHARACTER(len=6), INTENT(IN) :: land_use_type
!... local variables
    INTEGER :: itf, jtf, k, j, i
    REAL :: sumlai, sumlmn, sumrsi, sumlz0, sumveg, sumvmn, alai, vegf, &
&    sumsnup
    REAL :: vfmx, vfmn, vseas, farea, fwat, znotc, sumalb
    REAL, DIMENSION(nlcat) :: laimx, laimn, z0, veg, vegmn, snup
    REAL, DIMENSION(nlcat) :: g_z0
! CM, MIN Zo FOR CROPS
    REAL, PARAMETER :: znotcmn=5.0D0
! CM, MAX Zo FOR CROPS
    REAL, PARAMETER :: znotcmx=15.0D0
    REAL, DIMENSION(:), SAVE, POINTER :: rsmin, z00, veg0, vegmn0, lai0&
&    , laimn0, snup0, albf
!---- INITIALIZE PARAMETERS
    INTEGER, SAVE :: kwat
    INTEGER, SAVE :: limit1, limit2
! Initialize LU characteristics by LU Dataset
    IF (land_use_type .EQ. 'USGS') THEN
      kwat = 16
      rsmin => rsmin_usgs
      z00 => z00_usgs
      veg0 => veg0_usgs
      vegmn0 => vegmn0_usgs
      lai0 => lai0_usgs
      laimn0 => laimn0_usgs
      snup0 => snup0_usgs
      albf => albf_usgs
      limit1 = 2
      limit1 = 6
    ELSE IF (land_use_type .EQ. 'NLCD50') THEN
      kwat = 1
      rsmin => rsmin_nlcd50
      z00 => z00_nlcd50
      veg0 => veg0_nlcd50
      vegmn0 => vegmn0_nlcd50
      lai0 => lai0_nlcd50
      laimn0 => laimn0_nlcd50
      snup0 => snup0_nlcd50
      albf => albf_nlcd50
      limit1 = 20
      limit1 = 43
    ELSE IF (land_use_type .EQ. 'NLCD40') THEN
      kwat = 17
      rsmin => rsmin_nlcd40
      z00 => z00_nlcd40
      veg0 => veg0_nlcd40
      vegmn0 => vegmn0_nlcd40
      lai0 => lai0_nlcd40
      laimn0 => laimn0_nlcd40
      snup0 => snup0_nlcd40
      albf => albf_nlcd40
      limit1 = 20
      limit1 = 43
    ELSE IF (land_use_type .EQ. 'MODIS') THEN
      kwat = 17
      rsmin => rsmin_modis
      z00 => z00_modis
      veg0 => veg0_modis
      vegmn0 => vegmn0_modis
      lai0 => lai0_modis
      laimn0 => laimn0_modis
      snup0 => snup0_modis
      albf => albf_modis
      limit1 = 12
      limit1 = 14
    END IF
!--------------------------------------------------------------------
    DO j=jts,jte
      DO i=its,ite
        xlai(i, j) = 0.0D0
        xlaimn(i, j) = 0.0D0
        rstmin(i, j) = 9999.0D0
        xveg(i, j) = 0.0D0
        xvegmn(i, j) = 0.0D0
        xsnup(i, j) = 0.0D0
        xalb(i, j) = 0.0D0
      END DO
    END DO
! END LOOP THROUGH GRID CELLS
! END LOOP THROUGH GRID CELLS
!--------------------------------------------------------------------
    DO j=jts,jte
      DO i=its,ite
!-- Initialize 2 and 3-D veg parameters to be caculated
        DO k=1,nlcat
          laimx(k) = lai0(k)
          laimn(k) = laimn0(k)
          g_z0(k) = 0.0_8
          z0(k) = z00(k)
          veg(k) = veg0(k)
          vegmn(k) = vegmn0(k)
          snup(k) = snup0(k)
        END DO
!--  INITIALIZE SUMS
        sumlai = 0.0D0
        sumlmn = 0.0D0
        sumrsi = 0.0D0
        sumlz0 = 0.0D0
        sumveg = 0.0D0
        sumvmn = 0.0D0
        alai = 0.0D0
        sumsnup = 0.0D0
        sumalb = 0.0D0
!--   ESTIMATE CROP EMERGANCE DATE FROM VEGFRAC
        vfmx = shdmax(i, j)
        vfmn = shdmin(i, j)
        vegf = vegfra(i, j)
!-- IF cell is vegetation
!-- Computations for VEGETATION CELLS ONLY
        IF (vfmx .GT. 0.0 .AND. landusef(i, kwat, j) .LT. 1.00) THEN
          vseas = vegf/vfmx
          IF (vseas .GT. 1.0D0 .OR. vseas .LT. 0.0D0) THEN
            IF (vseas .GT. 1.0D0) THEN
              vseas = 1.0D0
            ELSE
              vseas = vseas
            END IF
            IF (vseas .LT. 0.0D0) THEN
              vseas = 0.0D0
            ELSE
              vseas = vseas
            END IF
          END IF
! Zo FOR CROPS
          znotc = znotcmn*(1.D0-vseas) + znotcmx*vseas
          DO k=1,nlcat
            IF (land_use_type .EQ. 'MODIS') THEN
!-- USE THE VEGFRAC DATA ONLY FOR CROPS
              IF (k .EQ. 12 .OR. k .EQ. 14) THEN
                laimx(k) = laimn0(k)*(1.D0-vseas) + lai0(k)*vseas
                laimn(k) = laimx(k)
                veg(k) = vegmn0(k)*(1.D0-vseas) + veg0(k)*vseas
                vegmn(k) = veg(k)
!-- SEASONALLY VARY Zo FOR MODIS DryCrop (k=12)
                IF (k .EQ. 12) THEN
                  g_z0(k) = 0.0_8
                  z0(k) = znotc
!-- CrGrM (k=14) USE AVG WITH GRASS AND FOREST
                ELSE IF (k .EQ. 14) THEN
                  g_z0(k) = 0.0_8
                  z0(k) = 0.5D0*(znotc+z00(k))
                END IF
              END IF
            ELSE IF (land_use_type .EQ. 'NLCD50') THEN
!-- USE THE VEGFRAC DATA ONLY FOR CROPS
              IF ((k .EQ. 20 .OR. k .EQ. 43) .OR. k .EQ. 45) THEN
                laimx(k) = laimn0(k)*(1.D0-vseas) + lai0(k)*vseas
                laimn(k) = laimx(k)
                veg(k) = vegmn0(k)*(1.D0-vseas) + veg0(k)*vseas
                vegmn(k) = veg(k)
!-- SEASONALLY VARY Zo FOR DryCrop (k=20) OR Irigated Crop (k=43) OR  Mix Crop (k=4)
                IF (k .EQ. 20 .OR. k .EQ. 43) THEN
                  g_z0(k) = 0.0_8
                  z0(k) = znotc
!-- CrNatM (k=45) USE AVG WITH GRASS AND FOREST
                ELSE IF (k .EQ. 45) THEN
                  g_z0(k) = 0.0_8
                  z0(k) = 0.5D0*(znotc+z00(k))
                END IF
              END IF
            ELSE IF (land_use_type .EQ. 'NLCD40') THEN
!-- USE THE VEGFRAC DATA ONLY FOR CROPS
              IF ((k .EQ. 12 .OR. k .EQ. 14) .OR. k .EQ. 38) THEN
                laimx(k) = laimn0(k)*(1.D0-vseas) + lai0(k)*vseas
                laimn(k) = laimx(k)
                veg(k) = vegmn0(k)*(1.D0-vseas) + veg0(k)*vseas
                vegmn(k) = veg(k)
!-- SEASONALLY VARY Zo FOR Crop (k=12 for MODIS or 38 for NLCD)
                IF (k .EQ. 12 .OR. k .EQ. 38) THEN
                  g_z0(k) = 0.0_8
                  z0(k) = znotc
!-- CrNatM (k=14) USE AVG WITH GRASS AND FOREST
                ELSE IF (k .EQ. 14) THEN
                  g_z0(k) = 0.0_8
                  z0(k) = 0.5D0*(znotc+z00(k))
                END IF
              END IF
            ELSE IF (land_use_type .EQ. 'USGS') THEN
!-- USE THE VEGFRAC DATA ONLY FOR CROPS 
              IF (k .GE. 2 .AND. k .LE. 6) THEN
                laimx(k) = laimn0(k)*(1.D0-vseas) + lai0(k)*vseas
                laimn(k) = laimx(k)
                veg(k) = vegmn0(k)*(1.D0-vseas) + veg0(k)*vseas
                vegmn(k) = veg(k)
!-- SEASONALLY VARY Zo FOR DryCrop (k=2) OR Irigated Crop (k=3) OR  Mix Crop (k=4)
                IF (k .GE. 2 .AND. k .LE. 4) THEN
                  g_z0(k) = 0.0_8
                  z0(k) = znotc
!-- CrGrM (k=5) or CrWdM (k=6) USE AVG WITH GRASS AND FOREST
                ELSE IF (k .GE. 5 .AND. k .LE. 6) THEN
                  g_z0(k) = 0.0_8
                  z0(k) = 0.5D0*(znotc+z00(k))
                END IF
              END IF
            END IF
          END DO
        END IF
!-------------------------------------
!-- LOOP THROUGH LANDUSE Fraction and compute totals
        DO k=1,nlcat
          farea = landusef(i, k, j)
          sumlai = sumlai + laimx(k)*farea
          sumlmn = sumlmn + laimn(k)*farea
          alai = alai + farea
          sumrsi = sumrsi + farea*laimx(k)/rsmin(k)
          sumlz0 = sumlz0 + farea*ALOG(z0(k))
          sumveg = sumveg + farea*veg(k)
          sumvmn = sumvmn + farea*vegmn(k)
          sumsnup = sumsnup + farea*snup(k)
          sumalb = sumalb + farea*albf(k)
        END DO
!-- CHECK FOR WATER
        fwat = landusef(i, kwat, j)
        IF (fwat .GT. 0.999) THEN
          xlai(i, j) = laimx(kwat)
          xlaimn(i, j) = laimn(kwat)
          rstmin(i, j) = rsmin(kwat)
          g_znt(i, j) = 0.0_8
          znt(i, j) = z0(kwat)
          xveg(i, j) = veg(kwat)
          xvegmn(i, j) = vegmn(kwat)
          xsnup(i, j) = snup(kwat)
          xalb(i, j) = albf(kwat)
        ELSE
          IF (fwat .GT. 0.10) THEN
            alai = alai - fwat
            sumlz0 = sumlz0 - fwat*ALOG(z0(kwat))
          END IF
          xlai(i, j) = sumlai/alai
          xlaimn(i, j) = sumlmn/alai
          rstmin(i, j) = sumlai/sumrsi
          g_znt(i, j) = 0.0_8
          znt(i, j) = EXP(sumlz0/alai)
          xveg(i, j) = sumveg/alai
          xvegmn(i, j) = sumvmn/alai
          xsnup(i, j) = sumsnup/alai
          xalb(i, j) = sumalb/alai
        END IF
        IF (fwat .GT. 0.50) THEN
          g_znt(i, j) = 0.0_8
          znt(i, j) = z0(kwat)
          xalb(i, j) = albf(kwat)
        END IF
!CONVERT TO M
        g_znt(i, j) = 0.01D0*g_znt(i, j)
        znt(i, j) = znt(i, j)*0.01D0
!CONVERT TO FRAC
        xveg(i, j) = xveg(i, j)*0.01D0
        xvegmn(i, j) = xvegmn(i, j)*0.01D0
        xland(i, j) = 1.0D0 + fwat
        xalb(i, j) = xalb(i, j)*0.01D0
      END DO
    END DO
  END SUBROUTINE G_VEGELAND
!-------------------------------------------------------------------------
!-------------------------------------------------------------------------
!-------------------------------------------------------------------------
!-------------------------------------------------------------------------

!  Differentiation of surfpx in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: capg wr hfx w2 t2 qfx wg tg
!   with respect to varying inputs: lai qv1 capg wr dens1 ust theta1
!                z1 ta1 w2 betap t2 cpair znt vegfrc qss rh2obs
!                qst12 psurf wg mol tg
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
  SUBROUTINE G_SURFPX(dtpbl, ifland, isnow, nudgex, xice1, soldn, gsw, &
&    lwdn, emissi, z1, g_z1, mol, g_mol, znt, g_znt, ust, g_ust, psurf, &
&    g_psurf, dens1, g_dens1, qv1, g_qv1, qss, g_qss, ta1, g_ta1, theta1&
&    , g_theta1, precip, cpair, g_cpair, psih, rh2obs, g_rh2obs, t2obs, &
&    vegfrc, g_vegfrc, isti, lai, g_lai, betap, g_betap, rstmin, hc_snow&
&    , snow_fra, wwlt, wfc, cgsat, wsat, b, c1sat, c2r, as, jp, ds1, ds2&
&    , qst12, g_qst12, radnet, grdflx, hfx, g_hfx, qfx, g_qfx, lh, eg, er&
&    , etr, qst, capg, g_capg, rs, ra, tg, g_tg, t2, g_t2, wg, g_wg, w2, &
&    g_w2, wr, g_wr, ta2, qa2, land_use_type)
    IMPLICIT NONE
!.......Arguments
!.. Integer
    INTEGER, INTENT(IN) :: isti, nudgex
!... Real
    REAL, INTENT(IN) :: dtpbl, ds1, ds2
    REAL, INTENT(IN) :: ifland, isnow, xice1
    REAL, INTENT(IN) :: soldn, gsw, lwdn, emissi, z1
    REAL, INTENT(IN) :: g_z1
    REAL, INTENT(IN) :: znt
    REAL, INTENT(IN) :: g_znt
    REAL, INTENT(IN) :: psurf, dens1, qv1, qss, ta1, theta1, precip
    REAL, INTENT(IN) :: g_psurf, g_dens1, g_qv1, g_qss, g_ta1, g_theta1
    REAL, INTENT(IN) :: cpair
    REAL, INTENT(IN) :: g_cpair
    REAL, INTENT(IN) :: vegfrc, lai
    REAL, INTENT(IN) :: g_vegfrc, g_lai
    REAL, INTENT(IN) :: rstmin, hc_snow, snow_fra
    REAL, INTENT(IN) :: wwlt, wfc, cgsat, wsat, b, c1sat, c2r, as, jp
    REAL, INTENT(IN) :: rh2obs, t2obs
    REAL, INTENT(IN) :: g_rh2obs
    REAL, INTENT(IN) :: qst12
    REAL, INTENT(IN) :: g_qst12
    REAL, INTENT(OUT) :: radnet, eg, er, etr
    REAL :: g_eg
    REAL, INTENT(OUT) :: qst, capg, rs, ta2, qa2
    REAL, INTENT(OUT) :: g_capg
    REAL, INTENT(INOUT) :: tg, t2, wg, w2, wr, ust, ra, betap
    REAL, INTENT(INOUT) :: g_tg, g_t2, g_wg, g_w2, g_wr, g_ust, g_betap
    REAL, INTENT(INOUT) :: grdflx, qfx, hfx, lh, psih, mol
    REAL, INTENT(INOUT) :: g_qfx, g_hfx, g_mol
    CHARACTER(len=5), INTENT(IN) :: land_use_type
!... Local Variables
!... Real
    REAL :: hf, lv, cq4
    REAL :: g_hf, g_lv, g_cq4
    REAL :: rah, raw, et, w2cg, cg, ct, soilflx, cpot, thetag
    REAL :: g_rah, g_raw, g_et, g_w2cg, g_cg, g_ct, g_cpot, g_thetag
    REAL :: zol, zobol, zntol, y, y0, psih15, ynt
    REAL :: g_zol, g_zobol, g_zntol, g_y, g_y0, g_psih15, g_ynt
    REAL :: wgnudg, w2nudg, alph1, alph2, bet1, bet2, t1p5
    REAL :: g_wgnudg, g_w2nudg, g_alph1, g_alph2, g_bet1, g_bet2
    REAL :: cq1, cq2, cq3, coeffnp1, coeffn, tsnew, tshlf, t2new
    REAL :: g_cq1, g_cq2, g_cq3, g_coeffnp1, g_coeffn, g_tsnew, g_tshlf&
&    , g_t2new
    REAL :: roff, wrmax, pc, dwr, pnet, tendwr, wrnew
    REAL :: g_roff, g_wrmax, g_pc, g_dwr, g_pnet, g_tendwr, g_wrnew
    REAL :: cof1, cfnp1wr, cfnwr, pg, fass
    REAL :: g_cof1, g_cfnp1wr, g_cfnwr, g_pg, g_fass
    REAL :: tendw2, w2new, w2hlf, w2rel, c1, c2, weq, cfnp1, cfn, wgnew
    REAL :: g_tendw2, g_w2new, g_w2hlf, g_w2rel, g_c1, g_c2, g_weq, &
&    g_cfnp1, g_cfn, g_wgnew
    REAL :: aln10, tmp1, tmp2, tmp3, aa, ab, tst, rbh, ctveg
    REAL :: g_tst
    REAL :: qst1, phih, psiob
    REAL :: g_qst1, g_phih, g_psiob
    REAL :: t2nud, t2nudf
    REAL :: g_t2nud
    REAL :: vapprs, qsbt, rh2mod
    REAL :: g_vapprs, g_qsbt, g_rh2mod
!... Parameters
    REAL :: zobs, gamah, betah, sigf, bh, ct_snow
! K-M2/J
    REAL, PARAMETER :: cv=8.0d-6
    PARAMETER (zobs=1.5D0)
    PARAMETER (bh=15.7D0)
! height for observed screen temp., (m)
    PARAMETER (gamah=16.D0)
    PARAMETER (betah=5.0D0)
!11.6)
    PARAMETER (sigf=0.5D0)
!8.21)
    PARAMETER (ct_snow=2.0d-5)
! rain interception see LSM (can be 0-1)
!PARAMETER (CT_SNOW  = 5.54E-5)   
! New value of CT_SNOW calibrated using multilayer soil model where csnow=6.9E5 J/(m3 K) 
! from NCAR CSM                                         
    REAL :: pwx1
    REAL :: g_pwx1
    REAL :: arg1
    REAL :: g_arg1
    REAL :: arg10
    REAL :: g_arg10
    REAL :: pwx10
    REAL :: g_pwx10
    REAL :: pwy1
    REAL :: pwr1
    REAL :: g_pwr1
    REAL :: pwr10
    REAL :: g_pwr10
    REAL :: pwy2
    REAL :: pwr2
    REAL :: g_pwr2
    REAL :: g_ra
    REAL :: g_qst
    REAL :: g_etr
    REAL :: g_qa2
    REAL :: g_ta2
    REAL :: g_psih
    REAL :: g_er
    aln10 = ALOG(10.0D0)
! NET RADIATION                             
    radnet = soldn - emissi*(stbolt*tg**4-lwdn)
!--------------------------------------------------------------------
! rcp is global constant(module_model_constants)                            
    g_pwx1 = -(100.0D0*g_psurf/psurf**2)
    pwx1 = 100.0D0/psurf
    IF (pwx1 .GT. 0.0_8 .OR. (pwx1 .LT. 0.0_8 .AND. rovcp .EQ. INT(rovcp&
&        ))) THEN
      g_cpot = rovcp*pwx1**(rovcp-1)*g_pwx1
    ELSE IF (pwx1 .EQ. 0.0_8 .AND. rovcp .EQ. 1.0) THEN
      g_cpot = g_pwx1
    ELSE
      g_cpot = 0.0_8
    END IF
    cpot = pwx1**rovcp
    g_thetag = g_tg*cpot + tg*g_cpot
    thetag = tg*cpot
    g_zol = (g_z1*mol-z1*g_mol)/mol**2
    zol = z1/mol
    g_zobol = -(zobs*g_mol/mol**2)
    zobol = zobs/mol
    g_zntol = (g_znt*mol-znt*g_mol)/mol**2
    zntol = znt/mol
!-----------------------------------------------------------------------------------------
    IF (mol .LT. 0.0) THEN
      IF (1.0D0 - gamah*zol .GT. 0.0_8) THEN
        g_y = -(0.5D0*(1.0D0-gamah*zol)**(-0.5D0)*gamah*g_zol)
      ELSE
        g_y = 0.0_8
      END IF
      y = (1.0D0-gamah*zol)**0.5D0
      IF (1.0D0 - gamah*zobol .GT. 0.0_8) THEN
        g_y0 = -(0.5D0*(1.0D0-gamah*zobol)**(-0.5D0)*gamah*g_zobol)
      ELSE
        g_y0 = 0.0_8
      END IF
      y0 = (1.0D0-gamah*zobol)**0.5D0
      IF (1.0D0 - gamah*zntol .GT. 0.0_8) THEN
        g_ynt = -(0.5D0*(1.0D0-gamah*zntol)**(-0.5D0)*gamah*g_zntol)
      ELSE
        g_ynt = 0.0_8
      END IF
      ynt = (1.0D0-gamah*zntol)**0.5D0
      g_arg1 = (g_y*(y0+1.0D0)-(y+1.0D0)*g_y0)/(y0+1.0D0)**2
      arg1 = (y+1.0D0)/(y0+1.0D0)
      g_psih15 = 2.0D0*g_arg1/arg1
      psih15 = 2.0D0*ALOG(arg1)
      g_arg1 = (g_y*(ynt+1.0D0)-(y+1.0D0)*g_ynt)/(ynt+1.0D0)**2
      arg1 = (y+1.0D0)/(ynt+1.0D0)
      g_psih = 2.0D0*g_arg1/arg1
      psih = 2.0D0*ALOG(arg1)
      g_arg1 = (g_y0*(ynt+1.0D0)-(y0+1.0D0)*g_ynt)/(ynt+1.0D0)**2
      arg1 = (y0+1.0D0)/(ynt+1.0D0)
      g_psiob = 2.0D0*g_arg1/arg1
      psiob = 2.0D0*ALOG(arg1)
      g_phih = -(g_y/y**2)
      phih = 1.0D0/y
    ELSE
      IF (zol - zntol .LE. 1.0D0) THEN
        g_psih = -(betah*(g_zol-g_zntol))
        psih = -(betah*(zol-zntol))
      ELSE
        g_psih = g_zntol - g_zol
        psih = 1.D0 - betah - (zol-zntol)
      END IF
      IF (zobol - zntol .LE. 1.0D0) THEN
        g_psiob = -(betah*(g_zobol-g_zntol))
        psiob = -(betah*(zobol-zntol))
      ELSE
        g_psiob = g_zntol - g_zobol
        psiob = 1.0D0 - betah - (zobol-zntol)
      END IF
      g_psih15 = g_psih - g_psiob
      psih15 = psih - psiob
      IF (zol .LE. 1.0) THEN
        g_phih = betah*g_zol
        phih = 1.0D0 + betah*zol
      ELSE
        g_phih = g_zol
        phih = betah + zol
      END IF
    END IF
!-----------------------------------------------------------------------------------------
!-- ADD RA AND RB FOR HEAT AND MOISTURE
!... RB FOR HEAT = 5 /UST
!... RB FOR WATER VAPOR =  5*(0.599/0.709)^2/3 /UST = 4.503/UST
    g_ra = (pr0*((g_z1*znt-z1*g_znt)/(znt*z1)-g_psih)*karman*ust-pr0*(&
&      ALOG(z1/znt)-psih)*karman*g_ust)/(karman*ust)**2
    ra = pr0*(ALOG(z1/znt)-psih)/(karman*ust)
    g_rah = g_ra - 5.0D0*g_ust/ust**2
    rah = ra + 5.0D0/ust
    g_raw = g_ra - 4.503D0*g_ust/ust**2
    raw = ra + 4.503D0/ust
!--------------------------------------------------------------------
!--  COMPUTE MOISTURE FLUX
    CALL G_QFLUX(dens1, g_dens1, qv1, g_qv1, ta1, g_ta1, soldn, raw, &
&           g_raw, qss, g_qss, vegfrc, g_vegfrc, isnow, isti, ifland, lai&
&           , g_lai, betap, g_betap, wg, w2, g_w2, wr, g_wr, rstmin, wwlt&
&           , wfc, eg, g_eg, er, g_er, etr, g_etr, cq4, g_cq4, rs, fass, &
&           g_fass)
!--------------------------------------------------------------------
!--------------------------------------------------------------------
!..........Total evaporation (ET)
    g_et = g_eg + g_er + g_etr
    et = eg + er + etr
    g_qst = -((g_et*dens1*ust-et*(g_dens1*ust+dens1*g_ust))/(dens1*ust)&
&      **2)
    qst = -(et/(dens1*ust))
!-- LATENT HEAT OF SUBLIMATION AT 0C FROM STULL(1988)
    lv = 2.83d6
!-- FROM STULL(1988) in J/KG
    IF (isnow .LT. 0.5 .AND. tg .GT. 273.15) THEN
      g_lv = -(1.d6*0.00237D0*g_tg)
      lv = (2.501D0-0.00237D0*(tg-273.15D0))*1.d6
    ELSE
      g_lv = 0.0_8
    END IF
! IF (IFLAND .LT. 1.5 )  QFX = ET     !-- Recaculate QFX over land to account for P-X LSM EG, ER and ETR
    g_qfx = g_et
    qfx = et
    lh = lv*qfx
!-----------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------
! Surface sensible heat flux
    g_tst = ((g_theta1-g_thetag)*ust*rah-(theta1-thetag)*(g_ust*rah+ust*&
&      g_rah))/(ust*rah)**2
    tst = (theta1-thetag)/(ust*rah)
    g_hf = g_ust*tst + ust*g_tst
    hf = ust*tst
    IF (-(dens1*cpair*hf) .LT. -250.0) THEN
      hfx = -250.0D0
      g_hfx = 0.0_8
    ELSE
      g_hfx = -((g_dens1*cpair+dens1*g_cpair)*hf+dens1*cpair*g_hf)
      hfx = -(dens1*cpair*hf)
    END IF
!-----------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------
! Compute the diagnosed 2m Q and T consistent with PX LSM
    g_qst1 = 0.5D0*(g_qst+(g_qst12*phih-qst12*g_phih)/phih**2)
    qst1 = 0.5D0*(qst+qst12/phih)
    g_ta2 = ((g_thetag+g_tst*(pr0/karman*(ALOG(zobs/znt)-psiob)+5.D0)+tst*&
&      pr0*(-(g_znt/znt)-g_psiob)/karman)*cpot-(thetag+tst*(pr0/karman*(&
&      ALOG(zobs/znt)-psiob)+5.D0))*g_cpot)/cpot**2
    ta2 = (thetag+tst*(pr0/karman*(ALOG(zobs/znt)-psiob)+5.D0))/cpot
    g_qa2 = g_qv1 - pr0*g_qst1*(ALOG(z1/zobs)-psih15)/karman - qst1*pr0*&
&      (g_z1/z1-g_psih15)/karman
    qa2 = qv1 - qst1*pr0/karman*(ALOG(z1/zobs)-psih15)
    IF (qa2 .LE. 0.0) THEN
      g_qa2 = g_qv1
      qa2 = qv1
    END IF
!--  Relative humidity
    g_arg10 = (svp2*g_ta2*(ta2-svp3)-svp2*(ta2-svpt0)*g_ta2)/(ta2-svp3)&
&      **2
    arg10 = svp2*(ta2-svpt0)/(ta2-svp3)
    g_vapprs = svp1*g_arg10*EXP(arg10)
    vapprs = svp1*EXP(arg10)
    g_qsbt = (ep_2*g_vapprs*(psurf-vapprs)-ep_2*vapprs*(g_psurf-g_vapprs&
&      ))/(psurf-vapprs)**2
    qsbt = ep_2*vapprs/(psurf-vapprs)
    g_rh2mod = (g_qa2*qsbt-qa2*g_qsbt)/qsbt**2
    rh2mod = qa2/qsbt
!-----------------------------------------------------------------------------------------
    IF (ifland .LT. 1.5) THEN
      IF (w2 .LT. wwlt) THEN
        w2cg = wwlt
        g_w2cg = 0.0_8
      ELSE
        g_w2cg = g_w2
        w2cg = w2
      END IF
      g_pwx10 = -(wsat*g_w2cg/w2cg**2)
      pwx10 = wsat/w2cg
      pwy1 = 0.5D0*b/aln10
      IF (pwx10 .GT. 0.0_8 .OR. (pwx10 .LT. 0.0_8 .AND. pwy1 .EQ. INT(&
&          pwy1))) THEN
        g_pwr1 = pwy1*pwx10**(pwy1-1.D0)*g_pwx10
      ELSE IF (pwx10 .EQ. 0.0_8 .AND. pwy1 .EQ. 1.0D0) THEN
        g_pwr1 = g_pwx10
      ELSE
        g_pwr1 = 0.0_8
      END IF
      pwr1 = pwx10**pwy1
      g_cg = cgsat*1.0d-6*g_pwr1
      cg = cgsat*1.0d-6*pwr1
      g_ct = -(((-(g_vegfrc*cg)-(1.D0-vegfrc)*g_cg)/cg**2+g_vegfrc/cv)/((1.D0-&
&        vegfrc)/cg+vegfrc/cv)**2)
      ct = 1.D0/((1.D0-vegfrc)/cg+vegfrc/cv)
      g_ct = -((-((1.D0-snow_fra)*g_ct/ct**2))/(snow_fra/ct_snow+(1.D0-&
&        snow_fra)/ct)**2)
      ct = 1.D0/(snow_fra/ct_snow+(1.D0-snow_fra)/ct)
      g_capg = -(g_ct/ct**2)
      capg = 1.0D0/ct
      soilflx = 2.0D0*pi*tauinv*(tg-t2)
      grdflx = soilflx/ct
    ELSE
      g_ct = 0.0_8
    END IF
!-----------------------------------------------------------------------------------------
!--------------------------------------------------------------------
!-- ASSIMILATION --- COMPUTE SOIL MOISTURE NUDGING FROM TA2 and RH2               
!-------COMPUTE ASSIMILATION COEFFICIENTS FOR ALL I                            
    IF (ifland .LT. 1.5) THEN
      IF (nudgex .EQ. 0) THEN
!-- NO NUDGING CASE                
        wgnudg = 0.0D0
        w2nudg = 0.0D0
        t2nud = 0.0D0
        g_t2nud = 0.0_8
        g_w2nudg = 0.0_8
        g_wgnudg = 0.0_8
      ELSE
!-- NUDGING CASE        
        CALL G_SMASS(isti, fass, g_fass, soldn, vegfrc, g_vegfrc, ra, &
&               g_ra, wwlt, wfc, alph1, g_alph1, alph2, g_alph2, bet1, &
&               g_bet1, bet2, g_bet2, t2nudf)
!--COMPUTE MODEL RH
        g_wgnudg = g_alph1*(t2obs-ta2) - alph1*g_ta2 + 100.D0*(g_alph2*(&
&          rh2obs-rh2mod)) + 100.D0*(alph2*(g_rh2obs-g_rh2mod))
        wgnudg = alph1*(t2obs-ta2) + alph2*(rh2obs-rh2mod)*100.D0
        g_w2nudg = g_bet1*(t2obs-ta2) - bet1*g_ta2 + 100.D0*(g_bet2*(rh2obs&
&          -rh2mod)) + 100.D0*(bet2*(g_rh2obs-g_rh2mod))
        w2nudg = bet1*(t2obs-ta2) + bet2*(rh2obs-rh2mod)*100D0
        IF (w2 .GE. wfc) THEN
          IF (w2nudg .GT. 0.0) THEN
            w2nudg = 0.0D0
            g_w2nudg = 0.0_8
          ELSE
            w2nudg = w2nudg
          END IF
        END IF
        IF (w2 .LE. wwlt) THEN
          IF (w2nudg .LT. 0.0) THEN
            w2nudg = 0.0D0
            g_w2nudg = 0.0_8
          ELSE
            w2nudg = w2nudg
          END IF
        END IF
        g_t2nud = -(t2nudf*g_ta2)
        t2nud = t2nudf*(t2obs-ta2)
!print *, 'T2NUD =',T2NUD,T2NUDF
      END IF
    ELSE
      g_t2nud = 0.0_8
      g_w2nudg = 0.0_8
      g_wgnudg = 0.0_8
    END IF
!-----------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------
!-- Compute new values for TS,T2,WG,W2 and WR. No change over ice or water (XLAND > 1)
    IF (ifland .LT. 1.5) THEN
!-- SOLVE BY CRANK-NIC --   TENDTS=CT*(RADNET-HFX-QFX)-SOILFLX 
!-- Calculate the coefficients for implicit calculation of TG
      g_cq1 = (1.0D0-0.622D0*lv*crankp/(r_d*tg))*g_qss - (0.622D0*crankp*g_lv*&
&        r_d*tg-0.622D0*lv*crankp*r_d*g_tg)*qss/(r_d**2*tg**2)
      cq1 = (1.0D0-0.622D0*lv*crankp/(r_d*tg))*qss
      g_cq2 = (0.622D0*crankp*(g_lv*qss+lv*g_qss)*r_d*tg**2-0.622D0*lv*qss*&
&        crankp*r_d*(g_tg*tg+tg*g_tg))/(r_d*tg*tg)**2
      cq2 = 0.622D0*lv*qss*crankp/(r_d*tg*tg)
      g_cq3 = (((g_dens1*betap+dens1*g_betap)*(1.0D0-vegfrc)-dens1*betap*&
&        g_vegfrc)*raw-dens1*betap*(1.0D0-vegfrc)*g_raw)/raw**2
      cq3 = dens1*betap*(1.0D0-vegfrc)/raw
      g_coeffnp1 = dtpbl*crankp*(4.0D0*emissi*stbolt*(3.D0*tg**2*g_tg*ct+tg**&
&        3*g_ct)+((g_dens1*cpair+dens1*g_cpair)*rah-dens1*cpair*g_rah)*&
&        cpot*ct/rah**2+dens1*cpair*(g_cpot*ct+cpot*g_ct)/rah) + dtpbl*((&
&        g_ct*lv+ct*g_lv)*cq2*(cq3+cq4)+ct*lv*(g_cq2*(cq3+cq4)+cq2*(g_cq3&
&        +g_cq4)))
      coeffnp1 = 1.0D0 + dtpbl*crankp*(4.0D0*emissi*stbolt*tg**3*ct+dens1*&
&        cpair/rah*cpot*ct+2.0D0*pi*tauinv) + dtpbl*(ct*lv*cq2*(cq3+cq4))
!NET RAD
!SFC HEAT FLUX 
!SOIL FLUX
      g_coeffn = g_ct*(gsw+emissi*(stbolt*(4.0D0*crankp-1.0D0)*tg*tg*tg*tg+&
&        lwdn)+dens1*cpair/rah*(theta1-(1.0D0-crankp)*thetag)-lv*(cq3*(cq1-&
&        qv1)+cq4*(cq1-qv1))) + ct*(emissi*stbolt*(4.0D0*crankp-1.0D0)*((g_tg&
&        *tg+tg*g_tg)*tg**2+tg**2*(g_tg*tg+tg*g_tg))+((g_dens1*cpair+&
&        dens1*g_cpair)*rah-dens1*cpair*g_rah)*(theta1-(1.0D0-crankp)*&
&        thetag)/rah**2+dens1*cpair*(g_theta1-(1.0D0-crankp)*g_thetag)/rah-&
&        g_lv*(cq3*(cq1-qv1)+cq4*(cq1-qv1))-lv*(g_cq3*(cq1-qv1)+cq3*(&
&        g_cq1-g_qv1)+g_cq4*(cq1-qv1)+cq4*(g_cq1-g_qv1))) - 2.0D0*pi*tauinv&
&        *((1.0D0-crankp)*g_tg-g_t2)
      coeffn = ct*(gsw+emissi*(stbolt*(4.0D0*crankp-1.0D0)*tg*tg*tg*tg+lwdn)&
&        +dens1*cpair/rah*(theta1-(1.0D0-crankp)*thetag)-lv*(cq3*(cq1-qv1)+&
&        cq4*(cq1-qv1))) - 2.0D0*pi*tauinv*((1.0D0-crankp)*tg-t2)
      g_tsnew = ((g_tg+dtpbl*g_coeffn)*coeffnp1-(tg+dtpbl*coeffn)*&
&        g_coeffnp1)/coeffnp1**2
      tsnew = (tg+dtpbl*coeffn)/coeffnp1
!-- FOR SNOW COVERED SURFACE TEMPERATURE IS NOT MORE THAN ZERO
! Re-added Jan 2010 to keep ice surface at or below freezing (J. Pleim)
      IF (xice1 .GT. 0.5) THEN
        IF (tsnew .GT. 273.15) THEN
          tsnew = 273.15D0
          g_tsnew = 0.0_8
        ELSE
          tsnew = tsnew
        END IF
      END IF
      g_tshlf = 0.5D0*(g_tsnew+g_tg)
      tshlf = 0.5D0*(tsnew+tg)
! Added deep temperature nudging 
      g_t2new = (g_t2+dtpbl*tauinv*t2tfac*(g_tshlf-(1.D0-crankp)*g_t2)+&
&        dtpbl*g_t2nud)/(1.0D0+dtpbl*tauinv*t2tfac*crankp)
      t2new = (t2+dtpbl*tauinv*t2tfac*(tshlf-(1.D0-crankp)*t2)+dtpbl*t2nud)&
&        /(1.0D0+dtpbl*tauinv*t2tfac*crankp)
!-- REPLACE OLD with NEW Value
      g_tg = g_tsnew
      tg = tsnew
      g_t2 = g_t2new
      t2 = t2new
    END IF
!-----------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------
! Compute new subsurface soil and canopy moisture values DENS1. No change required over ocean.
    IF (ifland .LT. 1.5 .AND. xice1 .LT. 0.5) THEN
!-- Compute WR
      roff = 0.0D0
! max. WRMAX IN m
      g_wrmax = 0.2d-3*(g_vegfrc*lai+vegfrc*g_lai)
      wrmax = 0.2d-3*vegfrc*lai
      IF (wrmax .GT. 0.0) THEN
!--  PC is precip. intercepted by veg.(M/S)
        g_pc = sigf*precip*g_vegfrc
        pc = vegfrc*sigf*precip
!the tendency to reach max.
        g_dwr = (g_wrmax-g_wr)/dtpbl
        dwr = (wrmax-wr)/dtpbl
! residual of precip. and evap.
        g_pnet = g_pc - g_er/denw
        pnet = pc - er/denw
        IF (pnet .GT. dwr) THEN
          g_roff = g_pnet - g_dwr
          roff = pnet - dwr
          g_pc = g_pc - g_roff
          pc = pc - roff
        END IF
        IF (qss .LT. qv1) THEN
          g_tendwr = g_pc - g_er/denw
          tendwr = pc - er/denw
          g_wrnew = g_wr + dtpbl*g_tendwr
          wrnew = wr + dtpbl*tendwr
        ELSE
          g_cof1 = ((g_dens1*vegfrc*(qss-qv1)/denw+dens1*(g_vegfrc*(qss-&
&            qv1)+vegfrc*(g_qss-g_qv1))/denw)*raw-dens1*vegfrc*(qss-qv1)*&
&            g_raw/denw)/raw**2
          cof1 = dens1/denw*vegfrc*(qss-qv1)/raw
!-- using delta=wr/wrmax
          g_cfnp1wr = (dtpbl*crankp*g_cof1*wrmax-dtpbl*cof1*crankp*&
&            g_wrmax)/wrmax**2
          cfnp1wr = 1.0D0 + dtpbl*cof1*crankp/wrmax
          g_cfnwr = g_pc - ((1.0D0-crankp)*(g_cof1*wr+cof1*g_wr)*wrmax-&
&            cof1*(1.0D0-crankp)*wr*g_wrmax)/wrmax**2
          cfnwr = pc - cof1*(1.0D0-crankp)*wr/wrmax
          g_wrnew = ((g_wr+dtpbl*g_cfnwr)*cfnp1wr-(wr+dtpbl*cfnwr)*&
&            g_cfnp1wr)/cfnp1wr**2
          wrnew = (wr+dtpbl*cfnwr)/cfnp1wr
        END IF
      ELSE
        pc = 0.0D0
        wrnew = 0.0D0
        g_wrnew = 0.0_8
        g_pc = 0.0_8
      END IF
!---------------------------------------------
!-- Compute W2
! PG is precip. reaching soil (PC already including ROFF)
      g_pg = -(denw*g_pc)
      pg = denw*(precip-pc)
! NUDGING
      g_tendw2 = (g_pg-g_eg-g_etr)/(denw*ds2) + (g_w2nudg+g_wgnudg)/ds2
      tendw2 = 1.0D0/(denw*ds2)*(pg-eg-etr) + (w2nudg+wgnudg)/ds2
      g_w2new = g_w2 + dtpbl*g_tendw2
      w2new = w2 + dtpbl*tendw2
      IF (w2new .GT. wsat) THEN
        w2new = wsat
        g_w2new = 0.0_8
      ELSE
        w2new = w2new
      END IF
      IF (w2new .LT. 0.05) THEN
        w2new = 0.05D0
        g_w2new = 0.0_8
      ELSE
        w2new = w2new
      END IF
      g_w2hlf = 0.5D0*(g_w2+g_w2new)
      w2hlf = 0.5D0*(w2+w2new)
!.. new values
      g_w2 = g_w2new
      w2 = w2new
      IF (wrmax .GT. wrnew) THEN
        g_wr = g_wrnew
        wr = wrnew
      ELSE
        g_wr = g_wrmax
        wr = wrmax
      END IF
    ELSE
      g_w2hlf = 0.0_8
      g_pg = 0.0_8
    END IF
!endif for XLAND
!-----------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------
! Compute new surface soil moisture values (WR).
    IF (ifland .LT. 1.5 .AND. xice1 .LT. 0.5) THEN
!endif for ISNOW
! over ocean no change to wg w2,wr
!--    FOR SNOW COVERED SURFACE, ASSUME SURFACE IS SATURATED AND
!      WG AND W2 ARE NOT CHANGED
      IF (isnow .GT. 0.5) THEN
        wg = wsat
        g_wg = 0.0_8
      ELSE
        g_w2rel = g_w2hlf/wsat
        w2rel = w2hlf/wsat
        IF (wg .GT. wwlt) THEN
          g_pwx10 = -(wsat*g_wg/wg**2)
          pwx10 = wsat/wg
          pwy1 = 0.5D0*b + 1.0D0
          IF (pwx10 .GT. 0.0_8 .OR. (pwx10 .LT. 0.0_8 .AND. pwy1 .EQ. &
&              INT(pwy1))) THEN
            g_pwr1 = pwy1*pwx10**(pwy1-1)*g_pwx10
          ELSE IF (pwx10 .EQ. 0.0_8 .AND. pwy1 .EQ. 1.0) THEN
            g_pwr1 = g_pwx10
          ELSE
            g_pwr1 = 0.0_8
          END IF
          pwr1 = pwx10**pwy1
          g_c1 = c1sat*g_pwr1
          c1 = c1sat*pwr1
        ELSE
! elimilate C1 for wg < wilting point
          pwx10 = wsat/wwlt
          pwy1 = 0.5D0*b + 1.0D0
          pwr1 = pwx10**pwy1
          c1 = c1sat*pwr1
          g_c1 = 0.0_8
        END IF
        g_c2 = (c2r*g_w2hlf*(wsat-w2hlf+1.d-11)+c2r*w2hlf*g_w2hlf)/(wsat&
&          -w2hlf+1.d-11)**2
        c2 = c2r*w2hlf/(wsat-w2hlf+1.d-11)
        IF (w2hlf .EQ. wsat) THEN
          weq = wsat
          g_weq = 0.0_8
        ELSE
          IF (w2rel .GT. 0.0_8 .OR. (w2rel .LT. 0.0_8 .AND. jp .EQ. INT(&
&              jp))) THEN
            g_pwr10 = jp*w2rel**(jp-1.D0)*g_w2rel
          ELSE IF (w2rel .EQ. 0.0_8 .AND. jp .EQ. 1.0) THEN
            g_pwr10 = g_w2rel
          ELSE
            g_pwr10 = 0.0_8
          END IF
          pwr10 = w2rel**jp
          pwy2 = 8.0D0*jp
          IF (w2rel .GT. 0.0_8 .OR. (w2rel .LT. 0.0_8 .AND. pwy2 .EQ. &
&              INT(pwy2))) THEN
            g_pwr2 = pwy2*w2rel**(pwy2-1.D0)*g_w2rel
          ELSE IF (w2rel .EQ. 0.0_8 .AND. pwy2 .EQ. 1.0) THEN
            g_pwr2 = g_w2rel
          ELSE
            g_pwr2 = 0.0_8
          END IF
          pwr2 = w2rel**pwy2
          g_weq = g_w2hlf - as*wsat*(g_pwr10*(1.0D0-pwr2)-pwr10*g_pwr2)
          weq = w2hlf - as*wsat*pwr10*(1.0D0-pwr2)
        END IF
!.... The beta method, Lee & Pielke (JAM, May 1992)
        g_cfnp1 = dtpbl*tauinv*crankp*g_c2
        cfnp1 = 1.0D0 + dtpbl*c2*tauinv*crankp
        g_cfn = g_c1*(pg-eg)/(denw*ds1) + c1*(g_pg-g_eg)/(denw*ds1) - &
&          tauinv*(g_c2*((1.0D0-crankp)*wg-weq)+c2*((1.0D0-crankp)*g_wg-g_weq&
&          )) + g_wgnudg/ds1
        cfn = c1/(denw*ds1)*(pg-eg) - c2*tauinv*((1.0D0-crankp)*wg-weq) + &
&          wgnudg/ds1
        IF ((wg+dtpbl*cfn)/cfnp1 .LT. 0.001) THEN
          wgnew = 0.001D0
          g_wgnew = 0.0_8
        ELSE
          g_wgnew = ((g_wg+dtpbl*g_cfn)*cfnp1-(wg+dtpbl*cfn)*g_cfnp1)/&
&            cfnp1**2
          wgnew = (wg+dtpbl*cfn)/cfnp1
        END IF
        IF (wgnew .GT. wsat) THEN
          wg = wsat
          g_wg = 0.0_8
        ELSE
          g_wg = g_wgnew
          wg = wgnew
        END IF
      END IF
    END IF
  END SUBROUTINE G_SURFPX
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------

!  Differentiation of qflux in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: eg betap er etr fass cq4
!   with respect to varying inputs: lai qv1 wr dens1 ta1 w2 betap
!                vegfrc qss raw
!-------------------------------------------------------------------------
!-------------------------------------------------------------------------

  SUBROUTINE G_QFLUX(dens1, g_dens1, qv1, g_qv1, ta1, g_ta1, rg, raw, &
&    g_raw, qss, g_qss, vegfrc, g_vegfrc, isnow, isti, ifland, lai, g_lai&
&    , betap, g_betap, wg, w2, g_w2, wr, g_wr, rstmin, wwlt, wfc, eg, &
&    g_eg, er, g_er, etr, g_etr, cq4, g_cq4, rs, fass, g_fass)
    IMPLICIT NONE
! DECLARATIONS - INTEGER
    INTEGER, INTENT(IN) :: isti
! DECLARATIONS - REAL
    REAL, INTENT(IN) :: isnow, ifland
    REAL, INTENT(IN) :: dens1, qv1, ta1, rg, raw, qss, vegfrc, lai, wg, &
&    w2, wr, rstmin
    REAL, INTENT(IN) :: g_dens1, g_qv1, g_ta1, g_raw, g_qss, g_vegfrc, &
&    g_lai, g_w2, g_wr
    REAL, INTENT(INOUT) :: betap
    REAL, INTENT(INOUT) :: g_betap
    REAL, INTENT(IN) :: wwlt, wfc
    REAL, INTENT(OUT) :: eg, er, etr, cq4, rs, fass
    REAL, INTENT(OUT) :: g_eg, g_er, g_etr, g_cq4, g_fass
!... Local Variables
!... Real
    REAL :: wrmax, delta, sigg, radl, radf, w2avail, w2mxav
    REAL :: g_wrmax, g_delta, g_sigg, g_radf, g_w2avail
    REAL :: ftot, f1, f2, f3, f4
    REAL :: g_ftot, g_f1, g_f2, g_f3, g_f4
    REAL :: fshelt, gs, ga, fx
    REAL :: g_gs, g_ga, g_fx
!... Parameters
! s/m
    REAL, PARAMETER :: rsmax=5000.0D0
! m/s
    REAL, PARAMETER :: ftmin=0.0000001D0
    REAL, PARAMETER :: f3min=0.25D0
    REAL :: arg1
    REAL :: g_arg1
    REAL :: result1
    REAL :: g_result1
    REAL :: x1
    REAL :: g_x1
    REAL :: g_rs
!
!... for water surface, no canopy evaporation and transpiration
    er = 0.0D0
    etr = 0.0D0
    cq4 = 0.0D0
!... GROUND EVAPORATION (DEPOSITION)
    IF (qss .LT. qv1) THEN
      betap = 1.0D0
      g_betap = 0.0_8
    END IF
    g_eg = (((g_dens1*betap+dens1*g_betap)*(1.0D0-vegfrc)*(qss-qv1)+dens1*&
&      betap*((1.0D0-vegfrc)*(g_qss-g_qv1)-g_vegfrc*(qss-qv1)))*raw-dens1*(&
&      1.0D0-vegfrc)*betap*(qss-qv1)*g_raw)/raw**2
    eg = dens1*(1.0D0-vegfrc)*betap*(qss-qv1)/raw
!!---------------------------------------------------------------------
!... CANOPY
    IF (ifland .LT. 1.5 .AND. vegfrc .GT. 0.0) THEN
! in unit m
      g_wrmax = 0.2d-3*(g_vegfrc*lai+vegfrc*g_lai)
      wrmax = 0.2d-3*vegfrc*lai
      IF (wr .LE. 0.0) THEN
        delta = 0.0d0
        g_delta = 0.0_8
      ELSE
!         DELTA = (WR / WRMAX) ** 0.66667
! referred to SiB model
        g_delta = (g_wr*wrmax-wr*g_wrmax)/wrmax**2
        delta = wr/wrmax
      END IF
      IF (qss .GE. qv1) THEN
        g_sigg = g_delta
        sigg = delta
      ELSE
        sigg = 1.0d0
        g_sigg = 0.0_8
      END IF
      g_er = (((g_dens1*vegfrc+dens1*g_vegfrc)*sigg*(qss-qv1)+dens1*&
&        vegfrc*(g_sigg*(qss-qv1)+sigg*(g_qss-g_qv1)))*raw-dens1*vegfrc*&
&        sigg*(qss-qv1)*g_raw)/raw**2
      er = dens1*vegfrc*sigg*(qss-qv1)/raw
    ELSE
      g_er = 0.0_8
      g_sigg = 0.0_8
    END IF
!!---------------------------------------------------------------------
!-- TRANSPIRATION
!!---------------------------------------------------------------------
    IF (ifland .LT. 1.5 .AND. vegfrc .GT. 0.0) THEN
!!!-RADIATION
      IF (rstmin .GT. 130.0) THEN
! W/M2
        radl = 30.0D0
      ELSE
! W/M2
        radl = 100.0D0
      END IF
! NP89 - EQN34
      g_radf = -(1.1D0*rg*radl*g_lai/(radl*lai)**2)
      radf = 1.1D0*rg/(radl*lai)
      g_f1 = (g_radf*(1.0D0+radf)-(rstmin/rsmax+radf)*g_radf)/(1.0D0+radf)**&
&        2
      f1 = (rstmin/rsmax+radf)/(1.0D0+radf)
!!!-SOIL MOISTURE
      g_w2avail = g_w2
      w2avail = w2 - wwlt
      w2mxav = wfc - wwlt
! according JP, 9/94
      g_arg1 = -(5.0D0*g_w2avail/w2mxav)
      arg1 = -(5.0D0*(w2avail/w2mxav-(w2mxav/3.0D0+wwlt)))
      g_f2 = -(g_arg1*EXP(arg1)/(1.0D0+EXP(arg1))**2)
      f2 = 1.0D0/(1.0D0+EXP(arg1))
!-AIR TEMP
!... according to Avissar (1985) and AX 7/95
      IF (ta1 .LE. 302.15) THEN
        g_f4 = -((-(0.41D0*g_ta1*EXP(-(0.41D0*(ta1-282.05D0)))))/(1.0D0+EXP(-(&
&          0.41D0*(ta1-282.05D0))))**2)
        f4 = 1.0D0/(1.0D0+EXP(-(0.41D0*(ta1-282.05D0))))
      ELSE
        g_f4 = -(0.5D0*g_ta1*EXP(0.5D0*(ta1-314.0D0))/(1.0D0+EXP(0.5D0*(ta1-314.0D0)&
&          ))**2)
        f4 = 1.0D0/(1.0D0+EXP(0.5D0*(ta1-314.0D0)))
      END IF
      g_ftot = (g_lai*f1+lai*g_f1)*f2*f4 + lai*f1*(g_f2*f4+f2*g_f4)
      ftot = lai*f1*f2*f4
    ELSE
      g_f1 = 0.0_8
      g_f4 = 0.0_8
      g_ftot = 0.0_8
    END IF
!!---------------------------------------------------------------------
    IF (ifland .LT. 1.5 .AND. vegfrc .GT. 0.0) THEN
! go back to NP89
      fshelt = 1.0D0
      g_gs = g_ftot/(rstmin*fshelt)
      gs = ftot/(rstmin*fshelt)
      g_ga = -(g_raw/raw**2)
      ga = 1.0D0/raw
!-- Compute humidity effect according to RH at leaf surf
      g_arg1 = g_ga*ga + ga*g_ga + (g_ga*gs+ga*g_gs)*(4.0D0*qv1/qss-2.0D0) +&
&        ga*gs*(4.0D0*g_qv1*qss-4.0D0*qv1*g_qss)/qss**2 + g_gs*gs + gs*g_gs
      arg1 = ga*ga + ga*gs*(4.0D0*qv1/qss-2.0D0) + gs*gs
      IF (arg1 .EQ. 0.0_8) THEN
        g_result1 = 0.0_8
      ELSE
        g_result1 = g_arg1/(2.0D0*SQRT(arg1))
      END IF
      result1 = SQRT(arg1)
      g_f3 = (0.5D0*(g_gs-g_ga+g_result1)*gs-0.5D0*(gs-ga+result1)*g_gs)/gs&
&        **2
      f3 = 0.5D0*(gs-ga+result1)/gs
      IF (f3 .LT. f3min) THEN
        x1 = f3min
        g_x1 = 0.0_8
      ELSE
        g_x1 = g_f3
        x1 = f3
      END IF
      IF (x1 .GT. 1.0) THEN
        f3 = 1.0D0
        g_f3 = 0.0_8
      ELSE
        g_f3 = g_x1
        f3 = x1
      END IF
      g_rs = -((g_gs*f3+gs*g_f3)/(gs*f3)**2)
      rs = 1.0D0/(gs*f3)
!--- Compute Assimilation factor for soil moisture nudging - jp 12/94
!--  Note that the 30 coef is to result in order 1 factor for max
      IF (rg .LT. 0.00001) THEN
! do not nudge during night
        fx = 0.0D0
        g_fx = 0.0_8
      ELSE
        g_fx = 30.0D0*((g_f1*f4+f1*g_f4)*lai+f1*f4*g_lai)/(rstmin*fshelt)
        fx = 30.0D0*f1*f4*lai/(rstmin*fshelt)
      END IF
      g_fass = g_fx
      fass = fx
      g_etr = (((g_dens1*vegfrc+dens1*g_vegfrc)*(1.0D0-sigg)*(qss-qv1)+&
&        dens1*vegfrc*((1.0D0-sigg)*(g_qss-g_qv1)-g_sigg*(qss-qv1)))*(raw+&
&        rs)-dens1*vegfrc*(1.0D0-sigg)*(qss-qv1)*(g_raw+g_rs))/(raw+rs)**2
      etr = dens1*vegfrc*(1.0D0-sigg)*(qss-qv1)/(raw+rs)
!..... CQ4 is used for the implicit calculation of TG in SURFACE
      g_cq4 = (g_dens1*vegfrc+dens1*g_vegfrc)*((1.0D0-sigg)/(raw+rs)+sigg/&
&        raw) + dens1*vegfrc*((-(g_sigg*(raw+rs))-(1.0D0-sigg)*(g_raw+g_rs)&
&        )/(raw+rs)**2+(g_sigg*raw-sigg*g_raw)/raw**2)
      cq4 = dens1*vegfrc*((1.0D0-sigg)/(raw+rs)+sigg/raw)
    ELSE
      g_etr = 0.0_8
      g_fass = 0.0_8
      g_cq4 = 0.0_8
    END IF
  END SUBROUTINE G_QFLUX
!-------------------------------------------------------------------------
!-------------------------------------------------------------------------

!  Differentiation of smass in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: bet1 bet2 alph1 alph2
!   with respect to varying inputs: ra vegfrc fass
!------------------------------------------------------------------------------------------
!------------------------------------------------------------------------------------------
!------------------------------------------------------------------------------------------
!------------------------------------------------------------------------------------------
!in                      
!in
  SUBROUTINE G_SMASS(isti, fass, g_fass, rg, vegfrc, g_vegfrc, ra, g_ra&
&    , wwlt, wfc, alph1, g_alph1, alph2, g_alph2, bet1, g_bet1, bet2, &
&    g_bet2, t2nudf)
    IMPLICIT NONE
!------------------------------------------------------------------------------------------
!     SMASS COMPUTES SOIL MOISTURE NUDGING COEFFICIENTS
!------------------------------------------------------------------------------------------
!
!.........Arguments
! max. soil types
    INTEGER, PARAMETER :: nscat=16
    INTEGER, INTENT(IN) :: isti
    REAL, INTENT(IN) :: fass, rg, vegfrc, ra
    REAL, INTENT(IN) :: g_fass, g_vegfrc, g_ra
    REAL, INTENT(IN) :: wwlt, wfc
    REAL, INTENT(OUT) :: alph1, alph2, bet1, bet2, t2nudf
    REAL, INTENT(OUT) :: g_alph1, g_alph2, g_bet1, g_bet2
!........Local variables
!... Real
    REAL :: fbet, falph, fra, ftext
    REAL :: g_fbet, g_fra, g_ftext
    REAL, DIMENSION(nscat) :: wfcx, wwltx
!... Parameters
! m/K, m for 6hr period
    REAL, PARAMETER :: a1max=-10.d-5, a2max=1.d-5
! m/K, m (Bouttier et al 1993)
    REAL, PARAMETER :: b1max=-10.d-3, b2max=1.d-3
! 1/6hr in 1/sec
    REAL, PARAMETER :: tassi=4.6296d-5
! 0.1 s/cm
    REAL, PARAMETER :: ramin=10.0D0
    REAL :: max2
!
!-- WFC is field capacity (M^3/M^3) (JN90)
      DATA WFCX   /  0.135D0, 0.150D0, 0.195D0, 0.255D0, 0.240D0, 0.255D0, 0.322D0,    &
                    0.325D0, 0.310D0, 0.370D0, 0.367D0, 0.367D0, 0.367D0, 0.367D0, 0.367D0, 0.367D0 /
!
!-- WWLT is wilting point (M^3/M^3) (JN90)
      DATA WWLTX  /  0.068D0, 0.075D0, 0.114D0, 0.179D0, 0.155D0, 0.175D0, 0.218D0,    &
                    0.250D0, 0.219D0, 0.283D0, 0.286D0, 0.286D0, 0.286D0, 0.286D0, 0.286D0, 0.286D0 /!
    g_fbet = g_fass
    fbet = fass
    falph = rg/1370.0D0
!--TEXTURE FACTOR NORMALIZED BY LOAM (IST=5)
! scale by aerodynamic resistance
    g_fra = -(ramin*g_ra/ra**2)
    fra = ramin/ra
    g_ftext = tassi*(wwlt+wfc)*g_fra/(wwltx(5)+wfcx(5))
    ftext = tassi*(wwlt+wfc)/(wwltx(5)+wfcx(5))*fra
!        write(6,*) ' ftot, fbet=',ftot, fbet,' ftext=',ftext/tassi
!
    g_alph1 = a1max*falph*((1.0D0-vegfrc)*g_ftext-g_vegfrc*ftext)
    alph1 = a1max*falph*(1.0D0-vegfrc)*ftext
    g_alph2 = a2max*falph*((1.0D0-vegfrc)*g_ftext-g_vegfrc*ftext)
    alph2 = a2max*falph*(1.0D0-vegfrc)*ftext
    g_bet1 = b1max*((g_fbet*vegfrc+fbet*g_vegfrc)*ftext+fbet*vegfrc*&
&      g_ftext)
    bet1 = b1max*fbet*vegfrc*ftext
    g_bet2 = b2max*((g_fbet*vegfrc+fbet*g_vegfrc)*ftext+fbet*vegfrc*&
&      g_ftext)
    bet2 = b2max*fbet*vegfrc*ftext
    IF (1.0D0 - 5.0D0*falph .LT. 0.0) THEN
      max2 = 0.0D0
    ELSE
      max2 = 1.0D0 - 5.0D0*falph
    END IF
! T2 Nudging at night
    t2nudf = 1.0d-5*max2
  END SUBROUTINE G_SMASS
!------------------------------------------------------------------------------------------
!------------------------------------------------------------------------------------------

!  Differentiation of soilprop in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: w2
!   with respect to varying inputs: w2
!------------------------------------------------------------------------------------------
!------------------------------------------------------------------------------------------
!------------------------------------------------------------------------------------------
!------------------------------------------------------------------------------------------
! IN
! IN
! OUT
  SUBROUTINE G_SOILPROP(soilcbot, weight, itimestep, mavail, &
&    pxlsm_smois_init, fwsat, fwfc, fwwlt, fb, fcgsat, fjp, fas, fc2r, &
&    fc1sat, isti, w2, g_w2)
    IMPLICIT NONE
!.........Arguments
! max. soil types
    INTEGER, PARAMETER :: nscat=16
! min soil types
    INTEGER, PARAMETER :: nscatmin=16
    INTEGER, INTENT(IN) :: weight, itimestep, pxlsm_smois_init
    REAL, INTENT(IN) :: mavail
    REAL, DIMENSION(nscat), INTENT(IN) :: soilcbot
    REAL, INTENT(OUT) :: fwsat, fwfc, fwwlt, fb, fcgsat, fjp, fas, fc2r&
&    , fc1sat
    REAL, INTENT(INOUT) :: w2
    REAL, INTENT(INOUT) :: g_w2
    INTEGER, INTENT(OUT) :: isti
!........Local variables
    CHARACTER(len=4) :: avclass
    CHARACTER(len=4), DIMENSION(nscat) :: texid
!... Integer
    INTEGER :: s
!... Real
    REAL :: tfracbot, cfrac, sumsnd, sumcly, avs, avc, avslt
    REAL, DIMENSION(nscat) :: wsat, wfc, wwlt, b, cgsat, as, jp, c2r, &
&    c1sat
    REAL, DIMENSION(nscatmin) :: sand, clay
!.......... DATA statement for SOIL PARAMETERS for the 11 soil types
      DATA SAND /92.5D0,80.5D0,61.1D0,19.6D0,4.0D0,40.0D0,57.1D0,11.3D0,26.8D0,       &
                 52.0D0,6.5D0,10.2D0,1.0D0,1.0D0,1.0D0,1.0D0/                                                  
      DATA CLAY/2.1D0,4.1D0,10.9D0,19.1D0,7.3D0,18.8D0,23.3D0,32.2D0,36.6D0,          &
                43.0D0,46.2D0,58.8D0,1.0D0,1.0D0,1.0D0,1.0D0/                                                 
      DATA TEXID/'Sand','Lsan','Sloa','Sill','Silt','Loam','Sclo',  &             
                 'Sicl','Cllo','Sacl','Sicy','Clay','Ormt','Wate',  &           
                 'Bedr','Othe'/

!
!-- WSAT is saturated soil moisture (M^3/M^3) (JN90)
      DATA WSAT  /  0.395D0, 0.410D0, 0.435D0, 0.485D0, 0.451D0, 0.420D0, 0.477D0,    &
                    0.476D0, 0.426D0, 0.482D0, 0.482D0, 0.482D0, 0.482D0, 0.482D0, 0.482D0, 0.482D0 /
!
!-- WFC is field capacity (M^3/M^3) (JN90)
      DATA WFC   /  0.135D0, 0.150D0, 0.195D0, 0.255D0, 0.240D0, 0.255D0, 0.322D0,    &
                    0.325D0, 0.310D0, 0.370D0, 0.367D0, 0.367D0, 0.367D0, 0.367D0, 0.367D0, 0.367D0 /
!
!-- WWLT is wilting point (M^3/M^3) (JN90)
      DATA WWLT  /  0.068D0, 0.075D0, 0.114D0, 0.179D0, 0.155D0, 0.175D0, 0.218D0,    &
                    0.250D0, 0.219D0, 0.283D0, 0.286D0, 0.286D0, 0.286D0, 0.286D0, 0.286D0, 0.286D0 /
!
!-- B is slop of the retention curve (NP89)
      DATA B     /  4.05D0,  4.38D0,  4.90D0,  5.30D0,  5.39D0,  7.12D0,  7.75D0,     &
                    8.52D0, 10.40D0, 10.40D0, 11.40D0, 11.40D0, 11.40D0, 11.40D0, 11.40D0, 11.40D0  /
!
!-- CGSAT is soil thermal coef. at saturation (10^-6 K M^2 J^-1) (NP89)
      DATA CGSAT /  3.222D0, 3.057D0, 3.560D0, 4.418D0, 4.111D0, 3.670D0, 3.593D0,    &
                    3.995D0, 3.058D0, 3.729D0, 3.600D0, 3.600D0, 3.600D0, 3.600D0, 3.600D0, 3.600D0 /
!
!-- JP is coefficient of WGEQ formulation (NP89)
      DATA JP    /  4,     4,     4,     6,     6,     6,     8,        &
                   10,     8,    10,    12,    12,    12,    12,    12,    12     /
!
!-- AS is coefficient of WGEQ formulation (NP89)
      DATA AS    /  0.387D0, 0.404D0, 0.219D0, 0.105D0, 0.148D0, 0.135D0, 0.127D0,    &
                    0.084D0, 0.139D0, 0.075D0, 0.083D0, 0.083D0, 0.083D0, 0.083D0, 0.083D0, 0.083D0 /
!
!-- C2R is the value of C2 for W2=0.5WSAT (NP89)
      DATA C2R   /  3.9D0,   3.7D0,   1.8D0,   0.8D0,   0.8D0,   0.8D0,   0.4D0,      &
                    0.6D0,   0.3D0,   0.3D0,   0.3D0,   0.3D0,   0.3D0,   0.3D0,   0.3D0,   0.3D0   /
!
!-- C1SAT is the value of C1 at saturation (NP89)
      DATA C1SAT /  0.082D0, 0.098D0, 0.132D0, 0.153D0, 0.191D0, 0.213D0, 0.385D0,    &
                    0.227D0, 0.421D0, 0.375D0, 0.342D0, 0.342D0, 0.342D0, 0.342D0, 0.342D0, 0.342D0 /
!   
!-------------------------------Exicutable starts here--------------------
    IF (weight .GE. 1) THEN
!Compute soil characteristics using weighting determined by fractional soil content
      fwsat = 0.D0
      fwfc = 0.D0
      fwwlt = 0.D0
      fb = 0.D0
      fcgsat = 0.D0
      fjp = 0.D0
      fas = 0.D0
      fc2r = 0.D0
      fc1sat = 0.D0
      tfracbot = 0.D0
      cfrac = 0.D0
      DO s=1,nscat
        IF (soilcbot(s) .GE. cfrac) THEN
          isti = s
          cfrac = soilcbot(s)
        END IF
        tfracbot = tfracbot + soilcbot(s)
        fwsat = fwsat + wsat(s)*soilcbot(s)
        fwfc = fwfc + wfc(s)*soilcbot(s)
        fwwlt = fwwlt + wwlt(s)*soilcbot(s)
        fb = fb + b(s)*soilcbot(s)
        fcgsat = fcgsat + cgsat(s)*soilcbot(s)
        fjp = fjp + jp(s)*soilcbot(s)
        fas = fas + as(s)*soilcbot(s)
        fc2r = fc2r + c2r(s)*soilcbot(s)
        fc1sat = fc1sat + c1sat(s)*soilcbot(s)
      END DO
      tfracbot = 1.D0/tfracbot
      fwsat = fwsat*tfracbot
      fwfc = fwfc*tfracbot
      fwwlt = fwwlt*tfracbot
      fb = fb*tfracbot
      fcgsat = fcgsat*tfracbot
      fjp = fjp*tfracbot
      fas = fas*tfracbot
      fc2r = fc2r*tfracbot
      fc1sat = fc1sat*tfracbot
    ELSE
!Compute soil characteristics by sand and clay fraction
      cfrac = 0.0D0
      sumsnd = 0.0D0
      sumcly = 0.0D0
      tfracbot = 0.0D0
      DO s=1,12
        tfracbot = tfracbot + soilcbot(s)
        sumsnd = sumsnd + sand(s)*soilcbot(s)
        sumcly = sumcly + clay(s)*soilcbot(s)
        IF (soilcbot(s) .GE. cfrac) THEN
! Find Dominant Category and fraction
          isti = s
          cfrac = soilcbot(s)
        END IF
      END DO
      IF (tfracbot .GT. 0.001) THEN
        avs = sumsnd/tfracbot
        avc = sumcly/tfracbot
        avslt = 100.D0 - avs - avc
        IF (avs .GT. 85. + 0.5*avc) THEN
          avclass = 'Sand'
          isti = 1
        ELSE IF (avs .GT. 70. + avc) THEN
          avclass = 'Lsan'
          isti = 2
        ELSE IF ((avc .LT. 20. .AND. avs .GT. 52.) .OR. (avc .LE. 7.5 &
&            .AND. avslt .LT. 50.)) THEN
          avclass = 'Sloa'
          isti = 3
        ELSE IF (avc .LT. 35. .AND. avs .GT. 45. .AND. avslt .LT. 28.) &
&        THEN
          avclass = 'Sclo'
          isti = 6
        ELSE IF (avc .GE. 35. .AND. avs .GT. 45.) THEN
          avclass = 'Sacl'
          isti = 9
        ELSE IF (avc .LT. 27.0 .AND. avslt .LT. 50.) THEN
          avclass = 'Loam'
          isti = 5
        ELSE IF (avc .LT. 12. .AND. avslt .GT. 80.) THEN
          avclass = 'Silt'
          isti = 4
        ELSE IF (avc .LT. 27.) THEN
          avclass = 'Sill'
          isti = 4
        ELSE IF (avc .LT. 40. .AND. avs .GT. 20.) THEN
          avclass = 'Cllo'
          isti = 8
        ELSE IF (avc .LT. 40.) THEN
          avclass = 'Sicl'
          isti = 7
        ELSE IF (avslt .GE. 40.) THEN
          avclass = 'Sicy'
          isti = 10
        ELSE
          avclass = 'Clay'
          isti = 11
        END IF
      ELSE
        isti = 5
        avclass = texid(isti)
      END IF
      fwsat = wsat(isti)
      fwfc = wfc(isti)
      fwwlt = wwlt(isti)
      fb = b(isti)
      fcgsat = cgsat(isti)
      fjp = jp(isti)
      fas = as(isti)
      fc2r = c2r(isti)
      fc1sat = c1sat(isti)
    END IF
! Compute W2 using soil moisture availiability if pxlsm_smois_init (in namelist) is not zero
    IF (itimestep .EQ. 1 .AND. pxlsm_smois_init .GT. 0) THEN
      w2 = fwwlt + (0.5D0*(fwsat+fwfc)-fwwlt)*mavail
      g_w2 = 0.0_8
    END IF
  END SUBROUTINE G_SOILPROP
!------------------------------------------------------------------------------------------
!------------------------------------------------------------------------------------------
END MODULE G_MODULE_SF_PXLSM
