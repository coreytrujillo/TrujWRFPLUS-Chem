!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.6 (r4756) - 12 Feb 2013 10:43
!
!WRF:MODEL_LAYER:PHYSICS
!
MODULE A_MODULE_SF_PXSFCLAY
  IMPLICIT NONE
!-------------------------------------------------------------------          
!critical Richardson number
  REAL, PARAMETER :: ricrit=0.25D0
! 8.21
  REAL, PARAMETER :: betah=5.0D0
! 6.0
  REAL, PARAMETER :: betam=5.0D0
  REAL, PARAMETER :: bm=13.0D0
  REAL, PARAMETER :: bh=15.7D0
  REAL, PARAMETER :: gamam=19.3D0
  REAL, PARAMETER :: gamah=11.6D0
  REAL, PARAMETER :: pr0=0.95D0
  REAL, PARAMETER :: czo=0.032D0
  REAL, PARAMETER :: ozo=1.d-4
  REAL, PARAMETER :: vconvc=1.0D0

CONTAINS
!  Differentiation of pxsfclay in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: wspd ust u3d cpm pblh hfx br
!                t3d qsfc qv3d psih znt psfc psim rmol flqc qfx
!                chs gz1oz0 v3d th3d zol flhc dz8w mol
!   with respect to varying inputs: wspd ust u3d cpm pblh hfx br
!                t3d qsfc qv3d psih znt psfc psim rmol flqc qfx
!                chs gz1oz0 v3d th3d zol flhc dz8w mol
!-------------------------------------------------------------------
  SUBROUTINE A_PXSFCLAY(u3d, a_u3d, v3d, a_v3d, t3d, a_t3d, th3d, a_th3d&
&    , qv3d, a_qv3d, p3d, dz8w, a_dz8w, cp, g, rovcp, r, xlv, psfc, &
&    a_psfc, chs, a_chs, chs2, cqs2, cpm, a_cpm, znt, a_znt, ust, a_ust, &
&    pblh, a_pblh, mavail, zol, a_zol, mol, a_mol, regime, psim, a_psim, &
&    psih, a_psih, xland, hfx, a_hfx, qfx, a_qfx, lh, tsk, flhc, a_flhc, &
&    flqc, a_flqc, qgh, qsfc, a_qsfc, rmol, a_rmol, u10, v10, gz1oz0, &
&    a_gz1oz0, wspd, a_wspd, br, a_br, isfflx, dx, svp1, svp2, svp3, &
&    svpt0, ep1, ep2, karman, ids, ide, jds, jde, kds, kde, ims, ime, jms&
&    , jme, kms, kme, its, ite, jts, jte, kts, kte)
    IMPLICIT NONE
!-------------------------------------------------------------------
!   THIS MODULE COMPUTES SFC RELATED PARAMETERS (U*, RA, REGIME, etc.)
!   USING A MODIFIED RICHARDSON NUMBER PARAMETERIZATIONS.
!
!   THE PARAMETERIZATIONS OF THE PSI FUNCTIONS FOR UNSTABLE CONDITIONS
!   HAVE BEEN REPLACED WITH EMPIRICAL EXPRESSIONS WHICH RELATE RB DIRECTLY
!   TO PSIH AND PSIM.  THESE EXPRESSIONS ARE FIT TO THE DYER (1974) FUNCTIONS
!   WITH HOGSTROM (1988) REVISED COEFFICIENTS.  ALSO, THESE EXPERESSIONS
!   ASSUME A LAMINAR SUBLAYER RESISTANCE FOR HEAT (Rb = 5/U*)   - JP 8/01
! 
!   Reference: Pleim (2006): JAMC, 45, 341-347
!
!  REVISION HISTORY:
!     A. Xiu        2/2005 - developed WRF version based on the MM5 PX LSM
!     R. Gilliam    7/2006 - completed implementation into WRF model
!*********************************************************************** 
!-------------------------------------------------------------------
!-- U3D         3D u-velocity interpolated to theta points (m/s)
!-- V3D         3D v-velocity interpolated to theta points (m/s)
!-- T3D         temperature (K)
!-- TH3D        potential temperature (K)
!-- QV3D        3D water vapor mixing ratio (Kg/Kg)
!-- P3D         3D pressure (Pa)
!-- dz8w        dz between full levels (m)
!-- CP          heat capacity at constant pressure for dry air (J/kg/K)
!-- G           acceleration due to gravity (m/s^2)
!-- ROVCP       R/CP
!-- R           gas constant for dry air (j/kg/k)
!-- XLV         latent heat of vaporization (j/kg)
!-- PSFC        surface pressure (Pa)
!-- CHS         exchange coefficient for heat (m/s)
!-- CHS2        exchange coefficient for heat at 2 m (m/s)
!-- CQS2        exchange coefficient for moisture at 2 m (m/s)
!-- CPM         heat capacity at constant pressure for moist air (J/kg/K)
!-- ZNT         roughness length (m)
!-- UST         u* in similarity theory (m/s)
!-- PBLH        PBL height from previous time (m)
!-- MAVAIL      surface moisture availability (between 0 and 1)
!-- ZOL         z/L height over Monin-Obukhov length
!-- MOL         T* (similarity theory) (K)
!-- REGIME      flag indicating PBL regime (stable, unstable, etc.)
!-- PSIM        similarity stability function for momentum
!-- PSIH        similarity stability function for heat
!-- XLAND       land mask (1 for land, 2 for water)
!-- HFX         upward heat flux at the surface (W/m^2)
!-- QFX         upward moisture flux at the surface (kg/m^2/s)
!-- LH          net upward latent heat flux at surface (W/m^2)
!-- TSK         surface temperature (K)
!-- FLHC        exchange coefficient for heat (m/s)
!-- FLQC        exchange coefficient for moisture (m/s)
!-- QGH         lowest-level saturated mixing ratio
!-- QSFC        SPECIFIC HUMIDITY AT LOWER BOUNDARY				
!-- RMOL        inverse Monin-Obukhov length (1/m)
!-- U10         diagnostic 10m u wind
!-- V10         diagnostic 10m v wind
!-- GZ1OZ0      log(z/z0) where z0 is roughness length
!-- WSPD        wind speed at lowest model level (m/s)
!-- BR          bulk Richardson number in surface layer
!-- ISFFLX      isfflx=1 for surface heat and moisture fluxes
!-- DX          horizontal grid size (m)
!-- SVP1        constant for saturation vapor pressure (kPa)
!-- SVP2        constant for saturation vapor pressure (dimensionless)
!-- SVP3        constant for saturation vapor pressure (K)
!-- SVPT0       constant for saturation vapor pressure (K)
!-- EP1         constant for virtual temperature (R_v/R_d - 1) (dimensionless)
!-- EP2         constant for specific humidity calculation 
!               (R_d/R_v) (dimensionless)
!-- KARMAN      Von Karman constant
!-- ids         start index for i in domain
!-- ide         end index for i in domain
!-- jds         start index for j in domain
!-- jde         end index for j in domain
!-- kds         start index for k in domain
!-- kde         end index for k in domain
!-- ims         start index for i in memory
!-- ime         end index for i in memory
!-- jms         start index for j in memory
!-- jme         end index for j in memory
!-- kms         start index for k in memory
!-- kme         end index for k in memory
!-- its         start index for i in tile
!-- ite         end index for i in tile
!-- jts         start index for j in tile
!-- jte         end index for j in tile
!-- kts         start index for k in tile
!-- kte         end index for k in tile
!-------------------------------------------------------------------
    INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, its, ite, jts, jte, kts, kte
!                                                               
    INTEGER, INTENT(IN) :: isfflx
    REAL, INTENT(IN) :: svp1, svp2, svp3, svpt0
    REAL, INTENT(IN) :: ep1, ep2, karman
!
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: dz8w
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_dz8w
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: qv3d, p3d&
&    , t3d, th3d
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_qv3d, a_t3d, a_th3d
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: mavail, pblh, xland&
&    , tsk
    REAL, DIMENSION(ims:ime, jms:jme) :: a_pblh
    REAL, DIMENSION(ims:ime, jms:jme) :: u10, v10, qsfc
    REAL, DIMENSION(ims:ime, jms:jme) :: a_qsfc
!
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: regime, hfx, qfx&
&    , lh, mol, rmol
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_hfx
!m the following 5 are change to memory size
!
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: gz1oz0, wspd, br&
&    , psim, psih
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_gz1oz0
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: u3d, v3d
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: a_u3d, a_v3d
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: psfc
    REAL, DIMENSION(ims:ime, jms:jme) :: a_psfc
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: znt, zol, ust, &
&    cpm, chs2, cqs2, chs
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_znt
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: flhc, flqc
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_flhc
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: qgh
    REAL, INTENT(IN) :: cp, g, rovcp, r, xlv, dx
! LOCAL VARS
    REAL, DIMENSION(its:ite) :: u1d, v1d, qv1d, p1d, t1d, th1d
    REAL, DIMENSION(its:ite) :: a_u1d, a_v1d, a_qv1d, a_t1d, a_th1d
    REAL, DIMENSION(its:ite) :: dz8w1d
    REAL, DIMENSION(its:ite) :: a_dz8w1d
    INTEGER :: i, j
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_ust
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_cpm
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_psih
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_psim
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_flqc
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_rmol
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_qfx
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_chs
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_wspd
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_zol
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_br
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: a_mol

    a_qv1d = 0.0_8
    a_v1d = 0.0_8
    a_th1d = 0.0_8
    a_dz8w1d = 0.0_8
    a_u1d = 0.0_8
    a_t1d = 0.0_8
    DO j=jte,jts,-1
      DO i=ite,its,-1
        dz8w1d(i) = dz8w(i, 1, j)
        u1d(i) = u3d(i, 1, j)
        v1d(i) = v3d(i, 1, j)
        qv1d(i) = qv3d(i, 1, j)
        p1d(i) = p3d(i, 1, j)
        t1d(i) = t3d(i, 1, j)
        th1d(i) = th3d(i, 1, j)
      END DO
      CALL A_PXSFCLAY1D(j, u1d, a_u1d, v1d, a_v1d, t1d, a_t1d, th1d, &
&                  a_th1d, qv1d, a_qv1d, p1d, dz8w1d, a_dz8w1d, cp, g, &
&                  rovcp, r, xlv, psfc(ims, j), a_psfc(ims, j), chs(ims, j), &
&                  a_chs(ims, j), chs2(ims, j), cqs2(ims, j), cpm(ims, j), a_cpm(&
&                  ims, j), pblh(ims, j), a_pblh(ims, j), rmol(ims, j), a_rmol(ims&
&                  , j), znt(ims, j), a_znt(ims, j), ust(ims, j), a_ust(ims, j), &
&                  mavail(ims, j), zol(ims, j), a_zol(ims, j), mol(ims, j), a_mol&
&                  (ims, j), regime(ims, j), psim(ims, j), a_psim(ims, j), psih(ims&
&                  , j), a_psih(ims, j), xland(ims, j), hfx(ims, j), a_hfx(ims, j&
&                  ), qfx(ims, j), a_qfx(ims, j), tsk(ims, j), u10(ims, j), v10(ims&
&                  , j), flhc(ims, j), a_flhc(ims, j), flqc(ims, j), a_flqc(ims, &
&                  j), qgh(ims, j), qsfc(ims, j), a_qsfc(ims, j), lh(ims, j), &
&                  gz1oz0(ims, j), a_gz1oz0(ims, j), wspd(ims, j), a_wspd(ims, j)&
&                  , br(ims, j), a_br(ims, j), isfflx, dx, svp1, svp2, svp3, &
&                  svpt0, ep1, ep2, karman, ids, ide, jds, jde, kds, kde&
&                  , ims, ime, jms, jme, kms, kme, its, ite, jts, jte, &
&                  kts, kte)
      DO i=ite,its,-1
        a_th3d(i, 1, j) = a_th3d(i, 1, j) + a_th1d(i)
        a_th1d(i) = 0.0_8
        a_t3d(i, 1, j) = a_t3d(i, 1, j) + a_t1d(i)
        a_t1d(i) = 0.0_8
        a_qv3d(i, 1, j) = a_qv3d(i, 1, j) + a_qv1d(i)
        a_qv1d(i) = 0.0_8
        a_v3d(i, 1, j) = a_v3d(i, 1, j) + a_v1d(i)
        a_v1d(i) = 0.0_8
        a_u3d(i, 1, j) = a_u3d(i, 1, j) + a_u1d(i)
        a_u1d(i) = 0.0_8
        a_dz8w(i, 1, j) = a_dz8w(i, 1, j) + a_dz8w1d(i)
        a_dz8w1d(i) = 0.0_8
      END DO
    END DO
  END SUBROUTINE A_PXSFCLAY
!-------------------------------------------------------------------

!  Differentiation of pxsfclay1d in reverse (adjoint) mode (with options r8 noISIZE):
!   gradient     of useful results: qv1d wspd ust cpm psfcpa pblh
!                hfx theta1 dz8w1d us br qsfc psih znt psim flqc
!                rmol vs qfx chs gz1oz0 zol flhc t1d mol
!   with respect to varying inputs: qv1d wspd ust cpm psfcpa pblh
!                hfx theta1 dz8w1d us br qsfc psih znt psim flqc
!                rmol vs qfx chs gz1oz0 zol flhc t1d mol
!====================================================================
  SUBROUTINE A_PXSFCLAY1D(j, us, a_us, vs, a_vs, t1d, a_t1d, theta1, &
&    a_theta1, qv1d, a_qv1d, p1d, dz8w1d, a_dz8w1d, cp, g, rovcp, r, xlv&
&    , psfcpa, a_psfcpa, chs, a_chs, chs2, cqs2, cpm, a_cpm, pblh, a_pblh&
&    , rmol, a_rmol, znt, a_znt, ust, a_ust, mavail, zol, a_zol, mol, &
&    a_mol, regime, psim, a_psim, psih, a_psih, xland, hfx, a_hfx, qfx, &
&    a_qfx, tg, u10, v10, flhc, a_flhc, flqc, a_flqc, qgh, qsfc, a_qsfc, &
&    lh, gz1oz0, a_gz1oz0, wspd, a_wspd, br, a_br, isfflx, dx, svp1, svp2&
&    , svp3, svpt0, ep1, ep2, karman, ids, ide, jds, jde, kds, kde, ims, &
&    ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte)
    IMPLICIT NONE
!-------------------------------------------------------------------
    REAL, PARAMETER :: xka=2.4e-5
    REAL, PARAMETER :: prt=1.
    INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, its, ite, jts, jte, kts, kte, j
!                                                               
    INTEGER, INTENT(IN) :: isfflx
    REAL, INTENT(IN) :: svp1, svp2, svp3, svpt0
    REAL, INTENT(IN) :: ep1, ep2, karman
!
    REAL, DIMENSION(ims:ime), INTENT(IN) :: mavail, pblh, xland, tg
    REAL, DIMENSION(ims:ime) :: a_pblh
!
    REAL, DIMENSION(ims:ime), INTENT(IN) :: psfcpa
    REAL, DIMENSION(ims:ime) :: a_psfcpa
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: regime, hfx, qfx, mol, &
&    rmol
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_hfx
!m the following 5 are changed to memory size---
!
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: gz1oz0, wspd, br, psim, &
&    psih
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_gz1oz0
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: znt, zol, ust, cpm, chs2&
&    , cqs2, chs
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_znt
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: flhc, flqc
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_flhc
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: qgh
    REAL, DIMENSION(ims:ime) :: u10, v10, qsfc, lh
    REAL, DIMENSION(ims:ime) :: a_qsfc
    REAL, INTENT(IN) :: cp, g, rovcp, xlv, dx, r
! MODULE-LOCAL VARIABLES, DEFINED IN SUBROUTINE SFCLAY
    REAL, DIMENSION(its:ite), INTENT(IN) :: dz8w1d
    REAL, DIMENSION(its:ite) :: a_dz8w1d
    REAL, DIMENSION(its:ite), INTENT(IN) :: us, vs, qv1d, p1d, t1d, &
&    theta1
    REAL, DIMENSION(its:ite) :: a_us, a_vs, a_qv1d, a_t1d, a_theta1
! LOCAL VARS
    REAL, DIMENSION(its:ite) :: za, th0, thetag, ws, ricut, ustm, ra, &
&    thetav1, molength
    REAL, DIMENSION(its:ite) :: a_za, a_th0, a_thetag, a_ws, a_ricut, &
&    a_ustm, a_ra, a_thetav1, a_molength
!
    REAL, DIMENSION(its:ite) :: rhox, govrth
    REAL, DIMENSION(its:ite) :: a_rhox, a_govrth
!
    REAL, DIMENSION(its:ite) :: psfc
    REAL, DIMENSION(its:ite) :: a_psfc
!
    INTEGER :: kl
    INTEGER :: n, i, k, kk, l, nzol, nk, nzol2, nzol10
    REAL :: pl, thcon, tvcon, e1
    REAL :: a_tvcon
    REAL :: zl, tskv, dthvdz, dthvm, vconv, rzol, rzol2, rzol10, zol2, &
&    zol10
    REAL :: a_dthvdz, a_vconv
    REAL :: dtg, psix, dtthx, psix10, psit, psit2, psiq, psiq2
    REAL :: a_dtg, a_psix
    REAL :: fluxc, vsgd
    REAL :: a_fluxc
    REAL :: xmol, zobol, z10ol, zntol, ynt, yob, x1, x2
    REAL :: a_xmol
    REAL :: g2oz0, g10oz0, ra2, zoll
    REAL :: a_zoll
    REAL :: tv0, cpot, ricriti, am, ah, sqlnzz0, rbh, rbw, tstv
    REAL :: a_tv0, a_cpot, a_am, a_ah, a_sqlnzz0, a_rbh, a_rbw, a_tstv
    REAL :: psih2, psim2, psih10, psim10, cqs
    REAL :: a_cqs
    INTEGER :: branch
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_ust
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_cpm
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_psih
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_psim
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_rmol
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_flqc
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_qfx
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_chs
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_wspd
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_zol
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_br
    REAL, DIMENSION(ims:ime), INTENT(INOUT) :: a_mol
    REAL :: temp3
    REAL :: temp2
    REAL :: temp1
    REAL :: temp0
    REAL :: temp2b0
    REAL :: a_x3
    REAL :: temp2b
    REAL :: x3
    REAL :: temp3b
    REAL :: temp11
    REAL :: temp10
    REAL :: temp10b4
    REAL :: temp10b3
    REAL :: temp5b
    REAL :: temp10b2
    REAL :: temp10b1
    REAL :: temp10b0
    REAL :: temp9b0
    REAL :: temp6b
    REAL :: temp7b
    REAL :: tempb
    REAL :: temp10b
    REAL :: temp8b
    REAL :: temp3b3
    REAL :: abs0
    REAL :: temp3b2
    REAL :: temp3b1
    REAL :: temp3b0
    REAL :: temp11b
    REAL :: temp9b
    REAL :: temp
    REAL :: max2
    REAL :: temp9
    REAL :: temp8
    REAL :: temp7
    REAL :: temp6
    REAL :: temp5
    REAL :: temp4
!-------------------------------Exicutable starts here-------------------- 
    DO i=its,ite
! PSFC cb
      psfc(i) = psfcpa(i)/1000.D0
      tvcon = 1.0D0 + ep1*qv1d(i)
      thetav1(i) = theta1(i)*tvcon
      rhox(i) = psfcpa(i)/(r*t1d(i)*tvcon)
    END DO
!
!-----Compute virtual potential temperature at surface
!
    DO i=its,ite
      CALL PUSHREAL8(e1)
      e1 = svp1*EXP(svp2*(tg(i)-svpt0)/(tg(i)-svp3))
      qsfc(i) = ep2*e1/(psfc(i)-e1)
! QGH CHANGED TO USE LOWEST-LEVEL AIR TEMP CONSISTENT WITH MYJSFC CHANGE
! Q2SAT = QGH IN LSM
      cpm(i) = cp*(1.D0+0.8D0*qv1d(i))
    END DO
!.......... compute the thetav at ground
    DO i=its,ite
      tv0 = tg(i)*(1.0D0+ep1*qsfc(i)*mavail(i))
      cpot = (100.D0/psfc(i))**rovcp
      th0(i) = tv0*(100.D0/psfc(i))**rovcp
      thetag(i) = cpot*tg(i)
    END DO
!                                                                                
!-----COMPUTE THE HEIGHT OF FULL- AND HALF-SIGMA LEVELS ABOVE GROUND             
!     LEVEL, AND THE LAYER THICKNESSES.                                          
!                                                                                
!... DZ8W1D is DZ between full sigma levels and Z0 is the height of the first 
!    half sigma level
    DO i=its,ite
      za(i) = 0.5D0*dz8w1d(i)
      ws(i) = SQRT(us(i)*us(i) + vs(i)*vs(i))
    END DO
!
!-----CALCULATE BULK RICHARDSON NO. OF SURFACE LAYER, ACCORDING TO
!     AKB(1976), EQ(12).
    ricriti = 1.0D0/ricrit
    DO i=its,ite
      gz1oz0(i) = ALOG(za(i)/znt(i))
      dthvdz = thetav1(i) - th0(i)
      x3 = hfx(i)/rhox(i)/cp + ep1*th0(i)*qfx(i)/rhox(i)
      IF (x3 .LT. 0.D0) THEN
        CALL PUSHREAL8(fluxc)
        fluxc = 0.D0
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHREAL8(fluxc)
        fluxc = x3
        CALL PUSHCONTROL1B(1)
      END IF
      vconv = vconvc*(g/tg(i)*pblh(i)*fluxc)**.33D0
      IF (dx/5000.D0 - 1.D0 .LT. 0.) THEN
        max2 = 0.D0
      ELSE
        max2 = dx/5000.D0 - 1.D0
      END IF
      CALL PUSHREAL8(vsgd)
      vsgd = 0.32D0*max2**.33D0
      wspd(i) = SQRT(ws(i)*ws(i) + vconv*vconv + vsgd*vsgd)
      IF (wspd(i) .LT. 0.1) THEN
        wspd(i) = 0.1D0
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
        wspd(i) = wspd(i)
      END IF
      govrth(i) = g/theta1(i)
      br(i) = govrth(i)*za(i)*dthvdz/(wspd(i)*wspd(i))
      ricut(i) = 1.0D0/(ricriti+gz1oz0(i))
    END DO
    DO i=its,ite
!       -- NOTE THAT THE REGIMES USED IN HIRPBL HAVE BEEN CHANGED:
      IF (br(i) .GE. ricut(i)) THEN
!           -----CLASS 1; VERY STABLE CONDITIONS:  Z/L > 1
        zoll = br(i)*gz1oz0(i)/(1.0D0-ricriti*ricut(i))
        psim(i) = 1.0D0 - betam - zoll
        psih(i) = 1.0D0 - betah - zoll
        CALL PUSHCONTROL2B(2)
      ELSE IF (br(i) .GE. 0.0) THEN
!           -----CLASS 2; STABLE: for 1 > Z/L >0
        zoll = br(i)*gz1oz0(i)/(1.0D0-ricriti*br(i))
        psim(i) = -(betam*zoll)
        psih(i) = -(betah*zoll)
        CALL PUSHCONTROL2B(1)
      ELSE
        CALL PUSHREAL8(am)
!        ----- CLASS 3 or 4; UNSTABLE:
!        ----- CLASS 4 IS FOR ACM NON-LOCAL CONVECTION (H/L < -3)
! Regime will be reset to 4 if ACM is used
        am = 0.031D0 + 0.276D0*ALOG(gz1oz0(i))
        CALL PUSHREAL8(ah)
        ah = 0.04D0 + 0.355D0*ALOG(gz1oz0(i))
        CALL PUSHREAL8(sqlnzz0)
        sqlnzz0 = SQRT(gz1oz0(i))
        psim(i) = am*ALOG(1.0D0-bm*sqlnzz0*br(i))
        psih(i) = ah*ALOG(1.0D0-bh*sqlnzz0*br(i))
        CALL PUSHCONTROL2B(0)
      END IF
    END DO
!
!     -------- COMPUTE THE FRICTIONAL VELOCITY AND SURFACE FLUXES:
    DO i=its,ite
      CALL PUSHREAL8(dtg)
      dtg = theta1(i) - thetag(i)
      psix = gz1oz0(i) - psim(i)
      ust(i) = 0.5D0*ust(i) + 0.5D0*karman*wspd(i)/psix
      ustm(i) = ust(i)
!      ------- OVER WATER, ALTER ROUGHNESS LENGTH (Z0) ACCORDING TO WIND (UST).
!
      IF (xland(i) - 1.5D0 .GE. 0.0) THEN
        CALL PUSHREAL8(znt(i))
        znt(i) = czo*ustm(i)*ustm(i)/g + ozo
        CALL PUSHREAL8(gz1oz0(i))
        gz1oz0(i) = ALOG(za(i)/znt(i))
        psix = gz1oz0(i) - psim(i)
        ust(i) = karman*wspd(i)/psix
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      ra(i) = pr0*(gz1oz0(i)-psih(i))/(karman*ust(i))
! 5/U*  ! WESELY AND HICKS (1977)
      rbh = 5.0D0/ust(i)
!       ------- RB FOR WATER VAPOR =  5*(0.599/0.709)^2/3 /UST = 4.47/UST    hi               
      rbw = 4.47D0/ust(i)
      chs(i) = 1.D0/(ra(i)+rbh)
      cqs = 1.D0/(ra(i)+rbw)
      CALL PUSHREAL8(tstv)
! This is really TST
      tstv = (thetav1(i)-th0(i))*chs(i)/ust(i)
      IF (tstv .GE. 0.) THEN
        abs0 = tstv
      ELSE
        abs0 = -tstv
      END IF
      IF (abs0 .LT. 1.e-5) THEN
        tstv = 1.d-5
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      molength(i) = thetav1(i)*ust(i)*ust(i)/(karman*g*tstv)
      CALL PUSHREAL8(xmol)
!
!       ---Compute 2m surface exchange coefficients for heat and moisture
      xmol = molength(i)
      IF (molength(i) .GT. 0.0) THEN
        IF (molength(i) .LT. 2.0) THEN
          CALL PUSHCONTROL2B(2)
          xmol = 2.0D0
        ELSE
          xmol = molength(i)
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
      rmol(i) = 1.D0/xmol
!       -----COMPUTE SURFACE HEAT AND MOIST FLUX:                                                
      flhc(i) = cpm(i)*rhox(i)*chs(i)
      flqc(i) = rhox(i)*cqs*mavail(i)
      CALL PUSHREAL8(qfx(i))
      qfx(i) = flqc(i)*(qsfc(i)-qv1d(i))
      IF (qfx(i) .LT. 0.) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (xland(i) - 1.5D0 .GT. 0.) THEN
        CALL PUSHCONTROL2B(3)
      ELSE IF (xland(i) - 1.5D0 .LT. 0.) THEN
        CALL PUSHREAL8(hfx(i))
        hfx(i) = -(flhc(i)*dtg)
        IF (hfx(i) .LT. -250.D0) THEN
          CALL PUSHCONTROL2B(1)
        ELSE
          CALL PUSHCONTROL2B(2)
        END IF
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
    END DO
    a_molength = 0.0_8
    a_thetav1 = 0.0_8
    a_ra = 0.0_8
    a_th0 = 0.0_8
    a_ustm = 0.0_8
    a_rhox = 0.0_8
    a_za = 0.0_8
    a_thetag = 0.0_8
    DO i=ite,its,-1
      CALL POPCONTROL2B(branch)
      IF (branch .LT. 2) THEN
        IF (branch .EQ. 0) THEN
          a_dtg = 0.0_8
          GOTO 100
        ELSE
          a_hfx(i) = 0.0_8
        END IF
      ELSE IF (branch .NE. 2) THEN
        dtg = theta1(i) - thetag(i)
        a_flhc(i) = a_flhc(i) - dtg*a_hfx(i)
        a_dtg = -(flhc(i)*a_hfx(i))
        a_hfx(i) = 0.0_8
        GOTO 100
      END IF
      dtg = theta1(i) - thetag(i)
      CALL POPREAL8(hfx(i))
      a_flhc(i) = a_flhc(i) - dtg*a_hfx(i)
      a_dtg = -(flhc(i)*a_hfx(i))
      a_hfx(i) = 0.0_8
 100  CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) a_qfx(i) = 0.0_8
      CALL POPREAL8(qfx(i))
      a_flqc(i) = a_flqc(i) + (qsfc(i)-qv1d(i))*a_qfx(i)
      a_qsfc(i) = a_qsfc(i) + flqc(i)*a_qfx(i)
      a_qv1d(i) = a_qv1d(i) - flqc(i)*a_qfx(i)
      a_qfx(i) = 0.0_8
      rbw = 4.47D0/ust(i)
      cqs = 1.D0/(ra(i)+rbw)
      a_rhox(i) = a_rhox(i) + chs(i)*cpm(i)*a_flhc(i) + mavail(i)*cqs*&
&        a_flqc(i)
      a_cqs = mavail(i)*rhox(i)*a_flqc(i)
      a_flqc(i) = 0.0_8
      a_cpm(i) = a_cpm(i) + chs(i)*rhox(i)*a_flhc(i)
      a_chs(i) = a_chs(i) + cpm(i)*rhox(i)*a_flhc(i)
      a_flhc(i) = 0.0_8
      a_za(i) = a_za(i) + rmol(i)*a_zol(i)
      a_rmol(i) = a_rmol(i) + za(i)*a_zol(i)
      a_zol(i) = 0.0_8
      a_xmol = -(a_rmol(i)/xmol**2)
      a_rmol(i) = 0.0_8
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .EQ. 1) a_molength(i) = a_molength(i) + a_xmol
        a_xmol = 0.0_8
      END IF
      CALL POPREAL8(xmol)
      a_molength(i) = a_molength(i) + a_xmol
      temp11 = karman*g*tstv
      temp11b = a_molength(i)/temp11
      a_thetav1(i) = a_thetav1(i) + ust(i)**2*temp11b
      a_ust(i) = a_ust(i) + thetav1(i)*2*ust(i)*temp11b
      a_tstv = -(thetav1(i)*ust(i)**2*karman*g*temp11b/temp11)
      a_molength(i) = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) a_tstv = 0.0_8
      temp10b1 = a_mol(i)/ust(i)
      CALL POPREAL8(tstv)
      temp10 = chs(i)/ust(i)
      temp10b0 = (thetav1(i)-th0(i))*a_tstv/ust(i)
      a_thetav1(i) = a_thetav1(i) + temp10*a_tstv
      a_th0(i) = a_th0(i) - temp10*a_tstv
      a_chs(i) = a_chs(i) + dtg*temp10b1 + temp10b0
      a_dtg = a_dtg + chs(i)*temp10b1
      a_mol(i) = 0.0_8
      temp10b3 = -(a_cqs/(ra(i)+rbw)**2)
      a_rbw = temp10b3
      rbh = 5.0D0/ust(i)
      temp10b4 = -(a_chs(i)/(ra(i)+rbh)**2)
      a_ra(i) = a_ra(i) + temp10b4 + temp10b3
      a_rbh = temp10b4
      a_chs(i) = 0.0_8
      temp10b2 = pr0*a_ra(i)/(karman*ust(i))
      a_ust(i) = a_ust(i) - dtg*chs(i)*temp10b1/ust(i) - 5.0D0*a_rbh/ust&
&        (i)**2 - (gz1oz0(i)-psih(i))*temp10b2/ust(i) - 4.47D0*a_rbw/ust(&
&        i)**2 - temp10*temp10b0
      a_gz1oz0(i) = a_gz1oz0(i) + temp10b2
      a_psih(i) = a_psih(i) - temp10b2
      a_ra(i) = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        a_ust(i) = a_ust(i) + a_ustm(i)
        psix = gz1oz0(i) - psim(i)
        temp10b = karman*a_ust(i)/psix
        a_wspd(i) = a_wspd(i) + temp10b
        a_psix = -(wspd(i)*temp10b/psix)
        a_ust(i) = 0.0_8
        a_gz1oz0(i) = a_gz1oz0(i) + a_psix
        a_psim(i) = a_psim(i) - a_psix
        CALL POPREAL8(gz1oz0(i))
        temp9 = za(i)/znt(i)
        temp9b0 = a_gz1oz0(i)/(temp9*znt(i))
        a_za(i) = a_za(i) + temp9b0
        a_znt(i) = a_znt(i) - temp9*temp9b0
        a_ustm(i) = czo*2*ustm(i)*a_znt(i)/g
        a_gz1oz0(i) = 0.0_8
        CALL POPREAL8(znt(i))
        a_znt(i) = 0.0_8
      END IF
      a_ust(i) = a_ust(i) + a_ustm(i)
      a_ustm(i) = 0.0_8
      psix = gz1oz0(i) - psim(i)
      temp9b = karman*0.5D0*a_ust(i)/psix
      a_wspd(i) = a_wspd(i) + temp9b
      a_psix = -(wspd(i)*temp9b/psix)
      a_ust(i) = 0.5D0*a_ust(i)
      a_gz1oz0(i) = a_gz1oz0(i) + a_psix
      a_psim(i) = a_psim(i) - a_psix
      CALL POPREAL8(dtg)
      a_theta1(i) = a_theta1(i) + a_dtg
      a_thetag(i) = a_thetag(i) - a_dtg
    END DO
    a_ricut = 0.0_8
    DO i=ite,its,-1
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        temp7 = -(bm*sqlnzz0*br(i)) + 1.0D0
        temp7b = -(am*bm*a_psim(i)/temp7)
        temp8 = -(bh*sqlnzz0*br(i)) + 1.0D0
        temp8b = -(ah*bh*a_psih(i)/temp8)
        a_ah = ALOG(temp8)*a_psih(i)
        a_sqlnzz0 = br(i)*temp7b + br(i)*temp8b
        a_br(i) = a_br(i) + sqlnzz0*temp7b + sqlnzz0*temp8b
        a_psih(i) = 0.0_8
        a_am = ALOG(temp7)*a_psim(i)
        a_psim(i) = 0.0_8
        CALL POPREAL8(sqlnzz0)
        IF (gz1oz0(i) .EQ. 0.0_8) THEN
          a_gz1oz0(i) = a_gz1oz0(i) + 0.355D0*a_ah/gz1oz0(i) + 0.276D0*a_am/&
&            gz1oz0(i)
        ELSE
          a_gz1oz0(i) = a_gz1oz0(i) + 0.355D0*a_ah/gz1oz0(i) + 0.276D0*a_am/&
&            gz1oz0(i) + a_sqlnzz0/(2.0D0*SQRT(gz1oz0(i)))
        END IF
        CALL POPREAL8(ah)
        CALL POPREAL8(am)
      ELSE IF (branch .EQ. 1) THEN
        a_zoll = -(betam*a_psim(i)) - betah*a_psih(i)
        a_psih(i) = 0.0_8
        a_psim(i) = 0.0_8
        temp6 = -(ricriti*br(i)) + 1.0D0
        temp6b = a_zoll/temp6
        a_br(i) = a_br(i) + (br(i)*gz1oz0(i)*ricriti/temp6+gz1oz0(i))*&
&          temp6b
        a_gz1oz0(i) = a_gz1oz0(i) + br(i)*temp6b
      ELSE
        a_zoll = -a_psim(i) - a_psih(i)
        a_psih(i) = 0.0_8
        a_psim(i) = 0.0_8
        temp5 = -(ricriti*ricut(i)) + 1.0D0
        temp5b = a_zoll/temp5
        a_br(i) = a_br(i) + gz1oz0(i)*temp5b
        a_gz1oz0(i) = a_gz1oz0(i) + br(i)*temp5b
        a_ricut(i) = a_ricut(i) + br(i)*gz1oz0(i)*ricriti*temp5b/temp5
      END IF
    END DO
    a_ws = 0.0_8
    a_govrth = 0.0_8
    DO i=ite,its,-1
      a_gz1oz0(i) = a_gz1oz0(i) - a_ricut(i)/(ricriti+gz1oz0(i))**2
      a_ricut(i) = 0.0_8
      dthvdz = thetav1(i) - th0(i)
      temp4 = wspd(i)**2
      temp3 = za(i)/temp4
      temp3b3 = govrth(i)*dthvdz*a_br(i)/temp4
      a_govrth(i) = a_govrth(i) + temp3*dthvdz*a_br(i)
      a_dthvdz = temp3*govrth(i)*a_br(i)
      a_za(i) = a_za(i) + temp3b3
      a_wspd(i) = a_wspd(i) - temp3*2*wspd(i)*temp3b3
      a_br(i) = 0.0_8
      a_theta1(i) = a_theta1(i) - g*a_govrth(i)/theta1(i)**2
      a_govrth(i) = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) a_wspd(i) = 0.0_8
      vconv = vconvc*(g/tg(i)*pblh(i)*fluxc)**.33D0
      IF (vsgd**2 + ws(i)**2 + vconv**2 .EQ. 0.0_8) THEN
        temp3b2 = 0.0D0
      ELSE
        temp3b2 = a_wspd(i)/(2.0D0*SQRT(vsgd**2+ws(i)**2+vconv**2))
      END IF
      a_ws(i) = a_ws(i) + 2*ws(i)*temp3b2
      a_vconv = 2*vconv*temp3b2
      a_wspd(i) = 0.0_8
      CALL POPREAL8(vsgd)
!      IF(x3.lt.0.D0)THEN
!            temp3b1 = 0.0_8
!      ELSE
        IF(pblh(i) .eq. 0.D0 .or. fluxc .eq. 0.D0) THEN
           temp3b1 = 0.0_8
        ELSE
           temp3b1 = g*.33D0*(g*(pblh(i)*fluxc/tg(i)))**(-0.67D0)*vconvc*&
&             a_vconv/tg(i)
        ENDIF
!      ENDIF
      a_pblh(i) = a_pblh(i) + fluxc*temp3b1
      a_fluxc = pblh(i)*temp3b1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(fluxc)
        a_x3 = 0.0_8
      ELSE
        CALL POPREAL8(fluxc)
        a_x3 = a_fluxc
      END IF
      temp3b = a_x3/(cp*rhox(i))
      temp3b0 = ep1*a_x3/rhox(i)
      a_hfx(i) = a_hfx(i) + temp3b
      a_rhox(i) = a_rhox(i) - th0(i)*qfx(i)*temp3b0/rhox(i) - hfx(i)*&
&        temp3b/rhox(i)
      a_th0(i) = a_th0(i) + qfx(i)*temp3b0 - a_dthvdz
      a_qfx(i) = a_qfx(i) + th0(i)*temp3b0
      a_thetav1(i) = a_thetav1(i) + a_dthvdz
      temp2 = za(i)/znt(i)
      temp2b0 = a_gz1oz0(i)/(temp2*znt(i))
      a_za(i) = a_za(i) + temp2b0
      a_znt(i) = a_znt(i) - temp2*temp2b0
      a_gz1oz0(i) = 0.0_8
    END DO
    DO i=ite,its,-1
      IF (us(i)**2 + vs(i)**2 .EQ. 0.0_8) THEN
        temp2b = 0.0D0
      ELSE
        temp2b = a_ws(i)/(2.0D0*SQRT(us(i)**2+vs(i)**2))
      END IF
      a_us(i) = a_us(i) + 2*us(i)*temp2b
      a_vs(i) = a_vs(i) + 2*vs(i)*temp2b
      a_ws(i) = 0.0_8
      a_dz8w1d(i) = a_dz8w1d(i) + 0.5D0*a_za(i)
      a_za(i) = 0.0_8
    END DO
    a_psfc = 0.0_8
    DO i=ite,its,-1
      a_cpot = tg(i)*a_thetag(i)
      a_thetag(i) = 0.0_8
      tv0 = tg(i)*(1.0D0+ep1*qsfc(i)*mavail(i))
      temp1 = 100.D0/psfc(i)
      a_tv0 = temp1**rovcp*a_th0(i)
      IF (.NOT.(temp1 .LE. 0.0_8 .AND. (rovcp .EQ. 0.0_8 .OR. rovcp .NE.&
&          INT(rovcp)))) a_psfc(i) = a_psfc(i) - rovcp*temp1**(rovcp-1.D0)*&
&          tv0*temp1*a_th0(i)/psfc(i)
      a_th0(i) = 0.0_8
      temp0 = 100.D0/psfc(i)
      IF (.NOT.(temp0 .LE. 0.0_8 .AND. (rovcp .EQ. 0.0_8 .OR. rovcp .NE.&
&          INT(rovcp)))) a_psfc(i) = a_psfc(i) - rovcp*temp0**(rovcp-1.D0)*&
&          temp0*a_cpot/psfc(i)
      a_qsfc(i) = a_qsfc(i) + tg(i)*ep1*mavail(i)*a_tv0
    END DO
    DO i=ite,its,-1
      a_qv1d(i) = a_qv1d(i) + cp*0.8D0*a_cpm(i)
      a_cpm(i) = 0.0_8
      a_psfc(i) = a_psfc(i) - ep2*e1*a_qsfc(i)/(psfc(i)-e1)**2
      a_qsfc(i) = 0.0_8
      CALL POPREAL8(e1)
    END DO
    DO i=ite,its,-1
      tvcon = 1.0D0 + ep1*qv1d(i)
      temp = t1d(i)*r*tvcon
      tempb = -(psfcpa(i)*a_rhox(i)/temp**2)
      a_psfcpa(i) = a_psfcpa(i) + a_psfc(i)/1000.D0 + a_rhox(i)/temp
      a_t1d(i) = a_t1d(i) + r*tvcon*tempb
      a_tvcon = theta1(i)*a_thetav1(i) + t1d(i)*r*tempb
      a_rhox(i) = 0.0_8
      a_theta1(i) = a_theta1(i) + tvcon*a_thetav1(i)
      a_thetav1(i) = 0.0_8
      a_qv1d(i) = a_qv1d(i) + ep1*a_tvcon
      a_psfc(i) = 0.0_8
    END DO
  END SUBROUTINE A_PXSFCLAY1D
!====================================================================
END MODULE A_MODULE_SF_PXSFCLAY
