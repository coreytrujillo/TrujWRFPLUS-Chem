!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.6 (r4756) - 12 Feb 2013 10:43
!
!WRF:MEDIATION_LAYER:PHYSICS
!
MODULE G_MODULE_SURFACE_DRIVER
  IMPLICIT NONE
!=======================================================================

CONTAINS
!  Differentiation of surface_driver in forward (tangent) mode (with options r8 noISIZE):
!   variations   of useful results: wspd ust hfx rmol qfx
!   with respect to varying inputs: v_phy pblh th_phy hfx qv_curr
!                t_phy rmol p_phy qfx u_phy p8w rho dz8w
!   RW status of diff variables: v_phy:in wspd:out ust:out pblh:in
!                th_phy:in hfx:in-out qv_curr:in t_phy:in rmol:in-out
!                p_phy:in qfx:in-out u_phy:in p8w:in rho:in dz8w:in
SUBROUTINE G_SURFACE_DRIVER(hydro_dt, &
       sfcheadrt, infxsrt, soldrain, acgrdflx, achfx, aclhf, acsnom, &
       acsnow, akhs, akms, &
       albedo, &!g_albedo   , 
       br, &!g_br, 
       canwat, g_canwat, &
       chklowq, dt, dx, dz8w, g_dz8w, dzs, glw, grdflx, gsw, swdown, &
       gz1oz0, hfx, g_hfx, ht, ifsnow, isfflx, fractional_seaice, &
       seaice_albedo_opt, seaice_albedo_default    , seaice_thickness_opt, &
       seaice_thickness_default, seaice_snowdepth_opt, seaice_snowdepth_max, &
       seaice_snowdepth_min, &
       tice2tsk_if2cold, ifndalbsi, ifndicedepth, ifndsnowsi, isltyp, itimestep, &
       julian_in, ivgtyp, lowlyr, mavail, rmol, g_rmol, num_soil_layers, &
       p8w, g_p8w, pblh, g_pblh, pi_phy, pshltr, fm, fhh, psih, &
       psim, p_phy, g_p_phy, q10, q2, qfx, g_qfx, qsfc, &!g_qsfc, &
       qshltr, qz0, raincv, rho, g_rho, sfcevp, sfcexc, sfcrunoff, &
       smois, g_smois, smstav, smstot, snoalb, snow, snowc, snowh, &
       stepbl, smcrel, th10, th2, thz0, th_phy, g_th_phy, &
       tmn, &!g_tmn, 
       tshltr, tsk, &!g_tsk, 
       tslb, g_tslb, &
       tyr, tyra, &
       tdly, tlag, lagday, nyear, nday, tmn_update, yr, t_phy, g_t_phy, u10, &
       udrunoff, ust, g_ust, uz0, u_frame, u_phy, g_u_phy, v10, &
       vegfra, &!g_vegfra, 
       vz0, v_frame, v_phy, g_v_phy, warm_rain, wspd, g_wspd, &
       xice, xland, z, znt, g_znt, zs, albsi, icedepth, snowsi, xicem, isice, &
       iswater, ct, tke_pbl, albbck, embck, lh, sh2o, shdmax, shdmin, z0, &
       flqc, &!g_flqc, 
       flhc, &!g_flhc, 
       psfc, &!g_psfc, 
       sst, sstsk, dtw, &
       sst_update, sst_skin, scm_force_skintemp, scm_force_flux, &
       t2, &
       emiss, &!g_emiss, 
       sf_sfclay_physics, sf_surface_physics, &
       ra_lw_physics, mosaic_lu, mosaic_soil, landusef, soilctop, soilcbot, &
       ra, rs, nlcat, nscat, vegf_px, &!g_vegf_px, 
       snowncv, anal_interval, &
       lai, &!g_lai, 
       pxlsm_smois_init, pxlsm_soil_nudge, idveg, &
       iopt_crs, iopt_btr, iopt_run, iopt_sfc, iopt_frz, iopt_inf, iopt_rad, &
       iopt_alb, iopt_snf, iopt_tbot, iopt_stc, &
       isnowxy, tvxy, tgxy, canicexy, canliqxy, &
       eahxy, tahxy, cmxy, chxy, fwetxy, sneqvoxy, alboldxy, qsnowxy, wslakexy, &
       zwtxy, waxy, wtxy, tsnoxy, zsnsoxy, snicexy, snliqxy, lfmassxy, &
       rtmassxy, stmassxy, woodxy, stblcpxy, fastcpxy, xsaixy, taussxy, &
       t2mvxy, t2mbxy, q2mvxy, q2mbxy, tradxy, neexy, gppxy, nppxy, &
       fvegxy, runsfxy, runsbxy, ecanxy, edirxy, etranxy, fsaxy, firaxy, &
       aparxy, psnxy, savxy, sagxy, rssunxy, rsshaxy, bgapxy, wgapxy, tgvxy, &
       tgbxy, chvxy, chbxy, shgxy, shcxy, shbxy, evgxy, evbxy, ghvxy, ghbxy, &
       irgxy, ircxy, irbxy, trxy, evcxy, chleafxy, chucxy, chv2xy, chb2xy, chstarxy, &
       ua_phys, flx4, fvb, fbur, fgsn, ch, tsq, qsq, cov, &
!       om_tmp, om_s, om_u, om_v, om_depth, om_ml, om_lon, om_lat, &
!       okms, okme, rdx, rdy, msfu, msfv, msft, &
!       xtime, om_tini, om_sini, id, omdt, &
       slope_rad, topo_shading, shadowmask, swnorm, slope, slp_azi, declin, &
       solcon, coszen, hrang, & 
       cmr_sfcdif, chr_sfcdif, cmc_sfcdif, chc_sfcdif, &
       ids, ide, jds, jde, kds, kde, ims, ime, jms, jme, kms, kme, &
       i_start, i_end, j_start, j_end, kts, kte, num_tiles, &
       qv_curr, g_qv_curr, qc_curr, qr_curr, qi_curr, qs_curr, qg_curr, &
       f_qv, f_qc, f_qr, f_qi, f_qs, f_qg, &
       capg, hol, mol, g_mol, rainncv, rainshv, rainbl, &!g_rainbl, &
       regime, thc, qsg, qvg, qcg, soilt1, &
       tsnav, smfr3d, keepfr3dflag, dew, potevp, snopcx, soiltb, sr, &
       t2_ndg_old, q2_ndg_old, t2_ndg_new, q2_ndg_new, sn_ndg_old, sn_ndg_new, &
       t2obs, q2obs, uratx, vratx, tratx, sf_ocean_physics, oml_hml0, oml_gamma, &
       tml, t0ml, hml, h0ml, huml, hvml, f, tmoml, ustm, g_ustm, ck, cka, cd, cda, &
       isftcflx, iz0tlnd, isurban, mminlu, snotime, rdlai2d, usemonalb, &
       noahres, bldt, curr_secs, adapt_step_flag, bldtacttime, tsk_save, cldfra)


    USE module_model_constants
    USE module_state_description, only : SFCLAYSCHEME, PXSFCSCHEME, SLABSCHEME, PXLSMSCHEME
    USE g_module_sf_pxsfclay
    USE g_module_sf_sfclay
    USE g_module_sf_slab
    USE module_sf_sfcdiags
    USE g_module_sf_pxlsm
    IMPLICIT NONE
!======================================================================
! Grid structure in physics part of WRF
!----------------------------------------------------------------------
! The horizontal velocities used in the physics are unstaggered
! relative to temperature/moisture variables. All predicted
! variables are carried at half levels except w, which is at full
! levels. Some arrays with names (*8w) are at w (full) levels.
!
!----------------------------------------------------------------------
! In WRF, kms (smallest number) is the bottom level and kme (largest
! number) is the top level.  In your scheme, if 1 is at the top level,
! then you have to reverse the order in the k direction.
!
!         kme      -   half level (no data at this level)
!         kme    ----- full level
!         kme-1    -   half level
!         kme-1  ----- full level
!         .
!         kms+2    -   half level
!         kms+2  ----- full level
!         kms+1    -   half level
!         kms+1  ----- full level
!         kms      -   half level
!         kms    ----- full level
!
!======================================================================
! Definitions
!-----------
! Theta      potential temperature (K)
! Qv         water vapor mixing ratio (kg/kg)
! Qc         cloud water mixing ratio (kg/kg)
! Qr         rain water mixing ratio (kg/kg)
! Qi         cloud ice mixing ratio (kg/kg)
! Qs         snow mixing ratio (kg/kg)
!-----------------------------------------------------------------
!-- itimestep     number of time steps
!-- GLW           downward long wave flux at ground surface (W/m^2)
!-- GSW           net short wave flux at ground surface (W/m^2)
!-- SWDOWN        downward short wave flux at ground surface (W/m^2)
!-- EMISS         surface emissivity (between 0 and 1)
!-- TSK           surface temperature (K)
!-- TMN           soil temperature at lower boundary (K)
!-- TYR           annual mean surface temperature of previous year (K)
!-- TYRA          accumulated surface temperature in the current year (K)
!-- TLAG          mean surface temperature of previous 140 days (K)
!-- TDLY          accumulated daily mean surface temperature of the current day (K)
!-- XLAND         land mask (1 for land, 2 for water)
!-- ZNT           time-varying roughness length (m)
!-- Z0            background roughness length (m)
!-- MAVAIL        surface moisture availability (between 0 and 1)
!-- UST           u* in similarity theory (m/s)
!-- MOL           T* (similarity theory) (K)
!-- HOL           PBL height over Monin-Obukhov length
!-- PBLH          PBL height (m)
!-- CAPG          heat capacity for soil (J/K/m^3)
!-- THC           thermal inertia (Cal/cm/K/s^0.5)
!-- SNOWC         flag indicating snow coverage (1 for snow cover)
!-- HFX           net upward heat flux at the surface (W/m^2)
!-- QFX           net upward moisture flux at the surface (kg/m^2/s)
!-- TAUX          RHO*U**2 for ocean coupling
!-- TAUY          RHO*U**2 for ocean coupling
!-- LH            net upward latent heat flux at surface (W/m^2)
!-- REGIME        flag indicating PBL regime (stable, unstable, etc.)
!-- tke_pbl       turbulence kinetic energy from PBL schemes (m^2/s^2)
!-- akhs          sfc exchange coefficient of heat/moisture from MYJ
!-- akms          sfc exchange coefficient of momentum from MYJ
!-- thz0          potential temperature at roughness length (K)
!-- uz0           u wind component at roughness length (m/s)
!-- vz0           v wind component at roughness length (m/s)
!-- qsfc          specific humidity at lower boundary (kg/kg)
!-- uratx         ratio of u over u10 (Added for obs-nudging)
!-- vratx         ratio of v over v10 (Added for obs-nudging)
!-- tratx         ratio of t over th2 (Added for obs-nudging)
!-- u10           diagnostic 10-m u component from surface layer
!-- v10           diagnostic 10-m v component from surface layer
!-- th2           diagnostic 2-m theta from surface layer and lsm
!-- t2            diagnostic 2-m temperature from surface layer and lsm
!-- q2            diagnostic 2-m mixing ratio from surface layer and lsm
!-- tshltr        diagnostic 2-m theta from MYJ
!-- th10          diagnostic 10-m theta from MYJ
!-- qshltr        diagnostic 2-m specific humidity from MYJ
!-- q10           diagnostic 10-m specific humidity from MYJ
!-- lowlyr        index of lowest model layer above ground
!-- rr            dry air density (kg/m^3)
!-- u_phy         u-velocity interpolated to theta points (m/s)
!-- v_phy         v-velocity interpolated to theta points (m/s)
!-- th_phy        potential temperature (K)
!-- moist         moisture array (4D - last index is species) (kg/kg)
!-- p_phy         pressure (Pa)
!-- pi_phy        exner function (dimensionless)
!-- pshltr        diagnostic shelter (2m) pressure from MYJ (Pa)
!-- p8w           pressure at full levels (Pa)
!-- t_phy         temperature (K)
!-- dz8w          dz between full levels (m)
!-- z             height above sea level (m)
!-- DX            horizontal space interval (m)
!-- DT            time step (second)
!-- PSFC          pressure at the surface (Pa)
!-- SST           sea-surface temperature (K)
!-- SSTSK         skin sea-surface temperature (K)
!-- DTW           warm layer temp diff (K)
!-- TSLB
!-- ZS
!-- DZS
!-- num_soil_layers number of soil layer
!-- IFSNOW      ifsnow=1 for snow-cover effects
!-- sf_ocean_physics       whether to call ocean model from slab (1 = oml, 2=3d PWP)
!-- oml_hml0      initial mixed layer depth (if real-data not available, default 50 m)
!-- oml_gamma     lapse rate below mixed layer in ocean (default 0.14 K m-1)
!-- ck            enthalpy exchange coeff at 10 meters
!-- cd            momentum exchange coeff at 10 meters
!-- cka           enthalpy exchange coeff at the lowest model level
!-- cda           momentum exchange coeff at the lowest model level
!!!!!!!!!!!!!!
!
!
!-- LANDUSEF     Landuse fraction                      ! P-X LSM
!-- SOILCTOP     Top soil fraction                     ! P-X LSM
!-- SOILCBOT     Bottom soil fraction                  ! P-X LSM
!-- RA           Aerodynamic resistence                        ! P-X LSM
!-- RS           Stomatal resistence                   ! P-X LSM
!-- NLCAT        Number of landuse categories          ! P-X LSM
!-- NSCAT        Number of soil categories             ! P-X LSM
!-- ch - drag coefficient for heat/moisture            ! MYNN LSM
!
!-- ids           start index for i in domain
!-- ide           end index for i in domain
!-- jds           start index for j in domain
!-- jde           end index for j in domain
!-- kds           start index for k in domain
!-- kde           end index for k in domain
!-- ims           start index for i in memory
!-- ime           end index for i in memory
!-- jms           start index for j in memory
!-- jme           end index for j in memory
!-- kms           start index for k in memory
!-- kme           end index for k in memory
!-- its           start index for i in tile
!-- ite           end index for i in tile
!-- jts           start index for j in tile
!-- jte           end index for j in tile
!-- kts           start index for k in tile
!-- kte           end index for k in tile
!
!******************************************************************
!------------------------------------------------------------------
    INTEGER, INTENT(IN) :: ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&    jme, kms, kme, kts, kte, num_tiles
    INTEGER, INTENT(IN) :: fractional_seaice
    INTEGER, INTENT(IN) :: seaice_albedo_opt
    REAL, INTENT(IN) :: seaice_albedo_default
    INTEGER, INTENT(IN) :: seaice_thickness_opt
    REAL, INTENT(IN) :: seaice_thickness_default
    INTEGER, INTENT(IN) :: seaice_snowdepth_opt
    REAL, INTENT(IN) :: seaice_snowdepth_max
    REAL, INTENT(IN) :: seaice_snowdepth_min
    INTEGER, INTENT(IN) :: ifndalbsi
    INTEGER, INTENT(IN) :: ifndicedepth
    INTEGER, INTENT(IN) :: ifndsnowsi
    INTEGER, INTENT(IN) :: nlcat, mosaic_lu, mosaic_soil
    INTEGER, INTENT(IN) :: nscat
!    INTEGER, INTENT(IN) :: history_interval
    INTEGER, INTENT(IN) :: sf_sfclay_physics, sf_surface_physics, &
&    ra_lw_physics, sst_update
    INTEGER, INTENT(IN), OPTIONAL :: sst_skin, tmn_update, &
&    scm_force_skintemp, scm_force_flux
    INTEGER, DIMENSION(num_tiles), INTENT(IN) :: i_start, i_end, j_start&
&    , j_end
    INTEGER, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: isltyp
    INTEGER, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: ivgtyp
    INTEGER, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: lowlyr
    INTEGER, INTENT(IN) :: ifsnow
    INTEGER, INTENT(IN) :: isfflx
    INTEGER, INTENT(IN) :: itimestep
    INTEGER, INTENT(IN) :: num_soil_layers
    REAL, INTENT(IN), OPTIONAL :: julian_in
    INTEGER, INTENT(IN) :: lagday
    INTEGER, INTENT(IN) :: stepbl
    INTEGER, INTENT(IN) :: isice
    INTEGER, INTENT(IN) :: iswater
    INTEGER, INTENT(IN), OPTIONAL :: isurban
    CHARACTER(len=*), INTENT(IN), OPTIONAL :: mminlu
    LOGICAL, INTENT(IN) :: warm_rain
    LOGICAL, INTENT(IN) :: tice2tsk_if2cold
    INTEGER, INTENT(INOUT), OPTIONAL :: nyear
    REAL, INTENT(INOUT), OPTIONAL :: nday
    INTEGER, INTENT(IN), OPTIONAL :: yr
    REAL, INTENT(IN) :: u_frame
    REAL, INTENT(IN) :: v_frame
!added by Wei Yu for WRF_HYDRO 
    REAL :: hydro_dt
    REAL, DIMENSION(ims:ime, jms:jme) :: sfcheadrt, infxsrt, soldrain
    REAL, DIMENSION(ims:ime, num_soil_layers, jms:jme), INTENT(INOUT) ::&
&    smois
    REAL, DIMENSION(ims:ime, num_soil_layers, jms:jme), INTENT(INOUT) ::&
&    g_smois
    REAL, DIMENSION(ims:ime, num_soil_layers, jms:jme), INTENT(INOUT) :: tslb
    REAL, DIMENSION(ims:ime, num_soil_layers, jms:jme), INTENT(INOUT) :: g_tslb

    REAL, DIMENSION(ims:ime, num_soil_layers, jms:jme) :: smcrel
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: glw
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: gsw, swdown
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: ht
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: raincv
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: sst
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT), OPTIONAL :: sstsk
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT), OPTIONAL :: dtw
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: tmn
!    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: g_tmn
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT), OPTIONAL :: tyr
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT), OPTIONAL :: tyra
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT), OPTIONAL :: tdly
    REAL, DIMENSION(ims:ime, lagday, jms:jme), INTENT(INOUT), OPTIONAL &
&    :: tlag
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: vegfra
!    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: g_vegfra
!------fds (06/2010)--------------------------
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: xice
!---------------------------------------------
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: albsi
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: icedepth
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: snowsi
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: xland
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: xicem
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: mavail
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: snoalb
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: acsnow
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: &
&    snotime
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: akhs
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: akms
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: albedo
!    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: g_albedo
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: canwat
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: g_canwat
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: grdflx
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: hfx
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: g_hfx
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: rmol
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: g_rmol
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: pblh
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: g_pblh
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: q2
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: qfx
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: g_qfx
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: qsfc
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: qz0
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: sfcrunoff
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: smstav
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: smstot
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: snow
!    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: g_snow
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: snowc
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: snowh
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: th2
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: thz0
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: tsk
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: udrunoff
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: ust
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: g_ust
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: uz0
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: vz0
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: wspd
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: g_wspd
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: znt
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: g_znt
!----------------------------------------------------------
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(OUT) :: br
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(OUT) :: chklowq
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(OUT) :: gz1oz0
    REAL, DIMENSION(ims:ime, jms:jme) :: pshltr
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(OUT) :: fhh
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(OUT) :: fm
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(OUT) :: psih
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(OUT) :: psim
    REAL, DIMENSION(ims:ime, jms:jme) :: q10
    REAL, DIMENSION(ims:ime, jms:jme) :: qshltr
    REAL, DIMENSION(ims:ime, jms:jme) :: th10
    REAL, DIMENSION(ims:ime, jms:jme) :: tshltr
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(OUT) :: u10
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(OUT) :: v10
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(OUT) :: psfc
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: acsnom
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: sfcevp
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT), OPTIONAL :: achfx
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT), OPTIONAL :: aclhf
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT), OPTIONAL :: &
&    acgrdflx
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: sfcexc
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: flhc
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: flqc
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: ct
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: dz8w
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: g_dz8w
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: p8w
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: g_p8w
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: pi_phy
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: p_phy
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: g_p_phy
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: rho
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: g_rho
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: th_phy
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: g_th_phy
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: t_phy
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: g_t_phy
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: u_phy
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: g_u_phy
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: v_phy
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: g_v_phy
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(IN) :: z
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), INTENT(INOUT) :: tke_pbl
    REAL, DIMENSION(num_soil_layers), INTENT(IN) :: dzs
    REAL, DIMENSION(num_soil_layers), INTENT(IN) :: zs
    REAL, INTENT(IN) :: dt
    REAL, INTENT(IN) :: dx
    REAL, INTENT(IN), OPTIONAL :: bldt
    REAL, INTENT(IN), OPTIONAL :: curr_secs
    LOGICAL, INTENT(IN), OPTIONAL :: adapt_step_flag
    REAL, INTENT(INOUT), OPTIONAL :: bldtacttime
!  arguments for NCAR surface physics
! INOUT needed for NMM
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: albbck
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: embck
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: lh
    REAL, DIMENSION(ims:ime, num_soil_layers, jms:jme), INTENT(INOUT) ::&
&    sh2o
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: shdmax
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(IN) :: shdmin
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: z0
    INTEGER, OPTIONAL, INTENT(IN) :: idveg, iopt_crs, iopt_btr, iopt_run&
&    , iopt_sfc, iopt_frz, iopt_inf, iopt_rad, iopt_alb, iopt_snf, &
&    iopt_tbot, iopt_stc
    INTEGER, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: &
&    isnowxy
    REAL, DIMENSION(ims:ime, -2:num_soil_layers, jms:jme), OPTIONAL, &
&    INTENT(INOUT) :: zsnsoxy
    REAL, DIMENSION(ims:ime, -2:0, jms:jme), OPTIONAL, INTENT(INOUT) :: &
&    tsnoxy, snicexy, snliqxy
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: tvxy, &
&    tgxy, canicexy, canliqxy, eahxy, tahxy, cmxy, chxy, fwetxy, sneqvoxy&
&    , alboldxy, qsnowxy, wslakexy, zwtxy, waxy, wtxy, lfmassxy, rtmassxy&
&    , stmassxy, woodxy, stblcpxy, fastcpxy, xsaixy, taussxy, t2mvxy, &
&    t2mbxy, q2mvxy, q2mbxy, tradxy, neexy, gppxy, nppxy, fvegxy, runsfxy&
&    , runsbxy, ecanxy, edirxy, etranxy, fsaxy, firaxy, aparxy, psnxy, &
&    savxy, sagxy
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: &
&    rssunxy, rsshaxy, bgapxy, wgapxy, tgvxy, tgbxy, chvxy, chbxy, shgxy&
&    , shcxy, shbxy, evgxy, evbxy, ghvxy, ghbxy, irgxy, ircxy, irbxy, &
&    trxy, evcxy, chleafxy, chucxy, chv2xy, chb2xy, chstarxy
! Noah UA changes
    LOGICAL, INTENT(IN) :: ua_phys
    REAL, DIMENSION(ims:ime, jms:jme) :: flx4, fvb, fbur, fgsn
!  arguments for Ocean Mixed Layer Model
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: tml, &
&    t0ml, hml, h0ml, huml, hvml
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(IN) :: f, tmoml
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(OUT) :: ck, cka&
&    , cd, cda, ustm
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(OUT) :: g_ustm
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: &
&    tsk_save
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: ch
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(IN) :: &
&    tsq, qsq, cov
    INTEGER, OPTIONAL, INTENT(IN) :: slope_rad, topo_shading
    INTEGER, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(IN) :: &
&    shadowmask
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: swnorm
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(IN) :: slope, &
&    slp_azi
    INTEGER, OPTIONAL, INTENT(IN) :: isftcflx, iz0tlnd
    INTEGER, OPTIONAL, INTENT(IN) :: sf_ocean_physics
    REAL, OPTIONAL, INTENT(IN) :: oml_hml0
    REAL, OPTIONAL, INTENT(IN) :: oml_gamma
!
!  Observation nudging
!
!Added for obs-nudging
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(OUT) :: uratx
!Added for obs-nudging
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(OUT) :: vratx
!Added for obs-nudging
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(OUT) :: tratx
!
!  PX LSM Surface Grid Analysis nudging
!
    INTEGER, OPTIONAL, INTENT(IN) :: pxlsm_smois_init, pxlsm_soil_nudge&
&    , anal_interval
    REAL, DIMENSION(ims:ime, nlcat, jms:jme), OPTIONAL, INTENT(INOUT) ::&
&    landusef
    REAL, DIMENSION(ims:ime, nscat, jms:jme), OPTIONAL, INTENT(INOUT) ::&
&    soilctop, soilcbot
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: &
&    vegf_px
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: ra
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: rs
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: lai
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: t2obs
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: q2obs
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: &
&    t2_ndg_old, q2_ndg_old, t2_ndg_new, q2_ndg_new, sn_ndg_old, &
&    sn_ndg_new
!
!
! Flags relating to the optional tendency arrays declared above
! Models that carry the optional tendencies will provdide the
! optional arguments at compile time; these flags all the model
! to determine at run-time whether a particular tracer is in
! use or not.
!
    LOGICAL, INTENT(IN), OPTIONAL :: f_qv, f_qc, f_qr, f_qi, f_qs, f_qg
! optional moisture tracers
! 2 time levels; if only one then use CURR
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(INOUT) &
&    :: qv_curr, qc_curr, qr_curr, qi_curr, qs_curr, qg_curr
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(INOUT) &
&    :: g_qv_curr
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(IN) :: snowncv
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: capg
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: emiss
!    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: g_emiss
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: hol
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: mol
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: g_mol
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: regime
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(IN) :: rainncv
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(IN) :: rainshv
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: rainbl
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: t2
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(IN) :: thc
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: qsg
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: qvg
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: qcg
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: dew
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: soilt1
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: tsnav
! NMM LSM
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: potevp
! NMM LSM
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: snopcx
! NMM LSM
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: soiltb
! NMM and RUC LSM
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: sr
    REAL, DIMENSION(ims:ime, num_soil_layers, jms:jme), OPTIONAL, &
&    INTENT(INOUT) :: smfr3d
    REAL, DIMENSION(ims:ime, num_soil_layers, jms:jme), OPTIONAL, &
&    INTENT(INOUT) :: keepfr3dflag
    REAL, DIMENSION(ims:ime, jms:jme), INTENT(INOUT), OPTIONAL :: noahres
!  LOCAL  VAR
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: v_phytmp
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: g_v_phytmp
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: u_phytmp
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: g_u_phytmp
    REAL, DIMENSION(ims:ime, jms:jme) :: zol
    REAL, DIMENSION(ims:ime, jms:jme) :: g_zol
    REAL, DIMENSION(ims:ime, jms:jme) :: qgh, chs, cpm, chs2, cqs2
    REAL, DIMENSION(ims:ime, jms:jme) :: g_chs, g_cpm
!Changed from I/O to local
    REAL, DIMENSION(ims:ime, jms:jme) :: g_br
    REAL, DIMENSION(ims:ime, jms:jme) :: g_gz1oz0
    REAL, DIMENSION(ims:ime, jms:jme) :: g_psih
    REAL, DIMENSION(ims:ime, jms:jme) :: g_psim
    REAL, DIMENSION(ims:ime, jms:jme) :: g_qsfc !May need to move back to I/O for PBL schemes other than ACM (e.g. QNSE, MYJ, MYNN, TEMF) (Sensitivity is to initial surface pressure, psfc, in wrfinput_d01 -- not a control variable)
    REAL, DIMENSION(ims:ime, jms:jme) :: g_tsk !Not differentiably connected to ACM PBL, but may be to other PBL schemes
    REAL, DIMENSION(ims:ime, jms:jme) :: g_flhc !Needs to be I/O if temfpbl added to AD/TL
    REAL, DIMENSION(ims:ime, jms:jme) :: g_flqc !Needs to be I/O if temfpbl added to AD/TL
    REAL, DIMENSION(ims:ime, jms:jme) :: g_psfc !Needs to be I/O if CAMZM Cumlus added to AD/TL
    REAL, DIMENSION(ims:ime, jms:jme) :: g_vegf_px !PX-Only
    REAL, DIMENSION(ims:ime, jms:jme) :: g_lai     !PX-Only
    REAL, DIMENSION(ims:ime, jms:jme) :: g_capg
    REAL, DIMENSION(ims:ime, jms:jme) :: g_rainbl

! SSIB local variables
    REAL :: zdiff
    REAL, DIMENSION(ims:ime, jms:jme) :: xice_save
!
    REAL :: dtmin, dtbl
!
    INTEGER :: i, j, k, nk, jj, ij
    INTEGER :: gfdl_ntsflg
    LOGICAL :: radiation, myj, frpcpn, isisfc
    LOGICAL, INTENT(IN), OPTIONAL :: rdlai2d
    LOGICAL, INTENT(IN), OPTIONAL :: usemonalb
    REAL :: total_depth, mid_point_depth
    REAL :: tconst, tprior, tnew, yrday, deltat
    REAL :: swsave
    REAL, DIMENSION(ims:ime, jms:jme) :: gswsave
!-------------------------------------------------
! urban related variables are added to declaration
!-------------------------------------------------
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: &
&    cmr_sfcdif
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: &
&    chr_sfcdif
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: &
&    cmc_sfcdif
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: &
&    chc_sfcdif
    REAL, OPTIONAL, INTENT(IN) :: declin, solcon
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(IN) :: coszen
    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(IN) :: hrang
!--------fds (06/2010)---------------------------------------------
    REAL, DIMENSION(ims:ime, kms:kme, jms:jme), OPTIONAL, INTENT(IN) :: &
&    cldfra
    REAL :: day, cloudfrac
!------------------------------------------------------------------
!
    REAL, DIMENSION(ims:ime, jms:jme) :: hfx_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: qfx_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: lh_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: qsfc_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: tsk_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: znt_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: chs_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: chs2_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: cqs2_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: cpm_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: flhc_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: flqc_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: qgh_sea
!
    REAL, DIMENSION(ims:ime, jms:jme) :: psih_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: pblh_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: rmol_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: ust_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: qz0_sea
    REAL, DIMENSION(ims:ime, jms:jme) :: tsk_local
!
    REAL :: xice_threshold
! cyl 3d ocean variable 
!    INTEGER :: okms, okme
!    REAL, DIMENSION(ims:ime, okms:okme, jms:jme), OPTIONAL, INTENT(INOUT&
!&    ) :: om_tmp, om_s, om_u, om_v, om_depth
!    REAL, DIMENSION(ims:ime, okms:okme, jms:jme), OPTIONAL, INTENT(IN) &
!&    :: om_tini, om_sini
!    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(INOUT) :: om_ml&
!&    , om_lat, om_lon
!    REAL, OPTIONAL, INTENT(IN) :: rdx, rdy, xtime, omdt
!    REAL, DIMENSION(ims:ime, jms:jme), OPTIONAL, INTENT(IN) :: msfu, &
!&    msfv, msft
!    INTEGER, OPTIONAL, INTENT(IN) :: id
!
!------------------------------------------------------------------
    CHARACTER(len=256) :: message
    REAL :: next_bl_time
    LOGICAL :: run_param, doing_adapt_dt, decided
    LOGICAL :: do_adapt
    REAL :: pwx1
    REAL :: pwr1
    REAL :: abs1
    REAL :: abs0
!
!
!------------------------------------------------------------------
!
    IF (sf_sfclay_physics .EQ. 0) THEN
      g_wspd = 0.0_8
!      g_ust = 0.0_8 !Should just be a passive subroutine for ust
      RETURN
    ELSE
      IF (fractional_seaice .EQ. 0) THEN
        xice_threshold = 0.5
      ELSE IF (fractional_seaice .EQ. 1) THEN
        xice_threshold = 0.02
      END IF
!$OMP PARALLEL DO &
!$OMP PRIVATE (ij, i, j, k)
      DO ij=1,num_tiles
        DO j=j_start(ij),j_end(ij)
          DO k=kms,kme
            DO i=i_start(ij),i_end(ij)
              g_v_phytmp(i, k, j) = 0.0_8
              v_phytmp(i, k, j) = 0.
              g_u_phytmp(i, k, j) = 0.0_8
              u_phytmp(i, k, j) = 0.
            END DO
          END DO
          DO i=i_start(ij),i_end(ij)
            g_zol(i, j) = 0.0_8
            zol(i, j) = 0.
            qgh(i, j) = 0.
            g_chs(i, j) = 0.0_8
            chs(i, j) = 0.
            g_cpm(i, j) = 0.0_8
            cpm(i, j) = 0.
            chs2(i, j) = 0.
          END DO
        END DO
      END DO
!$OMP END PARALLEL DO
      dtmin = 0.
      dtbl = 0.
! RAINBL in mm (Accumulation between PBL calls)
      IF (PRESENT(rainncv) .AND. PRESENT(rainbl)) THEN
!$OMP PARALLEL DO   &
!$OMP PRIVATE ( ij, i, j, k )
        DO ij=1,num_tiles
          DO j=j_start(ij),j_end(ij)
            DO i=i_start(ij),i_end(ij)
              g_rainbl(i, j) = 0.0_8
              rainbl(i, j) = rainbl(i, j) + raincv(i, j) + rainncv(i, j)
              IF (PRESENT(rainshv)) THEN
                g_rainbl(i, j) = 0.0_8
                rainbl(i, j) = rainbl(i, j) + rainshv(i, j)
              END IF
              IF (rainbl(i, j) .LT. 0.0) THEN
                g_rainbl(i, j) = 0.0_8
                rainbl(i, j) = 0.0
              ELSE
                g_rainbl(i, j) = 0.0_8
                rainbl(i, j) = rainbl(i, j)
              END IF
            END DO
          END DO
        END DO
!$OMP END PARALLEL DO
      ELSE IF (PRESENT(rainbl)) THEN
!$OMP PARALLEL DO   &
!$OMP PRIVATE ( ij, i, j, k )
        DO ij=1,num_tiles
          DO j=j_start(ij),j_end(ij)
            DO i=i_start(ij),i_end(ij)
              g_rainbl(i, j) = 0.0_8
              rainbl(i, j) = rainbl(i, j) + raincv(i, j)
              IF (PRESENT(rainshv)) THEN
                g_rainbl(i, j) = 0.0_8
                rainbl(i, j) = rainbl(i, j) + rainshv(i, j)
              END IF
              IF (rainbl(i, j) .LT. 0.0) THEN
                g_rainbl(i, j) = 0.0_8
                rainbl(i, j) = 0.0
              ELSE
                g_rainbl(i, j) = 0.0_8
                rainbl(i, j) = rainbl(i, j)
              END IF
            END DO
          END DO
        END DO
!$OMP END PARALLEL DO
      END IF
! Update SST
      IF (sst_update .EQ. 1) THEN
        CALL WRF_DEBUG(100, 'SST_UPDATE is on')
!$OMP PARALLEL DO   &
!$OMP PRIVATE ( ij, i, j, k )
        DO ij=1,num_tiles
          DO j=j_start(ij),j_end(ij)
            DO i=i_start(ij),i_end(ij)
              xice_save(i, j) = xicem(i, j)
              IF (xland(i, j) .GT. 1.5 .AND. xice(i, j) .GE. &
&                  xice_threshold .AND. xicem(i, j) .LT. xice_threshold) &
&              THEN
! water point turns to sea-ice point
                xicem(i, j) = xice(i, j)
                xland(i, j) = 1.
                ivgtyp(i, j) = isice
                isltyp(i, j) = 16
!                g_vegfra(i, j) = 0.0_8
                vegfra(i, j) = 0.
!                g_tmn(i, j) = 0.0_8
                tmn(i, j) = 271.4
! Over new ice, initial guesses of ALBEDO and EMISS are
! based on default water and ice values for albedo and
! emissivity.  The land-surface schemes can update these
! values
                SELECT CASE  (seaice_albedo_opt) 
                CASE (0, 1) 
!                  g_albedo(i, j) = 0.0_8
                  albedo(i, j) = seaice_albedo_default*xice(i, j) + 0.08&
&                    *(1.0-xice(i, j))
                  albbck(i, j) = seaice_albedo_default
                CASE (2) 
                  !+!IF (albsi(i, j) .LT. -1.e6) CALL WRF_ERROR_FATAL('Fiel&
!+!&d ALBSI not found in input.  Field ALBSI is required if SEAICE_ALBEDO_O&
!+!&PT=2'                                                      )
!                  g_albedo(i, j) = 0.0_8
                  albedo(i, j) = albsi(i, j)*xice(i, j) + 0.08*(1.0-xice&
&                    (i, j))
                  albbck(i, j) = albsi(i, j)
                END SELECT
!                g_emiss(i, j) = 0.0_8
                emiss(i, j) = 0.98*xice(i, j) + 0.98*(1.0-xice(i, j))
                embck(i, j) = 0.98
                DO nk=1,num_soil_layers
                  g_tslb(i, nk, j) = 0.0_8
                  tslb(i, nk, j) = tsk(i, j)
                  g_smois(i, nk, j) = 0.0_8
                  smois(i, nk, j) = 1.0
                  sh2o(i, nk, j) = 0.0
                END DO
              END IF
              IF (xland(i, j) .GT. 1.5) THEN
                IF (sst(i, j) .LT. 350. .AND. sst(i, j) .GT. 250.) THEN
                  g_tsk(i, j) = 0.0_8
                  tsk(i, j) = sst(i, j)
                  g_tslb(i, 1, j) = 0.0_8
                  tslb(i, 1, j) = sst(i, j)
                END IF
              END IF
              IF (xland(i, j) .LT. 1.5 .AND. xicem(i, j) .GE. &
&                  xice_threshold .AND. xice(i, j) .LT. xice_threshold) &
&              THEN
! sea-ice point turns to water point
                xicem(i, j) = xice(i, j)
                xland(i, j) = 2.
                ivgtyp(i, j) = iswater
                isltyp(i, j) = 14
!                g_vegfra(i, j) = 0.0_8
                vegfra(i, j) = 0.
!                g_snow(i, j) = 0.0_8
                snow(i, j) = 0.
                snowc(i, j) = 0.
                snowh(i, j) = 0.
!                g_tmn(i, j) = 0.0_8
                tmn(i, j) = sst(i, j)
!                g_albedo(i, j) = 0.0_8
                albedo(i, j) = 0.08
                albbck(i, j) = 0.08
!                g_emiss(i, j) = 0.0_8
                emiss(i, j) = 0.98
                embck(i, j) = 0.98
                DO nk=1,num_soil_layers
                  g_tslb(i, nk, j) = 0.0_8
                  tslb(i, nk, j) = sst(i, j)
                  g_smois(i, nk, j) = 0.0_8
                  smois(i, nk, j) = 1.0
                  sh2o(i, nk, j) = 1.0
                END DO
              END IF
              xice_save(i, j) = xicem(i, j)
              xicem(i, j) = xice(i, j)
            END DO
          END DO
        END DO
!$OMP END PARALLEL DO
      END IF

!
! Modified for adaptive time step
!
      doing_adapt_dt = .false.
      IF (PRESENT(adapt_step_flag)) THEN
        IF (adapt_step_flag) doing_adapt_dt = .true.
      END IF
!  Do we run through this scheme or not?
!    Test 1:  If this is the initial model time, then yes.
!                ITIMESTEP=1
!    Test 2:  If the user asked for the surface to be run every time step, then yes.
!                BLDT=0 or STEPBL=1
!    Test 3:  If not adaptive dt, and this is on the requested surface frequency, then yes.
!                MOD(ITIMESTEP,STEPBL)=0
!    Test 4:  If using adaptive dt and the current time is past the last requested activate surface time, then yes.
!                CURR_SECS >= BLDTACTTIME
!  If we do run through the scheme, we set the flag run_param to TRUE and we set the decided flag
!  to TRUE.  The decided flag says that one of these tests was able to say "yes", run the scheme.
!  We only proceed to other tests if the previous tests all have left decided as FALSE.
      run_param = .false.
      decided = .false.
      IF (.NOT.decided .AND. itimestep .EQ. 1) THEN
        run_param = .true.
        decided = .true.
      END IF
      IF (PRESENT(bldt)) THEN
        IF (.NOT.decided .AND. (bldt .EQ. 0. .OR. stepbl .EQ. 1)) THEN
          run_param = .true.
          decided = .true.
        END IF
      ELSE IF (.NOT.decided .AND. stepbl .EQ. 1) THEN
        run_param = .true.
        decided = .true.
      END IF
      IF (.NOT.decided .AND. (.NOT.doing_adapt_dt) .AND. MOD(itimestep, &
&          stepbl) .EQ. 0) THEN
        run_param = .true.
        decided = .true.
      END IF
      IF (.NOT.decided .AND. doing_adapt_dt .AND. curr_secs .GE. &
&          bldtacttime) THEN
        run_param = .true.
        decided = .true.
      END IF
      IF (run_param) THEN
        radiation = .false.
        frpcpn = .false.
        IF (ra_lw_physics .GT. 0) radiation = .true.
!----
! CALCULATE CONSTANT
        dtmin = dt/60.
! Surface schemes need PBL time step for updates and accumulations
! Assume these schemes provide no tendencies
        IF (PRESENT(adapt_step_flag)) THEN
          IF (adapt_step_flag) THEN
            do_adapt = .true.
          ELSE
            do_adapt = .false.
          END IF
        ELSE
          do_adapt = .false.
        END IF
        IF (PRESENT(bldt)) THEN
          IF (bldt .EQ. 0.) THEN
            dtbl = dt
            g_psfc = 0.0_8
            g_u_phytmp = 0.0_8
            g_v_phytmp = 0.0_8
          ELSE IF (do_adapt) THEN
            !+!IF (curr_secs .LT. 2.*dt) THEN
              !+!CALL WRF_MESSAGE(&
!+!&          'WARNING: When using an adaptive time-step the boundary layer'&
!+!&                         //&
!+!&         ' time-step should be 0 (i.e., equivalent to model time-step).'&
!+!&                        )
              !+!CALL WRF_MESSAGE(&
!+!&                   'In order to proceed, for surface calculations, the '&
!+!&                         //'boundary layer time-step'//&
!+!&                         ' will be rounded to the nearest minute,')
              !+!CALL WRF_MESSAGE(&
!+!&                         'possibly resulting in innacurate results.')
            !+!END IF
            dtbl = bldt*60.
            g_psfc = 0.0_8
            g_u_phytmp = 0.0_8
            g_v_phytmp = 0.0_8
          ELSE
            dtbl = dt*stepbl
            g_psfc = 0.0_8
            g_u_phytmp = 0.0_8
            g_v_phytmp = 0.0_8
          END IF
        ELSE
          dtbl = dt*stepbl
          g_psfc = 0.0_8
          g_u_phytmp = 0.0_8
          g_v_phytmp = 0.0_8
        END IF
! SAVE OLD VALUES
!$OMP PARALLEL DO   &
!$OMP PRIVATE ( ij, i, j, k )
        DO ij=1,num_tiles
          DO j=j_start(ij),j_end(ij)
            DO i=i_start(ij),i_end(ij)
! PSFC : in Pa
              g_psfc(i, j) = g_p8w(i, kts, j)
              psfc(i, j) = p8w(i, kts, j)
! REVERSE ORDER IN THE VERTICAL DIRECTION
              DO k=kts,kte
                g_v_phytmp(i, k, j) = g_v_phy(i, k, j)
                v_phytmp(i, k, j) = v_phy(i, k, j) + v_frame
                g_u_phytmp(i, k, j) = g_u_phy(i, k, j)
                u_phytmp(i, k, j) = u_phy(i, k, j) + u_frame
              END DO
            END DO
          END DO
        END DO
!$OMP END PARALLEL DO
        g_wspd = 0.0_8
        g_br = 0.0_8
        g_qsfc = 0.0_8
        g_psih = 0.0_8
        g_psim = 0.0_8
        g_gz1oz0 = 0.0_8
        g_flqc = 0.0_8
        g_flhc = 0.0_8
        g_cpm = 0.0_8
        g_chs = 0.0_8
        g_zol = 0.0_8
!Need to propogate from previous time step -JJG
!        g_ust = 0.0_8
!        g_mol = 0.0_8
!        g_ustm = 0.0_8
!        g_znt = 0.0_8
!$OMP PARALLEL DO   &
!$OMP PRIVATE ( ij, i, j, k )
        DO ij=1,num_tiles
          SELECT CASE  (sf_sfclay_physics) 
          CASE (sfclayscheme) 
            IF (PRESENT(qv_curr) .AND. PRESENT(mol) .AND. PRESENT(regime&
&                ) .AND. .true.) THEN
              CALL WRF_DEBUG(100, 'in SFCLAY')
              CALL G_SFCLAY(u_phytmp, g_u_phytmp, v_phytmp, g_v_phytmp, &
&                      t_phy, g_t_phy, qv_curr, g_qv_curr, p_phy, g_p_phy&
&                      , dz8w, g_dz8w, cp, g, rcp, r_d, xlv, psfc, g_psfc&
&                      , chs, g_chs, chs2, cqs2, cpm, g_cpm, znt, g_znt, &
&                      ust, g_ust, pblh, g_pblh, mavail, zol, g_zol, mol&
&                      , g_mol, regime, psim, g_psim, psih, g_psih, fm, &
&                      fhh, xland, hfx, g_hfx, qfx, g_qfx, lh, tsk, flhc&
&                      , g_flhc, flqc, g_flqc, qgh, qsfc, g_qsfc, rmol, &
&                      g_rmol, u10, v10, th2, t2, q2, gz1oz0, g_gz1oz0, &
&                      wspd, g_wspd, br, g_br, isfflx, dx, svp1, svp2, &
&                      svp3, svpt0, ep_1, ep_2, karman, eomeg, stbolt, &
&                      p1000mb, ids, ide, jds, jde, kds, kde, ims, ime, &
&                      jms, jme, kms, kme, i_start(ij), i_end(ij), &
&                      j_start(ij), j_end(ij), kts, kte, ustm, g_ustm, ck&
&                      , cka, cd, cda, isftcflx, iz0tlnd, scm_force_flux)
              DO j=j_start(ij),j_end(ij)
                DO i=i_start(ij),i_end(ij)
                  ch(i, j) = chs(i, j)
                END DO
              END DO
            !+!ELSE
!!             ch(i,j) = flhc(i,j)/( cpm(i,j)*rho(i,kts,j) )
              !+!CALL WRF_ERROR_FATAL(&
!+!&                        'Lacking arguments for SFCLAY in surface driver'&
!+!&                            )
            END IF
          CASE (pxsfcscheme) 
            IF (PRESENT(qv_curr) .AND. PRESENT(mol) .AND. PRESENT(regime&
&                ) .AND. .true.) THEN
              CALL WRF_DEBUG(100, 'in PX Surface Layer scheme')
              CALL G_PXSFCLAY(u_phytmp, g_u_phytmp, v_phytmp, g_v_phytmp&
&                        , t_phy, g_t_phy, th_phy, g_th_phy, qv_curr, &
&                        g_qv_curr, p_phy, dz8w, g_dz8w, cp, g, rcp, r_d&
&                        , xlv, psfc, g_psfc, chs, g_chs, chs2, cqs2, cpm&
&                        , g_cpm, znt, g_znt, ust, g_ust, pblh, g_pblh, &
&                        mavail, zol, g_zol, mol, g_mol, regime, psim, &
&                        g_psim, psih, g_psih, xland, hfx, g_hfx, qfx, &
&                        g_qfx, lh, tsk, flhc, g_flhc, flqc, g_flqc, qgh&
&                        , qsfc, g_qsfc, rmol, g_rmol, u10, v10, gz1oz0, &
&                        g_gz1oz0, wspd, g_wspd, br, g_br, isfflx, dx, &
&                        svp1, svp2, svp3, svpt0, ep_1, ep_2, karman, ids&
&                        , ide, jds, jde, kds, kde, ims, ime, jms, jme, &
&                        kms, kme, i_start(ij), i_end(ij), j_start(ij), &
&                        j_end(ij), kts, kte)
            !+!ELSE
              !+!CALL WRF_ERROR_FATAL(&
!+!&              'Lacking arguments for PX Surface Layer in surface driver'&
!+!&                            )
            END IF
          CASE DEFAULT
            WRITE(message, *) &
&            'The sfclay option does not exist: sf_sfclay_physics = ', &
&            sf_sfclay_physics
            !+!CALL WRF_ERROR_FATAL(message)
          END SELECT
!  Compute uratx, vratx, tratx for obs nudging
          IF (PRESENT(uratx) .AND. PRESENT(vratx) .AND. PRESENT(tratx)) &
&          THEN
            DO j=j_start(ij),j_end(ij)
              DO i=i_start(ij),i_end(ij)
                IF (u10(i, j) .GE. 0.) THEN
                  abs0 = u10(i, j)
                ELSE
                  abs0 = -u10(i, j)
                END IF
                IF (abs0 .GT. 1.e-10) THEN
                  uratx(i, j) = u_phytmp(i, 1, j)/u10(i, j)
                ELSE
                  uratx(i, j) = 1.2
                END IF
                IF (v10(i, j) .GE. 0.) THEN
                  abs1 = v10(i, j)
                ELSE
                  abs1 = -v10(i, j)
                END IF
                IF (abs1 .GT. 1.e-10) THEN
                  vratx(i, j) = v_phytmp(i, 1, j)/v10(i, j)
                ELSE
                  vratx(i, j) = 1.2
                END IF
! (Quotient P1000mb/P_PHY must be conditioned due to large value of P1000mb)
                pwx1 = p1000mb*0.001/(p_phy(i, 1, j)/1000.)
                pwr1 = pwx1**rcp
                tratx(i, j) = t_phy(i, 1, j)*pwr1/th2(i, j)
              END DO
            END DO
          END IF
        END DO
!$OMP END PARALLEL DO
        IF (isfflx .NE. 0) THEN
          g_lai = 0.0_8
          g_capg = 0.0_8
          g_vegf_px = 0.0_8
          g_tsk = 0.0_8
!          g_tslb = 0.0_8 !Need to propogate from previous time step -JJG
!          g_smois = 0.0_8
!          g_canwat = 0.0_8
!$OMP PARALLEL DO   &
!$OMP PRIVATE ( ij, i, j, k ) firstprivate(frpcpn)
          DO ij=1,num_tiles
            SELECT CASE  (sf_surface_physics) 
            CASE (slabscheme) 
              IF (PRESENT(qv_curr) .AND. PRESENT(capg) .AND. .true.) &
&              THEN
                DO j=j_start(ij),j_end(ij)
                  DO i=i_start(ij),i_end(ij)
!          CQS2 ACCOUNTS FOR MAVAIL FOR SFCDIAGS 2M Q
                    cqs2(i, j) = cqs2(i, j)*mavail(i, j)
                  END DO
                END DO
                CALL WRF_DEBUG(100, 'in SLAB')
                CALL G_SLAB(t_phy, g_t_phy, qv_curr, g_qv_curr, p_phy, &
&                      g_p_phy, flhc, g_flhc, flqc, g_flqc, psfc, g_psfc&
&                      , xland, tmn, hfx, g_hfx, qfx, g_qfx, lh, tsk, &
&                      g_tsk, qsfc, chklowq, gsw, glw, capg, g_capg, thc&
&                      , snowc, emiss, mavail, dtbl, rcp, xlv, dtmin, &
&                      ifsnow, svp1, svp2, svp3, svpt0, ep_2, karman, &
&                      eomeg, stbolt, tslb, g_tslb, zs, dzs, &
&                      num_soil_layers, radiation, p1000mb, ids, ide, jds&
&                      , jde, kds, kde, ims, ime, jms, jme, kms, kme, &
&                      i_start(ij), i_end(ij), j_start(ij), j_end(ij), &
&                      kts, kte)
                DO j=j_start(ij),j_end(ij)
                  DO i=i_start(ij),i_end(ij)
                    sfcevp(i, j) = sfcevp(i, j) + qfx(i, j)*dtbl
                    IF (PRESENT(achfx)) achfx(i, j) = achfx(i, j) + hfx(&
&                        i, j)*dt
                    IF (PRESENT(aclhf)) aclhf(i, j) = aclhf(i, j) + lh(i&
&                        , j)*dt
                  END DO
                END DO
                CALL WRF_DEBUG(100, 'in SFCDIAGS')
                CALL SFCDIAGS(hfx, qfx, tsk, qsfc, chs2, cqs2, t2, th2, &
&                        q2, psfc, cp, r_d, rcp, chs, t_phy, qv_curr, &
&                        ua_phys, ids, ide, jds, jde, kds, kde, ims, ime&
&                        , jms, jme, kms, kme, i_start(ij), i_end(ij), &
&                        j_start(ij), j_end(ij), kts, kte)
              END IF
            CASE (pxlsmscheme) 
              IF (PRESENT(qv_curr) .AND. PRESENT(qc_curr) .AND. PRESENT(&
&                  emiss) .AND. PRESENT(t2) .AND. PRESENT(rainbl) .AND. &
&                  .true.) THEN
                CALL WRF_DEBUG(100, 'in P-X LSM')
                CALL G_PXLSM(u_phy, v_phy, dz8w, g_dz8w, qv_curr, &
&                       g_qv_curr, t_phy, g_t_phy, th_phy, g_th_phy, rho&
&                       , g_rho, psfc, g_psfc, gsw, glw, rainbl, emiss, &
&                       itimestep, curr_secs, num_soil_layers, dt, &
&                       anal_interval, xland, xice, albbck, albedo, &
!&                       g_albedo, &
&                       snoalb, smois, g_smois, tslb, g_tslb, &
&                       mavail, t2, q2, zs, dzs, psih, landusef, soilctop&
&                       , soilcbot, vegfra, vegf_px, g_vegf_px, isltyp, &
&                       ra, rs, lai, g_lai, nlcat, nscat, hfx, g_hfx, qfx&
&                       , g_qfx, lh, tsk, g_tsk, sst, znt, g_znt, canwat&
&                       , g_canwat, grdflx, shdmin, shdmax, snowc, pblh, &
&                       g_pblh, rmol, g_rmol, ust, g_ust, capg, g_capg, &
&                       dtbl, t2_ndg_old, t2_ndg_new, q2_ndg_old, &
&                       q2_ndg_new, sn_ndg_old, sn_ndg_new, snow &!g_snow&
&                       , snowh, snowncv, t2obs, q2obs, &
&                       pxlsm_smois_init, pxlsm_soil_nudge, ids, ide, jds&
&                       , jde, kds, kde, ims, ime, jms, jme, kms, kme, &
&                       i_start(ij), i_end(ij), j_start(ij), j_end(ij), &
&                       kts, kte)
                DO j=j_start(ij),j_end(ij)
                  DO i=i_start(ij),i_end(ij)
                    chklowq(i, j) = 1.0
                    pwx1 = 1.e5/psfc(i, j)
                    pwr1 = pwx1**rcp
                    th2(i, j) = t2(i, j)*pwr1
                    sfcevp(i, j) = sfcevp(i, j) + qfx(i, j)*dtbl
                  END DO
                END DO
              !+!ELSE
                !+!CALL WRF_ERROR_FATAL(&
!+!&                       'Lacking arguments for P-X LSM in surface driver'&
!+!&                              )
              END IF
            CASE DEFAULT
              WRITE( message , * ) &
               'No land surface physics option is used: sf_surface_physics = ', sf_surface_physics
               !+!CALL wrf_message ( message )
            END SELECT
          END DO
!$OMP END PARALLEL DO
        END IF
! Reset RAINBL in mm (Accumulation between PBL calls)
        IF (PRESENT(rainbl)) THEN
!$OMP PARALLEL DO   &
!$OMP PRIVATE ( ij, i, j, k )
          DO ij=1,num_tiles
            DO j=j_start(ij),j_end(ij)
              DO i=i_start(ij),i_end(ij)
                rainbl(i, j) = 0.
              END DO
            END DO
          END DO
!$OMP END PARALLEL DO
        END IF
      ELSE
        g_wspd = 0.0_8
        g_ust = 0.0_8
      END IF
    END IF
  END SUBROUTINE G_SURFACE_DRIVER

END MODULE G_MODULE_SURFACE_DRIVER
